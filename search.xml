<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017 CCF 大数据竞赛Top4%]]></title>
    <url>%2F2018%2F03%2F13%2F2017-CCF-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9BTop4%2F</url>
    <content type="text"><![CDATA[2017 CCF 大数据比赛记录（首赛）此次是在CCF平台与天池平台联合举办的大数据比赛，题目是：商场中精确定位用户所在店铺，主办方是蚂蚁金服。我和朋友两个人都是第一次参加这种大数据比赛，也算一步一个坑走了过来…线下赛最终经过反作弊筛选后是前100，共有2845支队伍。最后因为我俩临近期末考试，比赛也就就此结束了。 赛题给出用户在商场使用手机支付时所采集到的信息，包括用户信息，店铺信息，商场信息等，要求预测给出上述信息后精准预测用户所在店铺。具体给出的数据表可以点击这里来看。 赛题分析 问题初看是多分类问题，但是如果直接处理的话$label$上千个。仔细观察题目可以发现， 不同商场里面的商店相互独立，所以这里考虑为每一个商场建立一个独立的预测模型。 WiFi信息信息量最大，为主要信息。但是所给WiFi信息繁杂不规范，给WiFi信息找到合理的处理模式至关重要（WiFi指纹）。 如何挖掘WiFi隐含信息，并建立其与$label$之间的关联（具体WiFi id、信号强度、连接与否）至关重要。 WiFi信息中有比较稳定的WiFi（商店自己的WiFi），有用户的个人热点，还有各种公共WiFi（CMCC之类的）。这里讲后两者当做是不稳定WiFi，或者说是噪音WiFi，预测时过滤掉 许多记录WiFi信息缺失，将此作为异常值直接删除（因为总数据量大，单条数据影响不大，WiFi信息又为最重要的信息） 不同商铺的经纬、WiFi信息有大量重合，说明商场存在多楼层问题，并且单单依靠原始WiFi信息无法全面对楼层进行区分。 按照商场划分模型后，每个商场还是有几十上百个$label$，可以多分类，或者二分类构造多分类。（因为$label$多，二分类构造多分类会遇到$label$不均衡的问题，需依靠采样来解决） 百万数据，训练时间成本太高，需要在特征工程、反复验证时减小时间成本。（前期用$LR$模型试错） 也算带有时间序列，如何构造可靠的线下验证集 顾客数据训练集与预测集交集仅为三分之一，顾客特征是否为噪音（我们尝试过顾客特征空值填充、保留，取顾客有交集的单独训练，效果均不好） 我们的具体操作数据预处理 删除公共WiFi：如果一个WiFi在一个以上商场出现或者在某个商场覆盖率超过一定范围，那么可以断定此WiFi为噪音信息 删除移动热点或者出现次数较少的WiFi：如果一个wifi出现次数少于某个阈值或者出现时间仅有一天，那么可以断定次WiFi为噪音信息 训练集和测试集WiFi取交集，因为对于以后要构建的WiFi指纹 删除WiFi信息为空的记录 $GPS$离群点的删除 定义不同等级稳定WiFi列表（不同等级原因某些特征防止维度爆炸），WiFi出现总次数超过一定阈值或者频率前200 字典：shop历史WiFi 经纬度信息该题目给了两种经纬度信息店铺经纬度和购买发生时候的经纬度（预测集只有后者）。两种经纬度理论上差距应该很小，实际差距很大。单独利用经纬度信息训练的结果并不理想，印象中只有70%多一点。 对经纬度数值做了泛化（精确小数点位数），印象中最后的粒度可能在10米左右 $L1、L2$距离，在商场中随意选择一个点做基准，经纬度到这个点的距离 经纬度聚类、以商铺经纬为质心聚类，然后哑编码（没有提升，后来没用） 时间特征的处理 饭点指示器（万分位的提升） 早晨深夜指示器，因为这两种店铺可能比较固定 用户特征构造的所有的用户特征在我们这都是坑，一是因为训练集、预测集用户交集只有$1/3$左右，我们尝试过空值填充、空值保留、只保留交集部分用户特征、对交集部分用户单独训练预测…均是强力的反向上分特征。另一个原因可能是，每个用户在数据统计量均不足，没有统计意义，所以这就类似于$ID$类特征，妥妥没有现实意义的过拟合特征。 用户购买力 用户常去商店 用户与WiFi相关特征 WiFi特征WiFi特征是最为重要的特征，我们构建的如下的WiFi特征 当前记录连接到的最强WiFi仅用这一个特征采取规则预测准确率也可达到80%，是个强特。哑编码。 记录中稳定WiFi的数量商场WiFi原点根据商场稳定WiFi（等级频率前50）建立一个基准点，计算每条数据到基准点的距离（离散化之后），没有的稳定WiFi按照强度为-99处理。 WiFi指纹根据商场稳定WiFi（等级频数大于20），训练集、预测集上下$concat$将所有WiFi id展开为特征，值为当前记录对应WiFi的强度，将强度离散化（粒度为10）. WiFi评分（最后仅用于规则）遍历数据建立嵌套字典$WiFi_score$，一层$key$为WiFi id，二层$key$为一层WiFi出现过的店铺，二层$val$为历史上该WiFi在该店铺强度的中位数。打分，对于每条数据的稳定WiFi信息，遍历嵌套字典$WiFi_score$，用打分函数对每条WiFi出现过的店铺打分。分数结果最高的直接作为结果。打分函数如下： f=1-tanh({|power_{now}-power_{middle}|\over k})其中： $tanh={e^x-e^{-x}\over e^x+e^{-x}}$ $power_{now}$表示当前记录中当前WiFi强度 $power_{middle}$表示嵌套字典中当前WiFi对各商店的强度中位数 $k$为参数，最后确定值为2 仅仅用该种规则，不用机器学习模型，精度就可以达到87%+（还是89%+来着）。但是当时将所得结果转化为特征加入模型训练，分数强力掉了一波。不用说，这里用了训练集构造的规则结果当特征继续加入训练集训练当然会造成$label leak$，也就是强力过拟合。 遗憾的是，当时没考虑采用滑动窗口，更没有使用候选集，这个特征就放弃了…如果采用滑动窗口，在特征采取区间构造嵌套字典$WiFi_score$，打分结果加在训练区间的特征，结果应该不会差。 如果在滑动窗口的基础上，采用候选集（甚至可以用这个打分函数构造候选集），并把分数当做该条记录对候选商店的特征，绝对会是个强力特征（这里其实可以理解为类条件概率） WiFi id组合的最长公共子串典型看起来巧妙没有卵用系列 xgb构造特征组合用$model.apply()$返回叶子节点$index$构造特征。注意此部分一定要划分数据集，即一部分数据用于生成特征，另一部分数据集用于加入该部分生成特征并训练。 总结以上就是比赛用到的、或者有代表性值得拿出来说的特征。这里发现其实我们的特征并不多，其实我们比赛时候尝试构造过远远比这多得多的特征，只是因为效果或者训练时间的原因，最后筛选剩这些。挖空心思构造各种想法复杂、实现困难、强力掉分的反向特征实在是能锤炼人强大的灵魂 ：）。 滑窗的欠缺 无法构造统计类特征，构造了会造成过拟合 训练集过大时间成本过高 既然也是时间序列，信息或多或少有时效性（比如WiFi） 候选集的欠缺 无法构造联合特征，商店-WiFi，商店-经纬度等等 完全丢弃了任何商店特征，包括特别重要的统计特征 训练成本过高，或者要下采样 总之，这两种的欠缺也早早为我们的特征工程确定了天花板，也大大限制了我们特征的提取，少了这两项能够造的有效特征数量至少少了70% 数据集的划分这里说一下我们实际的数据集划分，在最后给出可能的改进。 这是个时间相关的问题，而且数据量比较大，就放弃了分层$k$折交叉，我们选取一个周作为本地验证集 模型训练模型选择最开始我们用的是$xgboost$的多分类模型，分商场进行预测，效果一般。然后转向使用二分类实现多分类，提升显著。具体为每次将一个$label$作为正例，其他作为反例，每次输出每条记录是该正例的概率，最后以最大概率的$label$作为预测结果 样本不均衡每次有将近100个$label$每次只将一个当做正例，正负样本比会非常小，会导致时间成本过长，精度下降，需要靠采样解决。 我们直接放弃了上采样跟随机下采样，前者会加大时间成本后者因为样本比相差悬殊，随机采样可能破坏边界样本的分布。我们直接选用了用规则下采样以保存边界有效信息，具体通过购买经纬度与店铺经纬度的距离与当前样本$top2$强度任一WiFi存在历史列表的shop的并集。这样加快了训练速度，但是精度略有损失，可能因为评价指标是$AUC$所以对样本不均衡不敏感。我们最后还是放弃了采样。 模型参数xgb的模型参数就常用的那几个： 1、eta[默认0.3]和GBM中的 learning rate 参数类似。 通过减少每一步的权重，可以提高模型的鲁棒性。 典型值为0.01-0.2。 2、min_child_weight[默认1]建立每个模型所需要的最小样本数。决定最小叶子节点样本权重和。 和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。 这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。 但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。 3、max_depth[默认6]和GBM中的参数相同，这个值为树的最大深度。 这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。 需要使用CV函数来进行调优。 典型值：3-10 4、max_leaf_nodes树上最大的节点或叶子的数量。 可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n2个叶子。 如果定义了这个参数，GBM会忽略max_depth参数。 5、gamma[默认0]在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。 这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。 6、max_delta_step[默认0]这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。 通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。 这个参数一般用不到，但是你可以挖掘出来它更多的用处。 7、subsample[默认1]和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。 减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。 典型值：0.5-1 8、colsample_bytree[默认1]和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。 典型值：0.5-1 9、colsample_bylevel[默认1]用来控制树的每一级的每一次分裂，对列数的采样的占比。 我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。 10、lambda[默认1]权重的L2正则化项。(和Ridge regression类似)。 这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。 11、alpha[默认1]权重的L1正则化项。(和Lasso regression类似)。 可以应用在很高维度的情况下，使得算法的速度更快。 12、scale_pos_weight[默认1]在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。 真正调参方法 选择较高的学习速率(learning rate)。一般情况下，学习速率的值为0.1。但是，对于不同的问题，理想的学习速率有时候会在0.05到0.3之间波动。选择对应于此学习速率的理想决策树数量。 对于给定的学习速率和决策树数量，进行决策树特定参数调优(max_depth, min_child_weight, gamma, subsample, colsample_bytree)。 xgboost的正则化参数的调优。(lambda, alpha)。这些参数可以降低模型的复杂度，从而提高模型的表现。 降低学习速率，确定理想参数。 实际上比赛的调参因为数据量巨大，样本充足，所以实际上参数不是太差的话对结果影响不是很大。况且大的数据量调参时间成本太高，而且这个比赛自始至终不是一个分类器，90+的商场每个商场有多少个$label$就有多少个分类器，总共上千个不同分类器，也不可能找出每个分类器最适合的参数。因此本次比赛只是在刚开始时调整了一下树的深度，最后的时候调整了一下过拟合的参数。 模型融合最后我们取了$0.65xgb+0.35lgb$简单的加权融合，融合方法是直接把二分类生成的概率加权相加，选出概率最大的当做$label$。 其实可以再融合上多分类，提高模型融合的多样性，但是因为我们没分滑窗，训练时间巨长，就没再添加。 本次比赛不可能$stacking$，就像不可能$CV$一样，训练一次时间都受不了，更别说反复多次。 后话这次比赛成绩不算好，但第一次正式参赛，通过比赛收获了很多，一整套流程熟悉了一遍，对模型、特征的理解也深了好多。我跟朋友两个一步一个坑，摸着石头过河，心情大起大落也是锻炼了心态…最后初赛要截止时候，我们还在复赛线边缘徘徊，眼看着自己慢慢掉出复赛线，反复讨论着各种可能，尝试构造各种复杂但看起来有意义的特征，每次连夜实现，怀着希望入睡，第二天都会被反向上分现实打脸。记得第一次掉出前100时候，我俩彻夜讨论到凌晨五点出了一套方案，从绝望到满怀希望，实际上上第二天还是究极反向上分，又坐了一次过山车：）（其实现在想想那套方案是明显的$label leak$）。 现在想想，这次比赛主要差在了套路经验上，没能构造滑窗和候选集严重限制了特征的构造，几乎所有统计特征、交叉特征、先验后延特征都无法构造，有效特征数量至少少了70%。特别是候选集，之前闻所未闻，各种地方也了解不到，后来才知道，这种方法可能从之前摩拜比赛大佬们一路传承了下来… 对样本特征的理解差也导致我们踩了好多坑。在一开始对数据分布、统计特征的构造不清楚导致我们训练时间成本巨大。现在想想当时构造的好多看起来有效的特征其实都是明显的$label leak$（先从当前数据提取特征，再用当前数据训练模型），这次比赛过后对标签泄露、过拟合是印象深刻了。]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>大数据竞赛</tag>
        <tag>天池</tag>
        <tag>CCF</tag>
        <tag>wifi定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性模型的判断]]></title>
    <url>%2F2018%2F03%2F10%2F%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[线性模型的判断线性模型定义：如果模型是参数的线性函数，并且存在线性分类面就是线性模型，否则不是。 注意：线性模型可以用曲线拟合样本，但是分类的决策边界一定是直线的，例如$LR$ 例子： 单层感知机（网络）无法解决异或问题（单层感知机是线性模型） 存在非线性激活函数的多层感知机（网络）可以解决异或问题（存在非线性激活函数多层感知机是非线性） 快速判断线性非线性线性的情况 看乘法式子中自变量$x$前的系数$w$，如果$w$只影响一个$x$，那么此模型为线性模型。（等价于对决策边界是否为超平面的判断） 非线性的情况 $(变量)^n$，且$n$不为1为非线性 $|变量|$有变量在绝对值内为非线性 $sgn (变量)$有变量在符号函数内为非线性 常见的模型常见的线性分类器：$LR$，贝叶斯分类器，单层感知机，线性回归 常见的非线性分类器：决策树，$RF$，$GBDT$，多层感知机 $SVM$两种都有（看是线性核还是高斯核） 线性分类器速度快、编程方便，但是拟合效果可能不好 非线性分类器编程复杂，但是拟合能力强 为什么朴素贝叶斯分类器是线性分类器？这一部分我感觉我的理解出现了偏差，先写上了 朴素贝叶斯分类器假设了各特征之间相互独立，采用后验概率最大的类别 贝叶斯公式： p(C_k|x_1,x_2,…,x_n)={p(C_k)\Pi^n_{i=1}p(x_i|C_k)\over \sum_ip(x|C_i)p(C_i)}训练时候只需要统计$p(C_k),p(x_i|C_k)$，可以说是$very naive$了 从线性模型角度理解这里以二分类举例 我们将样本表示为$x=(x_1,x_2,…,x_n)$，$y=\{0,1\}$，$p_{ki}$表示$C_k$中$x_i$出现的概率 $\log p(C_k)p(x|C_k)$ $=\log p(C_k)+\sum_{i=1}^n\log p_{ki}$ 对于上式，将$\log p_{ki}$看做$w_i$，而$x_i$为样本中$x_i$表示的值的出现，$x_i=1$。上式可以化为： $=w^T_kx+b$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性模型</tag>
        <tag>非线性模型</tag>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说生成模型与判别模型]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%AF%B4%E8%AF%B4%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文主要是对知乎相关问题的总结 是什么？ 监督学习的任务就是学习一个模型，应用这一个模型，对给定的输入预测相应的输出。这个模型的一般形式为决策函数：$Y=f(X)$或者条件概率分布：$P(Y|X)$ 监督学习方法又可以氛围生成方法和判别方法。所学到的模型分别称为生成模型和判别模型。 生成模型书上的话：生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布$P(Y|X)$作为预测模型，即生成模型：$P(Y|X)={P(X,Y)\over P(X)}$ 这样的方法称为生成方法，是因为模型表示了$X,Y$的生成关系。典型的生成模型有：朴素贝叶斯法、隐马尔科夫模型、混合高斯模型、AODE、Latent Dirichlet allocation（unsup）、Restricted Boltzmann Machine 生成模型，就是生成（数据de分布）的模型，关注的是抓取样本的分布特征，通过建立每个类别的特征分布，最终建立很多类别模型（一般有多少类就有多少个），最后比较结果选择最优。生成模型输入$X$与输出$Y$之间没有因果关系。 判定模型书上的话：判别方法由数据直接学习决策函数$f(x)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别方法关心的是对给定的输入$X$应该预测什么样的输出$Y$。典型的判别方法包括：kNN，感知机，决策树，逻辑回归，最大熵模型，SVM，提升方法，条件随机场，神经网络等。 判别模型，就是判别（数据输出量）的模型，直接采用输入特征去预测输出，或者说条件概率。判定模型只有一个模型，$X$往里面丢，$label$就出来了。判别模型输入$X$与输出$Y$之间有因果关系 用起来？ 生成模型优点： 1.生成模型给出的是联合分布$P(\hat x,\hat c)$，不仅能够由联合分布计算条件分布$P(\hat c|\hat x)$（反之不行），还可以给出其他信息，比如可以使用$P(\hat x)=\sum^k_{i=1}P(\hat x|\hat c_i)P(\hat c_i)$来计算边缘分布$P(\hat x)$。如果一个输入样本的边缘分布$P(\hat x)$很小的话，那么可以认为学处的这个模型可能不太适合对这个样本进行分类，分类效果可能会不好，这技术里所谓的$outlier detection$。 2.生成模型收敛速度比较快，即当样本数量较多时，生成模型能更快地收敛于真实模型。3.生成模型能够应付存在隐变量的情况，比如混合高斯模型就是含有隐变量的生成方法。 4.生成模型所需计算资源是更少的，大部分情况下只要做统计计数就可以获得模型 缺点： 1.实践中多数情况下判别模型效果更好 判别模型优点： 1.直接面对预测，准确率往往较生成模型高 2.由于直接学习$P(\hat c|\hat x)$而不需要求解类别条件概率，所以允许我们对输入进行抽象（比如降维、构造等），从而能够简化学习问题。 缺点： 1.判别模型所需资源更多，因为判别模型必须靠误差梯度下降法来获得模型，训练所需时间要多很多。 过拟合： 生成模型‘‘没有考虑正则化很简单，因为他们很少过拟合’’。生成模型学习$X,Y$的联合概率分布$P(X,Y)$，直接学习的就是数据的分布，从整个数据的整体着手，很少会出现过拟合。 基本上属于高偏差/低方差分类器，当样本数量小于特征数量或样本数量不足时，应选用这种模型 判别模型判别模型应当有正则化过程，因为是直接生成$f(x)$或者$p(y|x)$，所以很容易比较$y$跟$f(x)$的关系，按照现有数据照葫芦画瓢来判别，容易过拟合，所以正则化便有存在的意义。 基本上属于低偏差/高方差分类器，容易过拟合，需要正则项。数据量充足时选用判别模型 结论随着训练集的增大，低偏差/高方差分类器（判别模型）相对于高偏差/低方差分类器（生成模型）准确率高，因为随着数据量的增大，现有训练集数据的分布更接近于真实分布，此时生成模型优势变小，同时生成模型不能提高足够的准确率，此时，判别模型优势更大。 举个例子： 当一份分类数据的特征维度大于样本数量时。如果采用判别模型，极端情况下每条样本都有唯一的特征（或特征组合），此时如果正则化不够给力，那么该判别模型将极大限度拟合当前数据，训练集AUC可能将近1，那么就可能得到训练数据上准确率100%，测试数据准确率不如XJB猜的模型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>生成模型</tag>
        <tag>判别模型</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义线性模型]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[广义线性模型概要本文将会说明线性回归和$LR$都是广义线性模型的一种特殊形式，介绍广义线性模型的一般求解步骤。 线性回归中我们假设： y(x;\theta) 服从N(\mu,\sigma^2)分布$LR$中我们假设： y(x;\theta)服从Bernoulli(\phi)分布其实他们只是广义线性模型($GlMs$)的特例。 自己的理解广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。 注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$ 指数分布族（$The exponential family$）首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)： p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))简单介绍一下其中的参数： 1.$\eta $是自然参数 2.$T(y)$是充分统计量(一般情况下$T(y)=y$) 3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $) 也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。 选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布 广义线性模型的形式化定义GLM有三个假设： 1.$y|x;\theta$~$ExpFamily(\eta)$（某指数分布族）；给定样本$x$与参数$\theta$，样本分类$y$服从指数分布族中的某个分布； 2.给定一个$x$，我们需要的目标函数为$h_{\theta}(x)=E[T(y)|x]$ 3.$\eta=\theta^Tx$ 高斯分布的另一种看法 伯努利分布-LR回归的含义]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>LR</tag>
        <tag>理论</tag>
        <tag>广义线性模型</tag>
        <tag>机器学习</tag>
        <tag>GLM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大熵模型]]></title>
    <url>%2F2018%2F03%2F07%2F%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[最大熵模型($The Maximum Entropy$，从信息论的角度来讲，就是保留了最大的不确定性，也就是让熵达到最大。当我们需要对一个时间的概率分布进行预测是，最大熵原理告诉我们所有的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设（不做主观假设这点很重要）。也就是让概率分布最均匀，预测风险最小。 数学知识熵熵（$Entropy$）是热力学中的概念，由香农引入到信息论中。在信息论和概率统计中，熵用来表示随机变量不确定性的度量。 定义：设$X\in\{x_1,x_2,x_3…,x_n\}$为一个离散随机变量，其概率分布为$p(X=x_i)=p_i, i=1,2,…,n$，则$X$的熵为 H(X)=-\sum^n_{i=1}p_i\log p_i其中，当$p_i=0$时，定义$0\log 0=0.$ 注意：$H(x)$依赖于$X$的分布，而与$X$的具体值无关。$H(x)$越大，表示$X$的不确定性越大。 条件熵定义：设$X\in\{x_1,x_2,x_3…,x_n\}, Y\in \{y_1,y_2,…,y_m\}$为离散随机变量，在已知$X$的条件下，$Y$的条件熵$(Conditional Entropy)$可定义为 H(Y|X)=\sum^n_{i=1}H(Y|X=x_i)=-\sum^n_{i=1}p(x_i)\sum^m_{j=1}p(y_j|x_i)\log p(y_j|x_i)它表示已知$X$的条件下，$Y$的条件概率分布的熵对$X$的数学期望。 最大熵原理最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。 假设离散随机变量$X$的概率分布是$P(X)$，则其熵是 H(P)=-\sum_xP(x)\log P(x)熵满足下列不等式： 0\le H(P)\le \log |X|式中，$|X|$是$X$的取值个数，当且仅当$X$的分布式均匀分布时右边的等号成立。这就是说，当$X$服从均匀分布时候，熵最大。 最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息条件下，那些不确定的成分是‘等可能的’。最大熵原理通过熵最大化来表示等可能性。‘等可能性’不易操作，而熵则是可优化的数值指标。 最大熵模型定义前提1.最大熵原理是统计学习的一般原理，将它应用到分类就得到了最大熵模型 2.假设分类模型是一个条件概率分布$P(Y|X),$$X$表示输入，$Y$表示输出。这个模型表示的是对于给定的输入$X$，一条件概率$P(Y|X)$输出$Y$。 3.给定一个训练数据集$T$，我们的目标就是利用最大熵原理选择最好的分类模型。 T=\{(x_1,y_1),(x_2,y_2),…(x_N,y_N)\}4.按照最大熵原理，我们应该优先保证模型满足一致的所有约束。那么如何得到这些约束的？ $ $思路：从训练数据$T$中抽取若干特征（依靠特征函数），然后要求这些特征在$T$上关于经验分布的期望与他们在模型中关于$p(x,y)$的数学期望相等，这样，一个特征就对应一个约束。 特征函数特征函数的作用1.用特征函数$f(x)$描述输入$x$和输出$y$之间的某一个事实。 2.按照最大熵原理，应该优先保证模型满足一致的所有约束。通过特征函数来定义、量化以及得到这些约束。 3.特征函数的出现，可以让模型有更好的泛化能力（特征函数的选取、定义特别随意）。 特征函数可以类比决策树对于输入$x$的处理，假设输入$x$是一个有着多个属性值的实例，决策树在一个决策点并不是对所有属性都进行考虑，这就有点提取出了特征中更有信息量的属性。 如何让一个线性模型（例如$LR:h_{\theta}(x)=\sigma (\theta^Tx)$ ）也有类似的功能？答案就是特征函数，让输入$X$先经过一些列特征函数的处理，变成$g(x)$再送给模型分类（如：$h_{\theta}(x)=\sigma (\theta^Tg(x))$）. 此外，当输入的样本可能不是数值的向量，比如文本或图片时，特征函数的功能更像是特征向量的制作。对于给定输入$X$，使用一系列定义好的特征函数$\{g(x)\}$将其转换成需要的向量形式。 对于特征函数中‘特征’的理解一般说的“特征”都是指输入的特征，而最大熵模型中的“特征”指的是输入和输出共同的特征。最大熵模型中的每个特征会有一个权重，你可以把它理解成这个特征所描述的输入和输出有多么倾向于同时出现。 可以以多类logistic regression为例，来感受一下两种视角的不同。在一般的视角下，每条输入数据会被表示成一个n维向量，可以看成n个特征。而模型中每一类都有n个权重，与n个特征相乘后求和再经过softmax的结果，代表这条输入数据被分到这一类的概率。在最大熵模型的视角下，每条输入的n个“特征”与k个类别共同组成了nk个特征，模型中有nk个权重，与特征一一对应。每个类别会触发nk个特征中的n个，这n个特征中的每个特征都会触发特征函数。 经验分布经验分布是指通过训练数据$T$进行统计得到的分布。我们需要考察两个经验分布，分别是$x,y$的联合经验分布，以及$x$的经验分布。其定义如下： \hat p(x,y)={count(x,y)\over N},\ \hat p(x)={count(x)\over N}对于任意特征函数$f$,记$E_{\hat p}(f)$表示$f$在训练数据$T$上关于$\hat p(x,y)$的数学期望。$E_p(f)$表示$f$在模型上关于$p(x,y)$的数学期望，由于模型中$p(x,y)$是未知的，并且我们建模的目标是$p(y|x)$，因此我们利用$Bayes$定理得到$p(x,y)=p(x)p(y|x)$，此时，$p(x)$还是未知的，我们可以使用经验分布$\hat p(x)$对$p(x)$进行近似。按照期望的定义有： E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)E_p(f)=\sum_{x,y}p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)对于概率分布$p(y|x)$我们希望特征$f$的期望应该和从训练数据中的到的一样的。（我的理解：特征函数是约束的提取量化，特征函数关于经验分布的期望与关于模型的期望相等就代表一个约束）因此我们可以提出约束： E_{\hat p}(f)=E_p(f)\sum_{x,y}\hat p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)假设从训练数据中抽取了n个特征，相应的便有n个特征函数以及n各约束条件。 C_i:E_p(f_i)=E_{\hat p}(f_i):=\tau_i,i=1,2,…,n最大熵模型给定数据集$T$，我们的目标就是根据最大上原理选择一个最优分类器，假设满足所有约束条件的模型集合为： C=\{P\in\pi|E_p(f_i)=E_{\hat p}(f_i),i=1,2,…,n \}定义在条件概率分布$P(Y|X)$上的条件熵为： H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)则模型集合$C$中条件熵$H(P)$最大的模型成为最大熵模型。式中的对数为自然对数。 最大熵模型的学习最大熵模型的学习可以形式化为约束最优化问题。对于给定训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\}$以及特征函数$f_i(x,y), i=1,2,3,…,n$，最大熵模型的学习等价于约束最优化问题(注意自变量为$P$)： \max_{P\in C}\ \ \ H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)\ \ \ s.t.\ \ \ E_P(f_i)=E_{\hat P}(f_i),\ i=1,2,….,n\sum_y P(y|x)=1\ \ \ \ \ \ \ \ \ \ \ \按照最优化习惯，将求最大值问题改写为等价的求最小值问题： \min_{P\in C}\ \ \ -H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)\ \ \ s.t.\ \ \ E_P(f_i)-E_{\hat P}(f_i)=0,\ i=1,2,….,n1-\sum_y P(y|x)=0\ \ \ \ \ \ \ \ \ \ \ \引入拉格朗日乘子$w_0,w_1,w_2,…,w_n$,定义拉格朗日函数$L(P,w)$(这里注意两自变量)： L(P,w)=-H(p)+w_0(1-\sum_yP(y|x))+\sum^n_{i=1}w_i(E_{\hat P}(f_i)-E_P(f_i))又： -H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)E_p(f)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)带入得到$L(P,w)$: L(P,w)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)+w_0(1-\sum_yP(y|x)\ )+\sum ^n_{i=1}w_i(\sum_{x,y}\hat p(x,y)f(x,y)-\sum_{x,y}\hat p(x,y)f(x,y)\ )对偶最优化的原始问题是（再次注意$min,max$的自变量是什么）： \min_{p\in C}\max_wL(P,w)对偶问题是 \max_w\min_{p\in C}L(P,w)由于拉格朗日函数$L(P,w)$是$P$的凸函数，原始问题的解与对偶问题的解是等价的。这样，可以通过求解对偶问题来求解原始问题 注：以上的推理解释可在另一篇拉格朗日文章中找到 首先，求解对偶问题内部的极小化问题$\min_{p\in C}L(P,w)$。$\min_{p\in C}L(P,w)$是关于$w$的函数（因为$\min_{p\in C}L(P,w)$代表$P$已经确定了），将其记作： \Psi(w)=\min_{P\in C}L(P,w)=L(P_w,w),注：上式的最后一项$L(P_w,w)$是归于$w$的函数，因为此时$P_w=\arg min_{P\in C}L(P,w)=P_w(y|x)$ $\Psi(x)$成为对偶函数，其解为$P_w$。 具体地，求$L(P,w)$对$P(y|x)$的偏导数（这里直接插入图片了手写这一段$mathjax$太累，将图片中$\lambda$换成$w$就行）注意蓝色字部分 另偏导数等于0，在$\hat P(x)&gt;0$的情况下，解得： P(y|x)=exp(\ \sum^n_{i=1}w_if_i(x,y)+w_0-1\ )={exp(\sum^n_{i=1}w_if_i(x,y))\over \exp(1-w_0)}由于$\sum_y P(y|x)=1$，得(关于$w$的函数)： P_w(y|x)={1\over Z_w(x)}exp(\ \sum^n_{i=1}w_if_i(x,y)\ )其中， Z_w(x)=\sum_yexp(\ \sum^n_{i=1}w_if_i(x,y)\ )$Z_w(x)$成为规范化因子；$f_i(x,y)$是特征函数；$w_i$是特征的权值。表示的模型$P_w=P_w(y|x)$就是最大熵模型。这里$w$是最大熵模型中的参数向量。 得到对偶问题内部的极小问题的解$P_w(y|x)$后，需要进一步求解外层的极大值问题。 \max_w\Psi(w)将其解记为$w^￥$,即： w^￥=\arg\ max_w\Psi(w)令$\sum_{x,y}\hat P(x,y)f_i(x,y) = \tau_i$ $ \Psi (x)$ $=L(P_w,w) 注意这里P_w为定量是之前内部极小问题的解$ $=\sum_{x,y}\hat P(x)P_w(y|x)\log P_w(y|x)+\sum^n_{i=1}w_i( \tau_i-\sum_{x,y}\hat P(x)P_w(y|x)f_i(x,y) )$ $=\sum^n_{i=1}w_i\tau_i+\sum_{x,y}\hat P(x)P_w(y|x)( \log p_w(y|x)-\sum^n_{i=1}w_if_i(s,y) )$ 又:$\log P_w(y|x)=\sum^n_{i=1}w_if_i(x,y)-\log Z_w(x)$ 将上式带入到$\Psi$中，可以得到 $\Psi(w)$ $=\sum^n_{i=1}w_i\tau_i-\sum_{x,y}\hat P(x)P_w(y|x)\log Z_w(x)$ $=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x)\sum_y P_w(y|x)$ $=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x) (这里利用了\sum_yP_w(y|x)=1 )$ 极大似然模型下面证明对偶函数的极大化等价于最大熵模型的极大似然估计。 注：极大似然估计$MLE$的一般形式表示为（推导下一小节给出）： L_{\hat P}=\Pi_xP(x)^{\hat P(x)}一直训练数据的经验概率分布$\hat P(x,y)$，条件概率分布$P(Y|X)$的对数似然表示为： L_{\hat P}(P_w)=\log \Pi_{x,y}P(y|x)^{\hat P(x,y)}=\sum_{x,y}\hat P(x,y)\log P(y|x)当条件概率分布$P(y|x)$是最大熵模型的内部极小函数的解释，对数似然函数$L_{\hat P}(P_w)$ 为： 注：最后一步由$\sum_{x,y}\hat p(x,y)=\sum_x\hat p(x)\sum_yp(y|x)$且$\sum_yp(y|x)=1$得来 最大熵模型中对数似然的解释转载自CSDN 最近在学习最大熵模型，看到极大似然估计这部分，没有看明白条件概率分布$p(y|x)$的对数似然函数。上网查了很多资料都没有一个合理的解释。基本直接给出对数似然函数的一般形式 ($\hat p(x)$为jing’yan’gai’lv): L\hat p=\Pi_xp(x)^{\hat p(x)}其实第一眼之所以不理解，因为这是最大似然函数的另外一种形式。一般书上描述的最大似然函数的一般形式是各个样本集XX中各个样本的联合概率: L(x_1,x_2,…,x_n)=\Pi^n_{i=1}p(x_i;\theta)其实这个公式和上式是等价的。$x_1,x_2,…,x_n$是样本具体观测值。随机变量$X$是离散的，所以它的取值范围是一个集合，假设样本集的大小为$n$，$X$的取值有$k$个，分别是$v_1,v_2,…,v_k$。用$C(X=v_i)$表示在观测值中样本$v_i$出现的频率。所以$L(x_1,x_2,…,x_n;θ)$可以表示为： L(x_1,x_2,…,x_n)=\Pi^k_{i=1}p(v_i;\theta)^{C(X=v_i)}对等式两边同时开$n$次方得： L(x_1,x_2,…,x_n)^{1\over n}=\Pi^k_{i=1}p(v_i;\theta)^{C(X=v_i)\over n}因为经验概率$\hat p(x)={C(X=v_i)\over n}$，所以简写可以得到 L(x_1,x_2,…,x_n)^{1\over n}=\Pi_xp(x;\theta)^{\hat p(x)}很明显对$L(x_1,x_2,…,x_n;θ)$求最大值和对$L(x_1,x_2,…,x_n;θ)^{1\over n}$求最大值的优化的结果是一样的。整理上式所以最终的最大似然函数可以表示为： L(x;\theta)=\Pi_xp(x;\theta)^{\hat p(x)}从最大熵模型角度理解LRLR是最大熵模型在类别为2时候的特例 假设每条输入第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。 f(x,y) =\begin{cases}x_i, & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}根据最大熵模型： P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}现在回到两类的情况$\{0,1\}$，此时分母上有两项： P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}分子、分母同时除以分子，则有： P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}这就变成了$logistic$函数。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>LR</tag>
        <tag>最大熵模型</tag>
        <tag>数学</tag>
        <tag>特征函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic Regression的理解]]></title>
    <url>%2F2018%2F03%2F06%2FLogistic-Regression%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[逻辑斯地回归模型逻辑斯谛分布设$X$是连续随机变量，$X$服从逻辑斯谛分布是指$X$具有下列分布函数和密度函数： F(x)=P(X\le x)= {1 \over 1+e^{-(x-\mu )/\gamma}}f(x)=F'(x)={e^{-(x-\mu)/y} \over \gamma(1+e^{-(x-\mu)}/\gamma)^2}式中，$\mu$为位置参数，$\gamma\gt0$为形状参数。密度函数与分布函数如下图所示。 注：逻辑斯谛分布的回归会在从广义线性模型角度理解LR时给出 二项逻辑斯谛回归模型二项逻辑斯谛回归模型是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的逻辑斯谛分布。这里，随机变量取值为实数，随机变量Y，取值为1或0，即Y满足二项分布。 定义：二项逻辑斯谛回归模型是如下的条件概率分布： P(Y=1|x)={exp(wx) \over 1+exp(wx) }={1\over 1+exp(-wx)}P(Y=0|x)={1 \over 1+exp(wx)}={exp(-wx) \over 1+exp(-wx)}一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是$p$,那么该事件的几率是${p\over 1-p}$，该事件的对数几率或者logit函数是： logit(p)=\log {p \over 1-p}这里$logit(p)$就是广义线性模型中的$\eta$。 对于逻辑斯谛回归而言 \log {P(Y=1|x) \over 1-P(Y=1|x)}=wx\ \ \ 其实就是广义线性模型第三条假设从广义线性模型角度，二项分布指数族解出的$\eta = \log{p\over 1-p}=logit(p)$,又由第三条假设，$\eta=wx$即可得到$\log {p\over 1-p}=wx$,求解出$p$来就是$P(Y=1|X)$的概率，又因为二项分布期望为$P$,所以收敛的结果就是$P$. 模型参数估计逻辑斯谛回归模型学习中，对于给定的训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_n)\}$ ，其中，$x_I\in R^n,y_i\in\{0,1\}$,可以应用极大似然估计法估计模型参数，从而得到逻辑斯谛回归模型。设： P(Y=1|x)=\pi(x),\ \ \ P(Y=0|x)=1-\pi(x)似然函数为 \Pi^N_{i=1}[\pi(x_i)^{y_i}][1-\pi(x)]^{1-y_i}对数似然函数为 L(w)=\sum^N_{i=1}[y_i\log \pi(x_i)+(1-y_i)\log (1-\pi(x_i))]\ \ \ =\sum^N_{i=1}[y_i\log{\pi(x) \over 1-\pi(x_i)}+\log(1-\pi(x_i))]\ \ =\sum^N_{i=1}[y_i(wx)-\log(1+exp(wx))]\ \ \ \ \ \ \从最大熵模型角度理解LRLR是最大熵模型在类别为2时候的特例 假设每条输入第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。 f(x,y) =\begin{cases}x_i, & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}根据最大熵模型： P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}​现在回到两类的情况$\{0,1\}$，此时分母上有两项： P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}分子、分母同时除以分子，则有： P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}这就变成了$logistic$函数。 从广义线性模型角度理解LR线性回归中我们假设： y(x;\theta) 服从N(\mu,\sigma^2)分布$LR$中我们假设： y(x;\theta)服从Bernoulli(\phi)分布其实他们只是广义线性模型($GlMs$)的特例。 自己的理解广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。 注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$ 指数分布族（$The exponential family$）首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)： p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))简单介绍一下其中的参数： 1.$\eta $是自然参数 2.$T(y)$是充分统计量(一般情况下$T(y)=y$) 3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $) 也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。 选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布 广义线性模型的形式化定义GLM有三个假设： 1.$y|x;\theta$~$ExpFamily(\eta)$（某指数分布族）；给定样本$x$与参数$\theta$，样本分类$y$服从指数分布族中的某个分布； 2.给定一个$x$，我们需要的目标函数为$h_{\theta}(x)=E[T(y)|x]$ 3.$\eta=\theta^Tx$ 推导过程]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>LR</tag>
        <tag>最大熵模型</tag>
        <tag>广义线性回归</tag>
        <tag>逻辑斯谛回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优化问题及KKT条件的几何理解]]></title>
    <url>%2F2018%2F03%2F04%2F%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%8F%8AKKT%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%87%A0%E4%BD%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[以二维空间$R^2$举例，从简单的无约束优化（0梯度条件），到等式约束优化（拉格朗日条件），再到不等式约束优化（KKT条件）解析优化问题解法的几何意义。 无约束优化问题$\min f(x)$，其中，$x=(x_1,x_2)$ 此时，对于$f(x)$的局部极小值点（红点）处梯度必然为0.因此优化问题可以转化为求解梯度为0的点。 带等式约束的优化问题$\min f(x)$，其中，$x=(x_1,x_2)$ $s.t. h(x)=0$ 与无约束问题不同，此时极小值点被限制在曲线$h(x)=0$上，我们因此将$\{x|h(x)=0\}$成为可行域，解只能在这个可行域里面取。如下图所示，曲线$h(x)=0$（黑色实线）便是可行域，现在要求在可行域上面的极小点。可以想象从无约束问题的极小点（黑点）靠等高线向外扩展，当扩展等高线第一次接触可行域时候（相切，梯度方向相反）的交点便是可行域的极小点。所以，相切，梯度方向相反，是取得极小值点的必要条件。 补充：能够碰到极大极小值点的必要条件是：梯度场与切空间垂直，也就是梯度场不能够有任何流形切空间上的分量，否则在切空间方向有分量，在流形上沿分量方向走，函数值会增加，沿反方向走，函数值会减少，不可能为局部极小或者极大值点。 两条曲线相切，梯度方向相反，即梯度差一个任意的常数乘子（取为$-\lambda$）：$\nabla f(x)=-\lambda \nabla h(x)$，调整后即可得到拉格朗日条件$\nabla (f(x)+\lambda h(x))=0$. 如此，带等式约束的优化问题转化为了无约束的优化问题，只需要对拉格朗日条件解方程组即可。这里$\lambda$便是拉格朗日乘子，有多少个等式约束就有多少个拉格朗日乘子。 带不等式约束的优化问题只有一个不等式起作用时$\min f(x)$ $s.t. h(x)\le0$ 当只有一个不等式起作用时，如下图所示，可行域变成了阴影部分，最小值点还是切点，跟等式约束条件完全一样，只需要把不等号当做等号去求解即可。 两个及以上不等式起作用时$\min f(x)$ $s.t.$ $g_1(x)\le0$ $g_2(x)\le0$ 如下图，当$f(x)$等高线慢慢扩大时，等高线与可行域（阴影部分）第一次相遇的点是个顶点，2个不等式同时起作用。满足最小值点从原来黑点的位置（切点）移动到了红点的位置，现在跟哪条约束函数都不相切了。这时候就需要用到KKt条件了。这里的条件是指：某一个点它如果是最小值点的话，就必须满足这个条件（在含不等式约束的优化问题里）。这是个必要条件，前面说的也全部是必要条件。 这个问题的解$x^*$应满足的KKT（卡罗需-库恩-塔克）条件为： $1. \mu_1\ge0, \mu_2\ge0;$ $2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)=0;$ $3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)=0$ 其中，$\mu$叫做KKT乘子，有多少个不等式约束就有多少个KKT乘子。加上本问题中的约束不封，就是完整版的KKT条件。对于有等式的情况：把其中一个不等式约束换成等式，可行域变成了半条曲线，最小值还是小红点，情况是一样的。 接下来看看KKT条件的几何意义。上图中绿色箭头为两条曲线的负梯度方向，红色箭头为等高线的梯度方向。如果这个顶点为满足约束的最小值点，那么该点处等高线梯度（红色箭头）一定在两个绿色箭头之间（$-\nabla g(x)$方向（绿色箭头）一定指向$g(x)$减小方向，即$g(x)\lt0$一边） $\mu_1\ge0,\mu_2\ge0$(红色箭头一定在绿色箭头之间)的解释：若三个向量的位置如下图所示，即$-\nabla f(x)$落在$\nabla g_1,\nabla g_2$所形成的锥形区域外侧。此时，作等高线（等值线）在点$x^k$处的切平面，可以发现：沿着与扶梯度$-\nabla f(x)$成锐角方向移动，只要能在红色阴影（阴影左界为当前等高线）取值，$f(x)$总能减小，而红色阴影区域为可行域，因此既可以建系哦啊目标函数值，又不破坏约束条件，所以当前$x^k$不是最优点。 有些不等式约束不起作用时如下面这个优化问题： $\min f(x)$ $s.t.$ $g_1(x)\le0$ $g_2(x)\le0$ $g_3(x)\le0$ 如下图$g_3(x)\le0$是不起作用的 对于最小值点$x^*$，三个不等式约束的不同在于： $g_1(x^￥)=0$（起作用） $g_2(x^￥)=0$（起作用） $g_3(x^￥)\lt0$（不起作用，最小值点不在$g_3(x)=0$上） 此时KKT条件1，2变为： $1. \mu_1\ge0, \mu_2\ge0, \mu_3\ge0, $ $2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)+\mu_3\nabla g_3(x^￥)=0$ 条件2中的$\mu_3\nabla g_3(x^￥)$让我们很苦恼，$g_3(x￥)$约束根本不起作用，要是能令$\mu_3=0$就好了。加上条件3： $3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)+\mu_3g_3(x^￥)=0$ 恰好能使$\mu_3=0​$。由于$g_1(x^￥)=0, g_2(x^￥)=0​$，所以前两项等于0，第三项$g_3(x^￥)\lt0​$,在条件3的作用下使得$\mu_3=0​$。正好满足哟啊求。如果再多几项不起作用的不等式约束，条件2都能在条件3的作用下实现：目标函数$f(x)​$的梯度$\nabla f(x)​$被起作用的不等式约束函数$g(x)​$的负梯度$-\nabla g(x)​$线性标出且系数$\mu​$全部非负（红色箭头被绿色箭头夹在中间）。这样，优化问题的求解就变成了对所有KKT条件解方程组。 如果再定义一个拉格朗日函数： $L(x,\mu)=f(x)+\mu_1g_1(x)+\mu_2g_2(x)+…$ 令它对$x$的偏导为0，就是KKT条件中的条件2了。 注意：以上所有都是局部极小值的点必要条件。据此求得的解不一定是局部极小值点（更别提全局），原因是上图中所画的等高线也许根本就不闭合，也急速实说我们一直想靠近的等高线和中间的黑点可能压根就是个鞍点或者近似鞍点。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
        <tag>KKT</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日对偶性]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7%2F</url>
    <content type="text"><![CDATA[原始问题​ 假设$f(x), c_i(x), h_j(x)$是定义在$R^n$上面的连续可微函数，考虑约束最优化问题 \min_{x\in R^n}f(x)s.t.\ c_i(x)\le0,\ i=1,2,…,kh_j(x)=0,\ j=1,2,…,l ​​ 称此约束最优化问题为原始最优化问题或原始问题。 ​ 首先，引进广义拉格朗日函数 L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)​ 这里，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i\ge0$. ​ 考虑函数(注意：此时$L(x,\alpha,\beta)$的变量是$\alpha_i\beta_j$)： \Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)​ 这里下标$P(Primal)$表示原始问题.对于此函数（关于$\alpha,\beta$的函数，$x$是常量），经过我们优化（不管什么方法），确定$\alpha,\beta$的值，就可以得到$L(x,\alpha,\beta)$的最大值，因为此时$\alpha,\beta$已经确定，显然最大值\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)就是只和$x$有关的函数 ​ 下面通过$x$是否绵竹约束条件两方面来分析这个函数： ​ 1.考虑某个$x$违反了原始的约束，即$c_i\gt0$或者$h_j\neq0$，那么： \Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=\infty​ 2.考虑$x$满足原始的约束，则： \Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)]=f(x)​ 注意最大化确定$\alpha,\beta$的过程，$f(x)$就是个常量，常量的最大值显然是本身 ​ 通过上面两条分析可以得出： \Theta_P(x)=\begin{cases}f(x),\ {x满足原始问题约束}\\+\infty,\ {其他}\\\end{cases}​ 那么在满足约束的条件下： \min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)​ 即$\min_x\Theta_P(x)$与原始优化问题等价，所以常用$\min_x\Theta_P(x)$来代表原始问题，定义原始问题的最优值： p^*=\min_x\Theta_P(x)​ 原始问题讨论到这里，总结：重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题。 对偶问题​ 定义关于$\alpha,\beta$的函数： \Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)​ 注意上面等式右边是关于$x$的函数最小化,$x$确定之后，最小值就只与$\alpha,\beta$有关，所以此时是一个关于$\alpha,\beta$的函数 ​ 再考虑极大化$\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$，即： \max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)​ 这就是原始问题的对偶问题，再将原始问题写出来： \min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)​ 从形式上可以看出堆成，只不过原始问题先固定$L(x,\alpha,\beta)$中的$x$,优化参数$\alpha,\beta$，再优化$x$；而对偶问题是先固定$\alpha,\beta$，再优化$x$，然后再确定参数$\alpha,\beta$ ​ 定义对偶问题的最优值： d^*=\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)原始问题与对偶问题之间的关系​ 若原始问题和对偶问题都有最优值，则有$Min-Max$不等式： d^*=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)\le\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=p^*​ 当$L(x,\alpha,\beta)$对$x$为凸函数，对$\alpha,\beta$为凹函数，以上等号成立。而$L(x,\alpha,\beta)$对$\alpha,\beta$为天然凹函数，因此只要$L(x,\alpha,\beta)$对$x$为凸函数，等号便成立 ​ 证明：一个式子的最大值永远大于等于这个式子的最小值，哪怕是这个式子最小的最大值与最大的最小值相比（瘦死的骆驼比马大）。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
        <tag>拉格朗日对偶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer二维数组中的查找Q:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：思路从右上开始，右上为一行最大，一列最小。target&lt;右上，删一列; target&gt;右上,删一行 Code 1234567891011121314class Solution1: # array 二维列表 def Find(self, target, array): # write code here i = 0 j = len(array[0])-1 while i&lt;len(array) and j&gt;=0: if array[i][j] == target: return True elif array[i][j] &gt; target: j -= 1 else: i += 1 return False 替换空格Q:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：python式。。 其他语言思路：从头到尾遍历数空格数量，然后从后往前遍历，碰到空格后根据之前数好的数量移位 Code 123456class Solution2: # s 源字符串 def replaceSpace(self, s): # write code here s= s.replace(' ', '%20') return s 从尾到头打印链表Q:输入一个链表，从尾到头打印链表每个节点的值 思路：遍历链表每次遍历的val从头插入list Code 12345678910class Solution3: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here list = [] p = listNode while p: list = [p.val] + list p = p.next return list 重建二叉树Q:输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：先序第一个为根节点，中序中根节点左边全在左子树，右边全在右子树。据此用递归建树 Code 123456789101112131415161718192021222324252627# 我的解法# 对len==1的list判定，繁琐class Solution32: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here root = TreeNode(pre[0]) if len(pre) == 1 and len(tin) == 1: return root root_index = tin.index(pre[0]) if root_index != 0: root.left = self.reConstructBinaryTree(pre[1:root_index+1],tin[:root_index]) if root_index != len(tin)-1: root.right = self.reConstructBinaryTree(pre[root_index+1:],tin[root_index+1:]) return root# 精简解法# 对空list的判定，鲁棒性更强，更精简def reConstructBinaryTree(self, pre, tin): # write code here if not pre or not tin: return None root = TreeNode(pre[0]) index = tin.index(root.val) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[0:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 旋转数组的最小数字Q:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路：太简单，不说了 Code 12345678910111213class Solution5: def minNumberInRotateArray(self, rotateArray): # write code here nums = rotateArray if not nums: return 0 p = len(nums) - 1 min = nums[0] while p &gt; 0 and nums[p-1]&lt;= nums[p]: p -= 1 if nums[p] &lt; min: min = nums[p] return min 斐波那契数列Q:大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 思路：分别用while 与 递归实现 Code 1234567891011121314151617181920212223242526# 不用递归，避免重复运算，运行时间短class Solution6: def Fibonacci(self, n): # write code here if n == 0: return 0 if n &lt; 3: return 1 pre = 1 post = 1 count = 3 while count &lt;= n: temp = post post = pre + post pre = temp count += 1 return post# 递归，代码简单，运行超时class Solution62: def Fibonacci(self, n): # write code here if n == 0: return 0 if n == 1: return 1 return self.Fibonacci(n-1) + self.Fibonacci(n-2) 跳台阶Q:一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：斐波那契数列问题，斐波那契数列前移一位 Code 1234567891011121314class Solution7: def jumpFloor(self, number): # write code here if number &lt; 2: return 1 pre = 1 post = 1 count = 2 while count &lt;= number: temp = post post = pre + post pre = temp count += 1 return post 变态跳台阶Q:一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 思路： F(n) = F(n-1)+F(n-2)+F(n-3)+….+F(1) 第n项是前n-1项的和，所以第n+1项是第n项的两倍，都是二的指数次方 Code 1234class Solution8: def jumpFloorII(self, number): # write code here return 2 ** (number-1) 矩形覆盖Q:我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路：还是个斐波那契问题 n*2 矩形覆盖时候最后一步要不覆盖田，要不覆盖日，因此是斐波那契问题F(n) = F(n-1)+F(n-2)只不过题目规定F(0)=0 Code 12345678910111213141516class Solution9: def rectCover(self, number): # write code here if not number: return 0 if number &lt; 2: return 1 pre = 1 post = 1 count = 2 while count &lt;= number: temp = post post = pre + post pre = temp count += 1 return post 二进制中1的个数Q:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路1：一个整数减去1，再和原整数做 与 运算，会把该整数最右边的1变成0（用补码表示的负数也是）。所以一个整数中有多少个1就可以进行多少次这种运算该法用python写超时 Code 12345678class Solution10: def NumberOf1(self, n): # write code here i = 0 while n: n = n &amp; (n-1) i += 1 return i 思路2：因为右移数字n会造成死循环（负数第一位是1），可以先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算……反复左移就能判断n的其中一位是不是1 注意：1要是无符号整数(unsigned int) Code 123456789101112int NumberOf1(int n)&#123; int count = 0; unsigned int flag = 1; while(flag) &#123; if(n&amp;flag) count ++ flag = flag &lt;&lt; 1 &#125; return count;&#125; 数值的整数次方Q:给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路：Life is short, you need python Code 1234class Solution11: def Power(self, base, exponent): # write code here return pow(base, exponent) 调整数组是奇数位于偶数前并保证奇数偶数各自相对位置Q:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路：一个list存奇数一个list存偶数，两个合起来 Code 1234567891011class Solution12: def reOrderArray(self, array): # write code here res1 = [] res2 = [] for i in range(len(array)): if array[i] % 2 == 0 : res2.append(array[i]) else: res1.append(array[i]) return res1+res2 链表中倒数第K个节点Q:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：构造长度为K的滑窗（构造时考虑K过大问题），将滑窗滑至最后即可 Code 12345678910111213141516171819class Solution13: def FindKthToTail(self, head, k): # write code here if k &lt; 1: return None if not head: return None post = pre = head count = k while k-1 &gt; 0: if post.next: post = post.next k -= 1 else: return None while post.next: post = post.next pre = pre.next return pre 翻转链表Q:输入一个链表，反转链表后，输出链表的所有元素。 思路：比较简单临近双指针遍历至最后，注意最后对边界值的处理 Code 123456789101112131415161718class Solution14: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead post = pHead.next pHead.next = None while post: if post.next: temp = post.next else: post.next = pHead break post.next = pHead pHead = post post = temp return post 合并两个排序链表Q:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路：每次选出两个链表较小的头结点，然后用剩下的递归链接 Code 123456789101112class Solution15: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if not pHead1 or not pHead2: return pHead1 or pHead2 if pHead1.val &lt; pHead2.val: pHead1.next = self.Merge(pHead1.next, pHead2) return pHead1 else: pHead2.next = self.Merge(pHead1, pHead2.next) return pHead2 树的子结构Q:输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路1：递归的查找子结构 注意： ①要全面遍历所有所可能（类似机器人路径中的找出所有起始位置），不能找到一对根节点相等的点，后面不等就return False； 这里体现在相等时候也留一手 or 类似与不等继续进行判断 ②因为题中给出空节点不是子结构，而我迭代又要用到对pRoot2是否为空的判断，因此，先对pRoot2判断，再单独写了个函数 ③本题求的是子结构而非子树 Code 1234567891011121314151617class Solution16: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot2: return False def Search(pRoot1,pRoot2): if not pRoot2: return True if not pRoot1: return False if pRoot1.val ==pRoot2.val: # 注意or的运用，遍历所有可能的节点 return True and ( (Search(pRoot1.left,pRoot2.left) and Search(pRoot1.right,pRoot2.right)) or Search(pRoot1.left,pRoot2) or Search(pRoot1.right,pRoot2) ) else: return Search(pRoot1.left,pRoot2) or Search(pRoot1.right,pRoot2) return Search(pRoot1,pRoot2) 思路2：更精简的分治递归 写一个函数判断两树是同一根节点的情况下pRoot2是否是pRoot1的子结构 在主函数里递归调用这个函数 Code 123456789101112class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.IsSub(pRoot1,pRoot2) or self.IsSub(pRoot1.left,pRoot2) or self.IsSub(pRoot1.right,pRoot2) def IsSub(self,p1,p2): if not p2: return True if not p1 or p1.val != p2.val: return False return self.IsSub(p1.left,p2.left) and self.IsSub(p1.right,p2.right) 二叉树的镜像Q:操作给定的二叉树，将其变换为源二叉树的镜像。 思路：递归实现没什么难度 Code 1234567891011121314class Solution17: # 返回镜像树的根节点 def Mirror(self, root): # write code here def Trans(root): if not root: return temp = root.left root.left = root.right root.right = temp Trans(root.left) Trans(root.right) Trans(root) return root 顺时针打印矩阵Q:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路：通过递归函数实现，每次添加最外一圈 注意：对行列为2的判断（里面的if判断），过程中一个不满足就代表添加完毕 Code 1234567891011121314151617181920212223242526272829303132class Solution18: # matrix类型为二维列表，需要返回列表 def __init__(self): self.List = [] def printMatrix(self, matrix): # write code here row_u = 0 row_d = len(matrix) - 1 col_l = 0 col_r = len(matrix[0]) - 1 def Printnum(matrix,row_u,row_d,col_l,col_r): if row_u &gt; row_d or col_l &gt; col_r: return if row_u &lt;= row_d and col_l &lt;= col_r: for j in range(col_l,col_r+1): self.List.append(matrix[row_u][j]) row_u += 1 if row_u &lt;= row_d and col_l &lt;= col_r: for i in range(row_u,row_d+1): self.List.append(matrix[i][col_r]) col_r -= 1 if row_u &lt;= row_d and col_l &lt;= col_r: for j in range(col_r,col_l-1,-1): self.List.append(matrix[row_d][j]) row_d -= 1 if row_u &lt;= row_d and col_l &lt;= col_r: for i in range(row_d,row_u-1,-1): self.List.append(matrix[i][col_l]) col_l += 1 Printnum(matrix,row_u,row_d,col_l,col_r) Printnum(matrix,row_u,row_d,col_l,col_r) return self.List 包含Min函数的栈Q:定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：python式。。 Code 123456789101112131415class Solution19: def __init__(self): self.stack = [] def push(self, node): # write code here self.stack.append(node) def pop(self): # write code here self.stack = self.stack[:-1] def top(self): # write code here return self.stack[-1] def min(self): # write code here return min(self.stack) 栈的压入、弹出序列Q:输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：弹出一个便从压入list中记录index为p，并删除 这个元素。下一个弹出的元素的index只能是p的前一个位置(pre)或者后面位置，弹出后便继续更新p 注意：压入list中删除元素后要更新index。list.remove(val)删除后会更新index，正好符合这道题。 Code 1234567891011121314151617class Solution20: def IsPopOrder(self, pushV, popV): # write code here pre = p = -1 for i in range(len(popV)): # 判断pushV popV是否一致 if popV[i] not in pushV: return False if pushV.index(popV[i]) &lt; pre: return False p = pushV.index(popV[i]) pushV.remove(popV[i]) if p == 0: pre = -1 else: pre = p - 1 return True 从上往下打印二叉树Q:从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：简单的层序遍历 注意：node=[] res=[] 跟 node=res=[]的区别，前面两个是两个[]，后面两个是同一个[] Code 1234567891011121314151617class Solution21: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root : return [] node = [] res = [] node.append(root) while node: res.append(node[0].val) if node[0].left: node.append(node[0].left) if node[0].right: node.append(node[0].right) node = node[1:] return res 二叉树的后序遍历序列Q:输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路：二叉搜索树的中序遍历序列便相当于升序序列，因此将原序列排序便得到中序序列。然后判断能否成树判断能否成树的方法：后序最末位为根节点，通过此节点在中序中的位置（mid_index）分割左右子树节点。 递归判断不能成树的条件是：递归中一旦出现两序列节点组成不一致的情况（最重要的思想！！！想死我了） 注意：其实此题不需要用到二叉搜索树left&lt;root&lt;right，或者说这个条件的全部信息都转化为升序序列为中序序列刚看此题想到中序序列以为此题得到解决，但是拘泥于二叉搜索树的性质写不出递归，其实可完全转化为一个中序一个后序能否成树问题。能否成树又可通过递归过程序列组成是否全程一致来判断。 Code 12345678910111213141516class Solution22: def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False mid = sorted(sequence) post = sequence def Define(mid, post): if not mid and not post: return True # 不能成树的判定 if set(mid)!= set(post): return False mid_index = mid.index(post[-1]) return True and Define(mid[:mid_index],post[:mid_index]) and Define(mid[mid_index+1:],post[mid_index:-1]) return Define(mid,post) 二叉树中和为某一值的路径Q:输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路：定义全局list：self.res，用rest记录剩下路径所需拟合值，PathList记录当前路径。递归遍历节点如果root.val拟合完毕，将PathList并入全局res，并且rest重置为expectNumber，重置PathList=[]，从孩子节点从头递归；如果root.val不拟合rest，则将这个节点加入当前PathList，左右孩子传承此PathList继续递归寻找接下来的Path，左右孩子也要不继承PathList把rest重置为expectNumber从头递归 注意： ①root.val拟合或者不拟合都要在左右孩子加一个递归重置rest为expectNumber，重置PathList=[]继续寻找 ②左右节点继承当前PathList递归时，PathList要分开指代，要不右节点会继承左节点的PathList ③PathList2=PathList这种方法指代，这俩指针还是指向同一list Code 123456789101112131415161718192021222324252627282930313233class Solution23: # 返回二维列表，内部每个列表表示找到的路径 def __init__(self): self.res = [] def FindPath(self, root, expectNumber): # write code here def Path(root, expectNumber, rest, PathList=[] ): if not root: return if root.val == rest: PathList=PathList+[root.val] # 不加以下这个if结构是任意子路径，加了代表路径结尾必须是叶子节点。 if not root.left and not root.right: self.res.append(PathList) Path(root.left,expectNumber,expectNumber,[]) Path(root.right,expectNumber,expectNumber,[]) return else: PathList.append(root.val) rest -= root.val # 将此节点填入路径继续递归 # 接下来两个递归会操作同一个PathList，这两个不应该操作统一list # 直接令PathList2=PathList这俩还是指向同一个 PathList2 = [] PathList2 += PathList Path(root.left,expectNumber,rest,PathList) Path(root.right,expectNumber,rest,PathList2) # 从此节点的子节点开始从头寻找路径 Path(root.left,expectNumber,expectNumber,[]) Path(root.right,expectNumber,expectNumber,[]) return Path(root,expectNumber,expectNumber,[]) return self.res 复杂链表的复制Q:输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路1：难点在给随机指针赋值时候怎样指向已存在的节点，这里的思路是通过next复制节点时，构造原节点与新节点一一对应的字典此方法因为用到哈希，空间复杂度较大 Code 123456789101112131415161718192021222324252627class Solution24: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return None Node_dic = &#123;&#125; pre = pHead clone_head = RandomListNode(pre.label) p = clone_head Node_dic[pre] = p while pre: pre = pre.next if pre : temp = RandomListNode(pre.label) p.next = temp p=p.next # 边复制节点边构造哈希表 Node_dic[pre] = p pre = pHead p = clone_head while pre: if pre.random: p.random = Node_dic[pre.random] pre = pre.next p = p.next return clone_head 思路2：省去了空间复杂度，复制链表时一一间隔，将新节点插入原链表 注意：不能用一个while（调整random指针的while）直接将合并的链表拆开 因为如果有random指向前面会出错，因为已经不是一一间隔了 Code 1234567891011121314151617181920212223242526272829303132333435class Solution24_2: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead p = pHead # 将新节点一一间隔插入原链表 while p: temp = RandomListNode(p.label) temp.next = p.next p.next = temp p = p.next.next pre = pHead post = pre.next new_head = pre.next while pre: if pre.random: post.random = pre.random.next pre = post.next if not pre: continue if pre.next: post = pre.next pre = pHead post = pre.next # 不能直接在上一个while直接将两链表分开，如果有random指向前面会出错，因为已经不是一一间隔了 while pre: pre.next = post.next # 考虑到尾节点情况 if post.next: post.next = post.next.next pre = pre.next post = post.next return new_head 二叉搜索树与双向链表Q:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路：二叉搜索树中序序列便是升序序列，用中序遍历构造链表 注意：需要两个全局变量记录起点指针self.head，还有上一节点的指针self.p Code 12345678910111213141516171819202122232425class Solution25: def __init__(self): self.p = None self.head = None def Convert(self, pRootOfTree): # write code here root = pRootOfTree def Trans(root): if not root: return #temp保留右指针 temp_left = root.left temp_right = root.right self.Convert(temp_left) if not self.p: self.p = root self.head = root else: self.p.right = root root.left = self.p self.p = root self.Convert(temp_right) return Trans(root) return self.head 字符串的排列Q:输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路1：先用递归将所有可能的情况列出来，用sorted（）解决字典排序问题列出所有情况的方法：分成两个列表s1,s2 ，每次s2中的一个元素加入s1当做下一个s1，其余元素当做下一个s2，进行递归自己的解法：非常不优雅，先将str转为list，在转为str添加进去，还用到了py自带的排序解决字典序问题 如果不用自带排序，则可以参考LeetCode31 注意：因为python中的字符串不可以更改，所以，先将str转为list，在转为str添加进去 Code 1234567891011121314151617181920212223class Solution26_1: def __init__(self): self.res = [] def Permutation(self, ss): # write code here if not ss: return [] def allkinds(s1,s2): if len(s2) == 1: s = ''.join(s1+s2) self.res.append(s) return for i in range(len(s2)): # 将选中元素替换到s2第一位 temp = s2[i] s2[i]=s2[0] s2[0]=temp allkinds(s1+[s2[0]],s2[1:]) return s = sorted(ss) allkinds([],s) self.res = list(set(self.res)) return sorted(self.res) 思路2：itertools.permutations用来返回所有排列（元组形式）的list’’.join() 将list、元组内的字符结合成字符串map函数将f应用于右边可迭代的每一个对象 Code 12345678import itertoolsclass Solution26_2: def Permutation(self, ss): # write code here if not ss : return [] else: return sorted(list(set(map(''.join,itertools.permutations(ss))))) 最小的k个数Q:输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路1：python式 Code 123456class Solution28_1: def GetLeastNumbers_Solution(self, tinput, k): # write code here if k&gt;len(tinput): return [] return sorted(tinput)[:k] 思路2：partition函数法（快排）：如果下标刚好是k(k-1)则左边(k-1则包含本身)便是所求，如果下标&gt;k则递归左边，下标&lt;k递归右边 Code 1234567891011121314151617181920212223242526272829class Solution28_2: def GetLeastNumbers_Solution(self, tinput, k): # write code here if k &gt; len(tinput): return [] def Partition(nums, k): i = 0 j = len(nums) - 1 temp = nums[0] while i &lt; j: while nums[j] &gt; temp: j -= 1 nums[i] = nums[j] i += 1 while nums[i] &lt;= temp: i += 1 nums[j] = nums[i] j -= 1 nums[i] = temp if i == k - 1 or i == k - 2: return elif i &gt; k - 1: return Partition(nums[:i], k) else: return Partition(nums[i + 1:], k - i - 1) Partition(tinput, k) return sorted(tinput[:k]) 连续子数组的最大和Q:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。 思路： 两个变量分别记录当前累加值(self.temp)与最大累加值(self.Max)。从头到尾累加数字如果self.temp&lt;0则在每次累加之前将其置0。最关键一点就是用self.temp记录最大值 动态规划思想：用f(i)表示以第i个数字结尾的子数组的最大和则max（f(i)）可由一下迭代公式求f(i)=Datai&lt;=0) f(i)=f(i-1)+Datai&gt;0) Code 12345678910111213class Solution29: def __init__(self): self.temp = -99 self.Max = -99 def FindGreatestSumOfSubArray(self, array): # write code here for i in range(len(array)): if self.temp &lt; 0: self.temp = 0 self.temp += array[i] if self.temp &gt; self.Max: self.Max = self.temp return self.Max 整数中1出现的次数Q:求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 思路： 10个数里面有1个个位1；每100个数里面有10个十位1（10、11、12……19）；每1000个数里面有100个百位1 …… 另外需要判断是否应该考虑剩余部分，剩余部分需要判断如115 里面有 10 + (115-110+1) 个十位1 Code 1234567891011121314151617181920212223242526class Solution30: def NumberOf1Between1AndN_Solution(self, n): # write code here if n &lt; 1: return 0 if n&lt;10: return 1 result = 0 # count代表n的位数 count = len(str(n)) # 这里相当于两位到 count-1位 第count 位要单独讨论 for i in range(1,count+1): # count为完整的倍数 times = n//(10**i) # num 为每一份对应的1的个数 num = 10 ** (i-1) # rest 为除掉完整的份数剩下的 rest = n - times*(10**i) result += times * num if rest &gt;= 2 * (10**(i-1)): result += 10**(i-1) elif rest &lt; (10**(i-1)): result += 0 else: result += rest - (10**(i-1)) + 1 return result 将数组排成最小的数Q:输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路：全部转化为字符串，用itertools.permutations列出全组合，直接用min 找全组合中最小的 注意：对itertools.permutations、map()、’ ‘.join的应用 Code 123456789class Solution31: def PrintMinNumber(self, numbers): # write code here if not numbers: return '' for i in range(len(numbers)): numbers[i] = str(numbers[i]) List = map(''.join,list(itertools.permutations(numbers,len(numbers)))) return int(min(List)) 序列化二叉树Q:请实现两个函数，分别用来序列化和反序列化二叉树 思路1：非递归，用栈 序列化：先序遍历得到字符串 反序列化：用栈记录字符串的节点，非#时入栈，flag指向添加方式1为左0为右，flag= =0时出栈，新元素入栈时flag = =1 遇到#号时flag= =0 注意：链接节点时候一定要注意指针。要用原节点去链接，而不是构造与原节点相同的节点链接（见注释） Code 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution_7_mine: def Serialize(self, root): # write code here if not root: return "#" else: return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') if not s: return None if len(s) == 1: return TreeNode(s[0]) root = TreeNode(s[0]) stack = [root] i = 1 flag = 1 # flag==1指示left添加且不用退栈，flag==0指示右边添加且要退栈 while i&lt;len(s): if s[i] != '#': if flag == 1: stack[-1].left = TreeNode(s[i]) # stack.append(TreeNode(s[i])) 是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接 stack.append(stack[-1].left) i += 1 else: stack[-1].right = TreeNode(s[i]) pop_node = stack[-1] stack = stack[:-1] # stack.append(TreeNode(s[i])) 是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接 stack.append(pop_node.right) i += 1 flag = 1 else: if flag == 1: #stack[-1].left = None flag = 0 i += 1 else: #stack[-1].right = None stack = stack[:-1] i += 1 return root 思路2：精简的递归思路 ①通过 def init(self):构造flag全局变量指示遍历位置 ②通过self.flag指示list位置建树，建树过程类似遍历过程，只不过遇到#return ③注意l元素本身为字符，给节点赋值时注意int化 123456789101112131415161718192021class Solution: def __init__(self): self.flag = -1 def Serialize(self, root): # write code her if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here self.flag += 1 l = s.split(',') if self.flag &gt;= len(l): return None if l[self.flag] == '#': return None else: root = TreeNode(int(l[self.flag])) root.left = self.Deserialize(s) root.right = self.Deserialize(s) return root 二叉树的第K个节点Q:给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / 3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 思路：二叉搜索树中序遍历就是升序 Code 123456789101112131415class Solution_5: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if k == 0 or not pRoot: return res = [] def dfs(root,res=[]): if not root: return dfs(root.left,res) res.append(root) dfs(root.right,res) dfs(pRoot,res) return res[k-1] if k&lt;=len(res) else None 矩阵中的路径Q:请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路：先用嵌套for循环找出所有起始位置，对每个位置依次用递归函数搜寻 注意：每次开始要用新的空list记录路径 Code 12345678910111213141516171819202122232425262728class Solution_2: def hasPath(self, matrix, rows, cols, path): # write code here ok = [] for i in range(rows): ok.append([]) for _ in range(len(matrix)): ok[_//cols].append(matrix[_]) init = [] for i in range(rows): for j in range(cols): if ok[i][j] == path[0]: init.append([i,j]) def search(i,j,rows,cols,ok,path,List=[]): if not path: return True if i&lt;0 or j&lt;0 or i&gt;=rows or j&gt;=cols or [i,j] in List : return False if ok[i][j] == path[0]: List.append([i,j]) return True and (search(i+1,j,rows,cols,ok,path[1:],List) or search(i,j+1,rows,cols,ok,path[1:],List) or search(i-1,j,rows,cols,ok,path[1:],List) or search(i,j-1,rows,cols,ok,path[1:],List)) else: return False for x in range(len(init)): if search(init[x][0],init[x][1],rows, cols, ok, path,[]): return True return False 机器人运动范围Q:地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：递归模拟机器人走路，用个列表记录机器人走过的路就行 Code 123456789101112131415161718class Solution_1: def movingCount(self, threshold, rows, cols): # write code here def Sum(x): res = 0 while x != 0: res += x % 10 x = x//10 return res def search(i,j,rows,cols,threshold,List=[]): if threshold&lt;0: return 0 if i&gt;=cols or j&gt;=rows or Sum(i)+Sum(j)&gt;threshold or [i,j] in List: return 0 else: List.append([i,j]) return 1+search(i+1,j,rows,cols,threshold,List)+search(i,j+1,rows,cols,threshold,List) return search(0,0,rows,cols,threshold) 二叉树的下一个节点Q:给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路：有right就沿着right的left一直找下去找到尽头没有right就沿着父节点一直向上找，直到导找到该节点是父节点的left Code 123456789101112131415class Solution: def GetNext(self, pNode): # write code here if not pNode: return pNode p = pNode if p.right: post = p.right while post.left: post = post.left return post while p.next: if p.next.left == p: return p.next p = p.next 二叉树的深度Q:输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路1：用self.temp记录当前深度，self.Max记录最大深度。先序self.temp+1，后序self.temp-1注意：不要思维定式先中后序只用一个 Code 123456789101112131415class Solution: def __init__(self): self.temp = 0 self.Max = 0 def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 self.temp += 1 if self.temp &gt; self.Max: self.Max = self.temp self.TreeDepth(pRoot.left) self.TreeDepth(pRoot.right) self.temp -= 1 return self.Max **思路2：更棒的方法 通过 左子树或右子树最大深度+1为当前子树深度 进行递归 Code 12345678class Solution: def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) return max(left, right)+1 平衡二叉树Q:输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路1：写一个递归函数判断深度，注意对max(left,right)的运用，即左子树或右子树最大深度+1为当前子树的深度（写出递归的关键所在）然后从根节点开始递归判断每个节点 缺点：根节点开始递归判断每个节点缺点：重复遍历节点，时间复杂度高 Code 1234567891011121314class Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs( self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right) ) &gt; 1: return False return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right) def TreeDepth(self, pRoot): if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) return max(left,right) + 1 思路2：同样写一个递归函数判断深度，但是一旦出现不满足返回值便为 -1 ，同时在后序中 left &lt; 0 or right &lt; 0 的运用保证了一旦出现非平衡子树，-1就一直会传递到最后，最后只需在主函数中判断深度是否 &gt;=0 。 对 -1 的传递真是太赞，好好体会 Code 123456789101112class Solution: def IsBalanced_Solution(self, pRoot): # write code here return self.TreeDepth(pRoot) &gt;= 0 def TreeDepth(self, pRoot): if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) if (left &lt; 0 or right &lt; 0 or abs(left - right) &gt; 1): return -1 return max(left, right) + 1 对称的二叉树Q:请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路：写递归函数（输入为两个节点）递归比较，递归方式为haha(left.left,right.right) and haha(left.right,right.left) Code 123456789101112class Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.haha(pRoot.left,pRoot.right) def haha(self,left,right): if not left and not right: return True if not left or not right or left.val != right.val : return False return self.haha(left.left,right.right) and self.haha(left.right,right.left) 把二叉树打印成多行Q:从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，NextLayer为贮存下层节点的临时list，遍历处理完本层节点后通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环。 Code 1234567891011121314151617181920class Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] NodeList = [pRoot] res = [] while NodeList: NextLayer = [] ValList = [] for node in NodeList: ValList.append(node.val) if node.left: NextLayer.append(node.left) if node.right: NextLayer.append(node.right) res.append(ValList) NodeList = NextLayer return res 按之字形打印二叉树Q:地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，NextLayer为贮存下层节点的临时list，遍历处理完本层节点后通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环。最后按照奇偶顺序修改val列表即可。 注意：将节点加入NextLayer时要判断存在与否，否则空类型也会被添加 Code 12345678910111213141516171819202122232425262728293031class Solution: def Print(self, pRoot): # write code here if not pRoot: return [] # Nodeque为循环遍历的node list Nodeque = [pRoot] # res为嵌套list,每个元素list为每层的val res = [] # 通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环 # 即每一圈while为每层的处理 while Nodeque: # NextLayer为本层节点的所有孩子节点 NextLayer = [] # ValList存取本层所有节点的val ValList = [] for node in Nodeque: ValList.append(node.val) if node.left: NextLayer.append(node.left) if node.right: NextLayer.append(node.right) res.append(ValList) Nodeque = NextLayer transres = [] for i,v in enumerate(res): if i % 2: transres.append(v[::-1]) else: transres.append(v) return transres 两个链表的第一个公共节点Q:输入两个链表，找出它们的第一个公共结点。这里的是指两个链表在某个节点之后会汇入同一个链表。 思路：最后两个链表汇入一个链表，即最后公共长度是一样的。因此可以先遍历两个链表，得出长度差在较长链表上提前多走长度差的步数，再一一比较 Code 123456789101112131415161718192021222324252627282930class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here if not pHead1 or not pHead2: return None p1 = pHead1 p2 = pHead2 length1 = 0 length2 = 0 while p1: length1 += 1 p1 = p1.next while p2: length2 += 1 p2 = p2.next p1 = pHead1 p2 = pHead2 differ = abs(length1 - length2) if length1 &gt; length2: for i in range(differ): p1 = p1.next else: for i in range(differ): p2 = p2.next while p1 and p2: if p1.val == p2.val: return p1 p1 = p1.next p2 = p2.next return None 数组中出现次数超过一半的元素Q:数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路1：用哈希记录每个元素出现的次数 Code 1234567891011121314class Solution27: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 1: return numbers[0] dic = &#123;&#125; for i in range(len(numbers)): if numbers[i] not in dic: dic[numbers[i]] = 1 else: dic[numbers[i]] += 1 if dic[numbers[i]]&gt;len(numbers)/2: return numbers[i] return 0 思路2：如果有个元素出现超过一半，那么这个元素比其他元素都多（废话）。据此，count记录所存储元素的计数，temp记录所存取元素。count == 0时，temp变为当前元素，count置1；count != 0时， 当前元素与temp相等，count+1否则-1;结束遍历一遍temp元素，看看是否次数超过一半。 Code 123456789101112131415161718192021222324class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here count = 0 temp = -99 for i in numbers: if count == 0: temp = i count += 1 else: if i != temp: count -= 1 else: count += 1 if count == 0: return 0 kan = 0 for i in numbers: if i == temp: kan += 1 if kan &gt; len(numbers) // 2: return temp else: return 0 丑数Q:把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路：考虑o(N)的用丑数生成丑数，不再遍历多余的非丑数。建立uglynums列表按顺序保存丑数。除了1以外，丑数肯定是排在之前的丑数乘以2、3、5的结果。问题在于怎样确保列表里面的丑数是排好顺序的。假设最大丑数为M，计算下一个丑数时小于M的肯定已经在列表当中。对于乘以2而言，肯定存在某一个丑数，排在它之前的每个丑数乘以2都小于M，排在它之后的每个丑数乘以2都远大于M，我们只需要记录下这个丑数的位置m2，对于乘以3和5，同样存下m3、m5. 12345注意： 1.更新标记只需要 +1 即可，+1之后再用到肯定大于M 2.此代码精彩的地方在于省略了对新丑数是否=M的判断，见下一条 3.有可能有几个数同时得到要添加的数值，如6（2*3，3*2）则m2,m3需要同时更新，这里的三个并列的if相当于省略了对更新的数是否=M的判断 Code 123456789101112131415161718class Solution: def GetUglyNumber_Solution(self, index): # write code here uglynums = [1] m2 = m3 = m5 =0 if index &lt; 1: return 0 if index == 1: return 1 for i in range(1,index+1): uglynums.append(min(uglynums[m2]*2, uglynums[m3]*3, uglynums[m5]*5)) if uglynums[i] == uglynums[m2]*2: m2 += 1 if uglynums[i] == uglynums[m3]*3: m3 += 1 if uglynums[i] == uglynums[m5]*5: m5 += 1 return uglynums[index-1] 数字在排序数组中出现的次数Q:统计一个数字在排序数组中出现的次数。 思路：二分查找找到一个target，返回index，然后往两边扩展 Code 12345678910111213141516171819202122232425262728293031class Solution: def Getindex(self, data, left, right, k): if left &gt; right: return -1 mid = (left + right) // 2 if data[mid] == k: return mid if data[mid] &lt; k: return self.Getindex(data, mid+1, right,k) else: return self.Getindex(data,left,mid-1,k) def GetNumberOfK(self, data, k): # write code here if not data: return 0 left = 0 right = len(data) - 1 flag = self.Getindex(data, left, right, k) if flag &lt; 0: return 0 else: l = r = flag while l &gt;= 1 and data[l-1] == k: l -= 1 if data[0] == k: l =0 while r &lt;= len(data) - 2 and data[r+1] == k: r += 1 if data[right] == k: r = right return r - l + 1]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2F2018%2F02%2F26%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode1.Two SumQ:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路：建立字典，key为值，val为值所对应位置 Code 12345678910111213class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ tag = &#123;&#125; for i in range(len(nums)): if nums[i] in tag: return[tag[nums[i]],i] else: tag[target-nums[i]]=i 2.Add Two NumbersQ:You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路：很简单 Code 123456789101112131415161718192021222324252627class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ takeover = 0 root = n = ListNode(0) while l1 or l2 or takeover: if l1: takeover += l1.val l1 = l1.next if l2: takeover += l2.val l2 = l2.next takeover, val = divmod(takeover, 10) # 以下两行可以写成 # n.next = n = ListNode(val) n.next = ListNode(val) n = n.next return root.next 3.Longest Substring Without Repeating CharactersQ:Given a string, find the length of the longest substring without repeating characters. Example: 12345Given "abcabcbb", the answer is "abc", which the length is 3.Given "bbbbb", the answer is "b", with the length of 1.Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring. 思路：建立字典key为值，val为该值最后一次出现的位置，用指针pre指向每次寻找的子串的开头位置 注意：自己思路是对的，但是错在没考虑嵌套重复如 abcddoua 遍历到第二个d时候重复pre指向第二个d 而遍历到第二个a时pre指向第一个a后的b，显然错的（即pre应该始终在字典回溯值之前，pre只能向后移动） Code 1234567891011def lengthOfLongestSubstringonglen(s): usedchar = &#123;&#125; maxlen = 0 pre = 0 for i in range(len(s)): if s[i] in usedchar and pre &lt;= usedchar[s[i]]: pre = usedchar[s[i]] + 1 else: maxlen = max(maxlen, i-pre+1) usedchar[s[i]] = i return maxlen 5. Longest Palindromic SubstringQ:Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 12345Input: "babad"Output: "bab"Note: "aba" is also a valid answer. 思路： ①for遍历选中心元素，找齐所有中心元素（第一个while 向后 找出所有与所选中心元素重复的元素） ② l r 指示回文边界，向两遍扩展 注意： ①l r 始终指向有效边界（闭区间，考虑边界值仍然是回文区域） ②注意边界情况判断，如第一个while循环判定条件有两个，应该把边界判断放在前面，要不会出现index越界 Code 1234567891011121314151617def longestPalindrome(s): if len(s) &lt;= 2: return s maxlen = real_l = real_r = 0 for i in range(len(s) - 1): l, r, pos = i, i, i+1 while ( pos &lt;= len(s) - 1) and s[r] == s[pos]: r = pos pos += 1 while (l &gt;= 1 and r &lt; (len(s) - 1)) and s[l - 1] == s[r + 1]: l -= 1 r += 1 if r - l + 1 &gt; maxlen: maxlen = r - l + 1 real_l = l real_r = r return s[real_l:real_r+1] 7. Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer. Example: 123456Input: 123Output: 321Input: -123Output: -321Input: 120Output: 21 思路： ①flag表示符号判断正数1负数-1 ②将int转为字符串形式，[::-1]表示字符串反转 ③bit_length表示位数的判断 注意： 注意对大数的判断 Code 1234def reverse(x): flag = (x&gt;0)-(x&lt;0) val = flag*int(str(abs(x))[::-1]) return val*(val.bit_length()&lt;32) 8. String to Integer (atoi)Q:Implement atoi to convert a string to an integer. Example: 12 思路：此题太乱没做，总结答案 str.strip（）用于移除首位指定字符串 str.isdigit()判断字符是否是数值 ord()将字符转换为ASCII码 chr()将ASCII码转为字符如ord(‘a’) -&gt; 97 chr(97) -&gt; ‘a’4. 字符串跟数值问题注意overflow问题，这里是有符号函数所以max=231-1 min=-231 注意： 注意对大数的判断 Code 1234567891011121314151617def myAtoi(self, s): """ :type str: str :rtype: int """ ###better to do strip before sanity check (although 8ms slower): if len(s) == 0: return 0 ls = list(s.strip()) sign = -1 if ls[0] == '-' else 1 if ls[0] in ['-', '+']: del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit(): ret = ret * 10 + ord(ls[i]) - ord('0') i += 1 return max(-2 ** 31, min(sign * ret, 2 ** 31 - 1)) 9. Palindrome NumberQ:Determine whether an integer is a palindrome. Do this without extra space. Example: 12 思路： 1.负数不是回文数、非零且末位为零不是回文数 2.用数字一半部分来比较避免了翻转数字overflow问题（赞） 注意： 注意对大数的处理（用数字一半部分作比较） Code 123456789101112def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0 or (x % 10 == 0 and x != 0): return False res = 0 while x &gt; res: res = res * 10 + x % 10 x = x // 10 return (x == res or x == res // 10) 11.Container With Most WaterQ:Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Example: 12 思路：分析此题可以得到一个解题基础：最终得到的两块挡板左挡板L和右挡板R，L左边的所有挡板一定短于L，R右边的所有挡板一定短于R。据此，可以从轴两遍开始向内遍历，每次记录最值，并且下次从较短的挡板继续向内遍历。 注意： 注意对python 中用while True: if XX: break 来代替do while Code 1234567891011121314151617181920212223242526272829def maxArea( height): """ :type height: List[int] :rtype: int """ l = 0 r = len(height) - 1 l_h = height[l] r_h = height[r] val = maxval = min(l_h, r_h) * (r - l) while (l &lt; r): if l_h &lt;= r_h: while True: l += 1 if height[l] &gt; l_h or l &gt;= r: if r &gt; l: l_h = height[l] break elif l_h &gt; r_h: while True: r -= 1 if height[r] &gt; r_h or l &gt;= r: if r &gt; l: r_h = height[r] break val = min(l_h, r_h) * (r - l) if val &gt; maxval: maxval = val return maxval 14.Longest Common PrefixQ:Write a function to find the longest common prefix string amongst an array of strings. Example: 1找到字符串们的最长前缀 思路：关于zip()以及zip(* )的用法 前者相当于压缩到一个list中，后者相当于分开 12345678910111213141516a=[1,2,3]b=[4,5,6,7]c=[8,9,10,11,12]zz=zip(a,b,c)print(zz)x,y,z=zip(*zz)print(x)print(y)print(z)输出：[(1, 4, 8), (2, 5, 9), (3, 6, 10)](1, 2, 3)(4, 5, 6)(8, 9, 10) Code 1234567891011def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' for i, group in enumerate(zip(*strs)): if len(set(group)) != 1: return strs[0][:i] return min(strs) 15.3 SumQ:Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路：开头 排序 为了跳过重复元素（用dup记录上一元素）遍历一次用twosum函数返回（twosum函数也要去重） Code 12345678910111213141516171819202122232425class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums = sorted(nums) result = [] dup = -999 for i in range(len(nums)-1): if nums[i] != dup: result.extend(self.twosum(nums[i],nums[i+1:],nums[i]*-1)) dup = nums[i] return result def twosum(self,p,arr,val): box = set() threesum = [] for i in range(len(arr)): if (val-arr[i] in box): temp = sorted([p,arr[i],val-arr[i]]) if temp not in threesum: threesum.append(temp) else: box.add(arr[i]) return threesum 16.3 Sum ClosestQ:Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 思路：排序后根据大小查找 Code 12345678910111213141516171819202122def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() close = nums[0]+nums[1]+nums[2] for i in range(len(nums)-1): j = i+1 k = len(nums)-1 while j&lt;k: sum = nums[i]+nums[j]+nums[k] if sum == target: return sum if abs(target-sum) &lt; abs(target-close): close = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return close 17.Letter Combinations of a Phone NumbertQ:Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Example: 12Input:Digit string "23"Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 思路：递归思想 字符串拼接用 + Code 1234567891011121314def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ mapping = &#123;'0': ' ', '1': '', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl' , '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if len(digits) == 0: return [] if len(digits) == 1: return list(mapping[digits[0]]) pre_comb = self.letterCombinations(digits[:-1]) last = mapping[digits[-1]] return [s + v for s in pre_comb for v in last] 18.4 SumQ:Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路：列表之间的拼接用 ‘+’先两层嵌套for循环将所有两两组合之和求出来，再用twosum思想 去重 保证每个元素只添加一次(通过变量保存下标而不是值) Code 1234567891011121314151617181920212223def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ dic = &#123;&#125; result = [] for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): twosum = nums[i] + nums[j] if target - twosum in dic: for two in range(len(dic[target - twosum])): thisfour = sorted([nums[i], nums[j]] + [nums[dic[target - twosum][two][0]], nums[dic[target - twosum][two][1]]]) # and前条件用于去重；and后条件用于去除元素是否重复利用 if thisfour not in result and len(set([i, j]) | set(dic[target - twosum][two])) == 4: result.append(thisfour) if twosum not in dic: dic[twosum] = [[i, j]] else: dic[twosum].append([i, j]) return result 19.Remove Nth Node From End of ListQ:Given a linked list, remove the nth node from the end of list and return its head. Note:Given n will always be valid.Try to do this in one pass. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 思路：构造一个长度为n的滑窗，滑到最后注意判断如果删除了第一个元素（此时post.next = null）应返回head.next Code 123456789101112131415161718def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ pre = head post = head for i in range(n): post = post.next # 注意这一步，如果删除的是head，直接返回head.next if not post: return head.next while post.next: pre = pre.next post = post.next pre.next = pre.next.next return head 20. Valid ParenthesesQ:Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not.. Example: 12 思路：not valid 只有三种情况，找准这三种情况的特点注意一手对ord()的应用 Code 1234567891011121314151617181920def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] for i in range(len(s)): if s[i] in ['(','&#123;','[']: stack = stack + [s[i]] else: if len(stack)==0: # 右括号比左括号多的情况 return False if ord(s[i])-ord(stack[-1])!= 1 and ord(s[i])-ord(stack[-1])!= 2: #左右括号不对称的情况 return False else: stack = stack[:-1] if len(stack) == 0: return True else: # 左括号比右括号多的情况 return False 21. Merge Two Sorted ListsQ:Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路： 1.正常思路，用and终止while，l1 或 l2 的尾巴可以一并加上 2.递归思想找准结束条件，链表一个一个拼接 Code 123456789101112131415161718192021222324252627282930313233# 第一种做法def mergeTwoLists( l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ head = p = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 or l2 #加上小尾巴 return head.next# 递归做法def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 22.Generate ParenthesesQ:Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: Example: 1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路： 不带返回值的递归（用于添加或者修改），递归生成每个str Left right 分别为左右括号的计数器 Init_str为目前生成的字符串 Code 123456789101112131415161718192021class Solution22: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if not n: return [] left, right, init_str = n, n, '' result = [] self.generate(left,right,init_str,result) return result def generate(self,left,right,init_str,result): if not left and not right: result.append(init_str) return if left: self.generate(left-1,right,init_str+'(',result) #left &lt; right 为添加右括号条件 if right and left &lt; right: self.generate(left,right-1,init_str+')',result) 24.wap Nodes in PairsQ:Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Example: 12input:1-&gt;2-&gt;3-&gt;4output:2-&gt;1-&gt;4-&gt;3. 思路：基本操作，但是遇到return head报错，return init.next就正确，没找到原因 Code 123456789101112131415161718192021def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ init = ListNode(0) pre = init pre.next = head while pre.next and pre.next.next: p = pre.next post = p.next p.next = post.next post.next = p pre.next = post if not p.next: break else: pre = p p = p.next post = p.next return init.next 24.wap Nodes in PairsQ:Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Example: 12input:1-&gt;2-&gt;3-&gt;4output:2-&gt;1-&gt;4-&gt;3. 思路：基本操作，但是遇到return head报错，return init.next就正确，没找到原因 Code 123456789101112131415161718192021def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ init = ListNode(0) pre = init pre.next = head while pre.next and pre.next.next: p = pre.next post = p.next p.next = post.next post.next = p pre.next = post if not p.next: break else: pre = p p = p.next post = p.next return init.next 26.Remove Duplicates from Sorted ArrayQ:Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example: 1234Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn't matter what you leave beyond the new length. 思路：简单题，在数组内删除重复元素，两个指针write、read,修改时候 A[write + 1] = A[read] Code 12345678910111213141516171819202122class Solution26(object): def removeDuplicates(self, A): """ :type nums: List[int] :rtype: int """ if not A: return 0 if len(A) == 1: return 1 write = 0 read = 1 while read &lt; len(A): if A[write] != A[read]: # 修改重复元素的方法 A[write + 1] = A[read] write += 1 read += 1 else: read += 1 A = A[:write + 1] return len(A) 27.Remove ElementQ:Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: 123Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2. 思路：简单的双指针 Code 1234567891011121314151617class Solution27: def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if not nums: return 0 read = write =0 while read &lt; len(nums): if nums[read] != val: nums[write] = nums[read] write += 1 read += 1 nums = nums[:write] return len(nums) 29.Divide Two IntegersQ:Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. Example: 12 思路：不会位运算，看了discussion此题两个while循环，第一个为结束条件，第二个循环每次减去除数的1、2、4、8……倍，结束第二个循环继续从一倍开始。减完回到第一个循环的判定条件判断是否需要再进行第二个while，相当于指数高效的记录倍数 Code 1234567891011121314151617181920class Solution29: def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i temp &lt;&lt;= 1 i &lt;&lt;= 1 if not positive: res = -res return min(max(-2 ** 31,res), 2**31-1) 31.Next PermutationQ:Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 从这几个数组合中找到下一个比他大的数 Example: 1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路：较简单，尽可能更改最后几位，并且从后往前如果一直是递增则就是这几个数的最大排列如4321，从后找到第一个非递增的数字p（如1245763中的5），然后将此数字与之后数字中 大于它且最接近于它 的数字（6）交换，交换后将该位置之后的数字升序排列（1246357）该题要求在原数组中修改，因此我把之后按升序拍了的数组建立一个临时数组temp_list，用for循环写入原数组 list.sort() 和 sorted(list)的区别 12345678a = [3,2,1]list.sort()就地修改无返回值 sorted(list)返回新列表，对所有可迭代对象均有效print(a.sort()) -&gt; Noneprint(sorted(a)) -&gt; [1,2,3]a.sort() print(a) -&gt; [1,2,3]#对于切片列表：a[1:].sort() print(a) -&gt;[3,2,1] 无效print(sorted(a[1:])) -&gt;[1,2] 注意： ①找与p交换的数字时从后往前找可以避免index越界问题 ②考虑有重复数字问题 ③while遍历时候考虑左右边界问题（如while p and 条件 -&gt;此为不超过左边界） Code 12345678910111213141516171819202122232425262728class Solution31: def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if not nums: return None p = len(nums) - 1 # while p用以阻止左边界越界 while p and nums[p-1] &gt;= nums[p]: p -= 1 if p == 0: nums.sort() return None else: p = p - 1 post = len(nums) - 1 # while post用以阻止左边界越界，同时从后往前找防止右边界越界 while post and nums[post]&lt;=nums[p]: post -= 1 temp = nums[p] nums[p] = nums[post] nums[post] = temp temp_list = sorted(nums[p+1:]) for i in range(p+1,len(nums)): nums[i] = temp_list[i-p-1] return None 33.Search in Rotated Sorted ArrayQ:Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Example: 12 思路：在排序或类排序数组中查找首先想到二分法此题因为不需要考虑重复元素，较为简单，列出所有情况来即可，我的代码比较繁琐，边界值判定条件应该可以统一一下，懒得改了因为最后的6种判定条件互斥，所以用 抑或^ 或者 or 都行分情况讨论如图（类似高中数学题） Code 12345678910111213141516171819202122232425class Solution33: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 1 and nums[0] == target: return 0 left = 0 right = len(nums)-1 while left &lt; right: mid = (left +right) // 2 if nums[left] == target: return left if nums[right] == target: return right if nums[mid] == target: return mid if (nums[mid]&gt;target and target &gt; nums[right])^(nums[right]&gt;nums[mid] and nums[mid]&gt;target )^(target&gt;nums[right] and nums[right]&gt;nums[mid]): right = mid - 1 else: left = mid + 1 return -1 34.Search for a RangeQ:Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example: 12Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 思路：很简单，因为是排序数组，所以先用二分法查找target,在从这个位置往两边扩展 注意： ①类似while pre&gt;0 and nums[pre] == target: 中判断while结束后的pre是否指向target(有可能因为边界条件跳出循环，并且边界仍满足target)来判断pre是否 -1 ②第一个while l&lt;=r: 中‘=’存在不构成死循环的原因如果l=r且指向target接下来会return，如果l=r不指向target之后对于mid与target判定仍会跳出循环 Code 12345678910111213141516171819202122232425262728293031class Solution34: def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if not nums or (len(nums)==1 and nums[0] != target): return [-1,-1] l = 0 r = len(nums) - 1 if l == r and nums[0]==target: return [0,0] while l &lt;= r: mid = (l+r) // 2 if nums[mid] == target: pre = post = mid while pre&gt;0 and nums[pre] == target: pre -= 1 while post&lt;len(nums)-1 and nums[post] == target: post += 1 if nums[pre] != target: pre += 1 if nums[post] != target: post -= 1 return [pre, post] elif nums[mid] &gt; target: r = mid - 1 else: l = mid + 1 return [-1, -1] 35.Search Insert PositionQ:Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example: 12345678Input: [1,3,5,6], 5Output: 2Input: [1,3,5,6], 2Output: 1Input: [1,3,5,6], 7Output: 4Input: [1,3,5,6], 0Output: 0 思路：没什么好说的，排序数列二分查找，注意边界值问题及while中的等号问题while 中 加’=’保证在无target的情况，mid在连续两位中的右边一位 注意：target&gt;max情况 Code 12345678910111213141516171819202122232425class Solution35: def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if not nums or (len(nums)==1 and nums[0]&gt;=target): return 0 if len(nums)==1 and nums[0]&lt;target: return 1 l = 0 r = len(nums)-1 while l &lt;= r: # 加‘=’保证在无target的情况，mid在连续两位中的右边一位 mid = (l + r) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: l = mid + 1 else: r = mid - 1 if nums[mid]&gt;target: return mid else: # target&gt;max情况 return mid+1 **]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>代码</tag>
      </tags>
  </entry>
</search>
