<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KTT条件]]></title>
    <url>%2F2018%2F03%2F04%2FKTT%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>机器学习</tag>
        <tag>KKT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日对偶性]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7%2F</url>
    <content type="text"><![CDATA[原始问题​ 假设$f(x), c_i(x), h_j(x)$是定义在$R^n$上面的连续可微函数，考虑约束最优化问题 \min_{x\in R^n}f(x)s.t.\ c_i(x)\le0,\ i=1,2,…,k​h_j(x)=0,\ j=1,2,…,l ​ ​ 称此约束最优化问题为原始最优化问题或原始问题。 ​ 首先，引进广义拉格朗日函数 ​L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x) ​ 这里，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i\ge0$. ​ 考虑函数(注意：此时$L(x,\alpha,\beta)$的变量是$\alpha_i\beta_j$)： ​\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta) ​ 这里下标$P(Primal)$表示原始问题.对于此函数（关于$\alpha,\beta$的函数，$x$是常量），经过我们优化（不管什么方法），确定$\alpha,\beta$的值，就可以得到$L(x,\alpha,\beta)$的最大值，因为此时$\alpha,\beta$已经确定，显然最大值\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)就是只和$x$有关的函数 ​ 下面通过$x$是否绵竹约束条件两方面来分析这个函数： ​ 1.考虑某个$x$违反了原始的约束，即$c_i\gt0$或者$h_j\neq0$，那么： ​\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=\infty ​ 2.考虑$x$满足原始的约束，则： ​\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)]=f(x) , ​ 注意最大化确定$\alpha,\beta$的过程，$f(x)$就是个常量，敞亮的最大值显然是本身 ​ 通过上面两条分析可以得出： ​\Theta_P(x)=\begin{cases}f(x),\ {x满足原始问题约束}\\+\infty,\ {其他}\\\end{cases} ​ 那么在满足约束的条件下： ​\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x) ​ 即$\min_x\Theta_P(x)$与原始优化问题等价，所以常用$\min_x\Theta_P(x)$来代表原始问题，定义原始问题的最优值： ​p^*=\min_x\Theta_P(x)​ 原始问题讨论到这里，总结：重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题。 对偶问题​ 定义关于$\alpha,\beta$的函数： ​\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta) ​ 注意上面等式右边是关于$x$的函数最小化,$x$确定之后，最小值就只与$\alpha,\beta$有关，所以此时是一个关于$\alpha,\beta$的函数 ​ 再考虑极大化$\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$，即： ​\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta) ​ 这就是原始问题的对偶问题，再将原始问题写出来： ​\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x) ​ 从形式上可以看出堆成，只不过原始问题先固定$L(x,\alpha,\beta)$中的$x$,优化参数$\alpha,\beta$，再优化$x$；而对偶问题是先固定$\alpha,\beta$，再优化$x$，然后再确定参数$\alpha,\beta$ ​ 定义对偶问题的最优值： ​d^*=\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta) 原始问题与对偶问题之间的关系​ 若原始问题和对偶问题都有最优值，则有$Min-Max$不等式： ​d^*=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)\le\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=p^* ​ 当$L(x,\alpha,\beta)$对$x$为凸函数，对$\alpha,\beta$为凹函数，以上等号成立。而$L(x,\alpha,\beta)$对$\alpha,\beta$为天然凹函数，因此只要$L(x,\alpha,\beta)$对$x$为凸函数，等号便成立 ​ 证明：一个式子的最大值永远大于等于这个式子的最小值，哪怕是这个式子最小的最大值与最大的最小值相比（瘦死的骆驼比马大）。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>机器学习</tag>
        <tag>拉格朗日对偶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer二维数组中的查找Q:在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：思路从右上开始，右上为一行最大，一列最小。target&lt;右上，删一列; target&gt;右上,删一行 Code 1234567891011121314class Solution1: # array 二维列表 def Find(self, target, array): # write code here i = 0 j = len(array[0])-1 while i&lt;len(array) and j&gt;=0: if array[i][j] == target: return True elif array[i][j] &gt; target: j -= 1 else: i += 1 return False 替换空格Q:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：python式。。 其他语言思路：从头到尾遍历数空格数量，然后从后往前遍历，碰到空格后根据之前数好的数量移位 Code 123456class Solution2: # s 源字符串 def replaceSpace(self, s): # write code here s= s.replace(' ', '%20') return s 从尾到头打印链表Q:输入一个链表，从尾到头打印链表每个节点的值 思路：遍历链表每次遍历的val从头插入list Code 12345678910class Solution3: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here list = [] p = listNode while p: list = [p.val] + list p = p.next return list 重建二叉树Q:输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：先序第一个为根节点，中序中根节点左边全在左子树，右边全在右子树。据此用递归建树 Code 123456789101112131415161718192021222324252627# 我的解法# 对len==1的list判定，繁琐class Solution32: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here root = TreeNode(pre[0]) if len(pre) == 1 and len(tin) == 1: return root root_index = tin.index(pre[0]) if root_index != 0: root.left = self.reConstructBinaryTree(pre[1:root_index+1],tin[:root_index]) if root_index != len(tin)-1: root.right = self.reConstructBinaryTree(pre[root_index+1:],tin[root_index+1:]) return root# 精简解法# 对空list的判定，鲁棒性更强，更精简def reConstructBinaryTree(self, pre, tin): # write code here if not pre or not tin: return None root = TreeNode(pre[0]) index = tin.index(root.val) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[0:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 旋转数组的最小数字Q:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路：太简单，不说了 Code 12345678910111213class Solution5: def minNumberInRotateArray(self, rotateArray): # write code here nums = rotateArray if not nums: return 0 p = len(nums) - 1 min = nums[0] while p &gt; 0 and nums[p-1]&lt;= nums[p]: p -= 1 if nums[p] &lt; min: min = nums[p] return min 斐波那契数列Q:大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 思路：分别用while 与 递归实现 Code 1234567891011121314151617181920212223242526# 不用递归，避免重复运算，运行时间短class Solution6: def Fibonacci(self, n): # write code here if n == 0: return 0 if n &lt; 3: return 1 pre = 1 post = 1 count = 3 while count &lt;= n: temp = post post = pre + post pre = temp count += 1 return post# 递归，代码简单，运行超时class Solution62: def Fibonacci(self, n): # write code here if n == 0: return 0 if n == 1: return 1 return self.Fibonacci(n-1) + self.Fibonacci(n-2) 跳台阶Q:一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：斐波那契数列问题，斐波那契数列前移一位 Code 1234567891011121314class Solution7: def jumpFloor(self, number): # write code here if number &lt; 2: return 1 pre = 1 post = 1 count = 2 while count &lt;= number: temp = post post = pre + post pre = temp count += 1 return post 变态跳台阶Q:一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 思路： F(n) = F(n-1)+F(n-2)+F(n-3)+….+F(1) 第n项是前n-1项的和，所以第n+1项是第n项的两倍，都是二的指数次方 Code 1234class Solution8: def jumpFloorII(self, number): # write code here return 2 ** (number-1) 矩形覆盖Q:我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路：还是个斐波那契问题 n*2 矩形覆盖时候最后一步要不覆盖田，要不覆盖日，因此是斐波那契问题F(n) = F(n-1)+F(n-2)只不过题目规定F(0)=0 Code 12345678910111213141516class Solution9: def rectCover(self, number): # write code here if not number: return 0 if number &lt; 2: return 1 pre = 1 post = 1 count = 2 while count &lt;= number: temp = post post = pre + post pre = temp count += 1 return post 二进制中1的个数Q:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路1：一个整数减去1，再和原整数做 与 运算，会把该整数最右边的1变成0（用补码表示的负数也是）。所以一个整数中有多少个1就可以进行多少次这种运算该法用python写超时 Code 12345678class Solution10: def NumberOf1(self, n): # write code here i = 0 while n: n = n &amp; (n-1) i += 1 return i 思路2：因为右移数字n会造成死循环（负数第一位是1），可以先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算……反复左移就能判断n的其中一位是不是1 注意：1要是无符号整数(unsigned int) Code 123456789101112int NumberOf1(int n)&#123; int count = 0; unsigned int flag = 1; while(flag) &#123; if(n&amp;flag) count ++ flag = flag &lt;&lt; 1 &#125; return count;&#125; 数值的整数次方Q:给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路：Life is short, you need python Code 1234class Solution11: def Power(self, base, exponent): # write code here return pow(base, exponent) 调整数组是奇数位于偶数前并保证奇数偶数各自相对位置Q:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路：一个list存奇数一个list存偶数，两个合起来 Code 1234567891011class Solution12: def reOrderArray(self, array): # write code here res1 = [] res2 = [] for i in range(len(array)): if array[i] % 2 == 0 : res2.append(array[i]) else: res1.append(array[i]) return res1+res2 链表中倒数第K个节点Q:请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：构造长度为K的滑窗（构造时考虑K过大问题），将滑窗滑至最后即可 Code 12345678910111213141516171819class Solution13: def FindKthToTail(self, head, k): # write code here if k &lt; 1: return None if not head: return None post = pre = head count = k while k-1 &gt; 0: if post.next: post = post.next k -= 1 else: return None while post.next: post = post.next pre = pre.next return pre 翻转链表Q:输入一个链表，反转链表后，输出链表的所有元素。 思路：比较简单临近双指针遍历至最后，注意最后对边界值的处理 Code 123456789101112131415161718class Solution14: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead post = pHead.next pHead.next = None while post: if post.next: temp = post.next else: post.next = pHead break post.next = pHead pHead = post post = temp return post 合并两个排序链表Q:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路：每次选出两个链表较小的头结点，然后用剩下的递归链接 Code 123456789101112class Solution15: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here if not pHead1 or not pHead2: return pHead1 or pHead2 if pHead1.val &lt; pHead2.val: pHead1.next = self.Merge(pHead1.next, pHead2) return pHead1 else: pHead2.next = self.Merge(pHead1, pHead2.next) return pHead2 树的子结构Q:输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路1：递归的查找子结构 注意： ①要全面遍历所有所可能（类似机器人路径中的找出所有起始位置），不能找到一对根节点相等的点，后面不等就return False； 这里体现在相等时候也留一手 or 类似与不等继续进行判断 ②因为题中给出空节点不是子结构，而我迭代又要用到对pRoot2是否为空的判断，因此，先对pRoot2判断，再单独写了个函数 ③本题求的是子结构而非子树 Code 1234567891011121314151617class Solution16: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot2: return False def Search(pRoot1,pRoot2): if not pRoot2: return True if not pRoot1: return False if pRoot1.val ==pRoot2.val: # 注意or的运用，遍历所有可能的节点 return True and ( (Search(pRoot1.left,pRoot2.left) and Search(pRoot1.right,pRoot2.right)) or Search(pRoot1.left,pRoot2) or Search(pRoot1.right,pRoot2) ) else: return Search(pRoot1.left,pRoot2) or Search(pRoot1.right,pRoot2) return Search(pRoot1,pRoot2) 思路2：更精简的分治递归 写一个函数判断两树是同一根节点的情况下pRoot2是否是pRoot1的子结构 在主函数里递归调用这个函数 Code 123456789101112class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False return self.IsSub(pRoot1,pRoot2) or self.IsSub(pRoot1.left,pRoot2) or self.IsSub(pRoot1.right,pRoot2) def IsSub(self,p1,p2): if not p2: return True if not p1 or p1.val != p2.val: return False return self.IsSub(p1.left,p2.left) and self.IsSub(p1.right,p2.right) 二叉树的镜像Q:操作给定的二叉树，将其变换为源二叉树的镜像。 思路：递归实现没什么难度 Code 1234567891011121314class Solution17: # 返回镜像树的根节点 def Mirror(self, root): # write code here def Trans(root): if not root: return temp = root.left root.left = root.right root.right = temp Trans(root.left) Trans(root.right) Trans(root) return root 顺时针打印矩阵Q:输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路：通过递归函数实现，每次添加最外一圈 注意：对行列为2的判断（里面的if判断），过程中一个不满足就代表添加完毕 Code 1234567891011121314151617181920212223242526272829303132class Solution18: # matrix类型为二维列表，需要返回列表 def __init__(self): self.List = [] def printMatrix(self, matrix): # write code here row_u = 0 row_d = len(matrix) - 1 col_l = 0 col_r = len(matrix[0]) - 1 def Printnum(matrix,row_u,row_d,col_l,col_r): if row_u &gt; row_d or col_l &gt; col_r: return if row_u &lt;= row_d and col_l &lt;= col_r: for j in range(col_l,col_r+1): self.List.append(matrix[row_u][j]) row_u += 1 if row_u &lt;= row_d and col_l &lt;= col_r: for i in range(row_u,row_d+1): self.List.append(matrix[i][col_r]) col_r -= 1 if row_u &lt;= row_d and col_l &lt;= col_r: for j in range(col_r,col_l-1,-1): self.List.append(matrix[row_d][j]) row_d -= 1 if row_u &lt;= row_d and col_l &lt;= col_r: for i in range(row_d,row_u-1,-1): self.List.append(matrix[i][col_l]) col_l += 1 Printnum(matrix,row_u,row_d,col_l,col_r) Printnum(matrix,row_u,row_d,col_l,col_r) return self.List 包含Min函数的栈Q:定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 思路：python式。。 Code 123456789101112131415class Solution19: def __init__(self): self.stack = [] def push(self, node): # write code here self.stack.append(node) def pop(self): # write code here self.stack = self.stack[:-1] def top(self): # write code here return self.stack[-1] def min(self): # write code here return min(self.stack) 栈的压入、弹出序列Q:输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路：弹出一个便从压入list中记录index为p，并删除 这个元素。下一个弹出的元素的index只能是p的前一个位置(pre)或者后面位置，弹出后便继续更新p 注意：压入list中删除元素后要更新index。list.remove(val)删除后会更新index，正好符合这道题。 Code 1234567891011121314151617class Solution20: def IsPopOrder(self, pushV, popV): # write code here pre = p = -1 for i in range(len(popV)): # 判断pushV popV是否一致 if popV[i] not in pushV: return False if pushV.index(popV[i]) &lt; pre: return False p = pushV.index(popV[i]) pushV.remove(popV[i]) if p == 0: pre = -1 else: pre = p - 1 return True 从上往下打印二叉树Q:从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：简单的层序遍历 注意：node=[] res=[] 跟 node=res=[]的区别，前面两个是两个[]，后面两个是同一个[] Code 1234567891011121314151617class Solution21: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root : return [] node = [] res = [] node.append(root) while node: res.append(node[0].val) if node[0].left: node.append(node[0].left) if node[0].right: node.append(node[0].right) node = node[1:] return res 二叉树的后序遍历序列Q:输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路：二叉搜索树的中序遍历序列便相当于升序序列，因此将原序列排序便得到中序序列。然后判断能否成树判断能否成树的方法：后序最末位为根节点，通过此节点在中序中的位置（mid_index）分割左右子树节点。 递归判断不能成树的条件是：递归中一旦出现两序列节点组成不一致的情况（最重要的思想！！！想死我了） 注意：其实此题不需要用到二叉搜索树left&lt;root&lt;right，或者说这个条件的全部信息都转化为升序序列为中序序列刚看此题想到中序序列以为此题得到解决，但是拘泥于二叉搜索树的性质写不出递归，其实可完全转化为一个中序一个后序能否成树问题。能否成树又可通过递归过程序列组成是否全程一致来判断。 Code 12345678910111213141516class Solution22: def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False mid = sorted(sequence) post = sequence def Define(mid, post): if not mid and not post: return True # 不能成树的判定 if set(mid)!= set(post): return False mid_index = mid.index(post[-1]) return True and Define(mid[:mid_index],post[:mid_index]) and Define(mid[mid_index+1:],post[mid_index:-1]) return Define(mid,post) 二叉树中和为某一值的路径Q:输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路：定义全局list：self.res，用rest记录剩下路径所需拟合值，PathList记录当前路径。递归遍历节点如果root.val拟合完毕，将PathList并入全局res，并且rest重置为expectNumber，重置PathList=[]，从孩子节点从头递归；如果root.val不拟合rest，则将这个节点加入当前PathList，左右孩子传承此PathList继续递归寻找接下来的Path，左右孩子也要不继承PathList把rest重置为expectNumber从头递归 注意： ①root.val拟合或者不拟合都要在左右孩子加一个递归重置rest为expectNumber，重置PathList=[]继续寻找 ②左右节点继承当前PathList递归时，PathList要分开指代，要不右节点会继承左节点的PathList ③PathList2=PathList这种方法指代，这俩指针还是指向同一list Code 123456789101112131415161718192021222324252627282930313233class Solution23: # 返回二维列表，内部每个列表表示找到的路径 def __init__(self): self.res = [] def FindPath(self, root, expectNumber): # write code here def Path(root, expectNumber, rest, PathList=[] ): if not root: return if root.val == rest: PathList=PathList+[root.val] # 不加以下这个if结构是任意子路径，加了代表路径结尾必须是叶子节点。 if not root.left and not root.right: self.res.append(PathList) Path(root.left,expectNumber,expectNumber,[]) Path(root.right,expectNumber,expectNumber,[]) return else: PathList.append(root.val) rest -= root.val # 将此节点填入路径继续递归 # 接下来两个递归会操作同一个PathList，这两个不应该操作统一list # 直接令PathList2=PathList这俩还是指向同一个 PathList2 = [] PathList2 += PathList Path(root.left,expectNumber,rest,PathList) Path(root.right,expectNumber,rest,PathList2) # 从此节点的子节点开始从头寻找路径 Path(root.left,expectNumber,expectNumber,[]) Path(root.right,expectNumber,expectNumber,[]) return Path(root,expectNumber,expectNumber,[]) return self.res 复杂链表的复制Q:输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路1：难点在给随机指针赋值时候怎样指向已存在的节点，这里的思路是通过next复制节点时，构造原节点与新节点一一对应的字典此方法因为用到哈希，空间复杂度较大 Code 123456789101112131415161718192021222324252627class Solution24: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return None Node_dic = &#123;&#125; pre = pHead clone_head = RandomListNode(pre.label) p = clone_head Node_dic[pre] = p while pre: pre = pre.next if pre : temp = RandomListNode(pre.label) p.next = temp p=p.next # 边复制节点边构造哈希表 Node_dic[pre] = p pre = pHead p = clone_head while pre: if pre.random: p.random = Node_dic[pre.random] pre = pre.next p = p.next return clone_head 思路2：省去了空间复杂度，复制链表时一一间隔，将新节点插入原链表 注意：不能用一个while（调整random指针的while）直接将合并的链表拆开 因为如果有random指向前面会出错，因为已经不是一一间隔了 Code 1234567891011121314151617181920212223242526272829303132333435class Solution24_2: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead p = pHead # 将新节点一一间隔插入原链表 while p: temp = RandomListNode(p.label) temp.next = p.next p.next = temp p = p.next.next pre = pHead post = pre.next new_head = pre.next while pre: if pre.random: post.random = pre.random.next pre = post.next if not pre: continue if pre.next: post = pre.next pre = pHead post = pre.next # 不能直接在上一个while直接将两链表分开，如果有random指向前面会出错，因为已经不是一一间隔了 while pre: pre.next = post.next # 考虑到尾节点情况 if post.next: post.next = post.next.next pre = pre.next post = post.next return new_head 二叉搜索树与双向链表Q:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路：二叉搜索树中序序列便是升序序列，用中序遍历构造链表 注意：需要两个全局变量记录起点指针self.head，还有上一节点的指针self.p Code 12345678910111213141516171819202122232425class Solution25: def __init__(self): self.p = None self.head = None def Convert(self, pRootOfTree): # write code here root = pRootOfTree def Trans(root): if not root: return #temp保留右指针 temp_left = root.left temp_right = root.right self.Convert(temp_left) if not self.p: self.p = root self.head = root else: self.p.right = root root.left = self.p self.p = root self.Convert(temp_right) return Trans(root) return self.head 字符串的排列Q:输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路1：先用递归将所有可能的情况列出来，用sorted（）解决字典排序问题列出所有情况的方法：分成两个列表s1,s2 ，每次s2中的一个元素加入s1当做下一个s1，其余元素当做下一个s2，进行递归自己的解法：非常不优雅，先将str转为list，在转为str添加进去，还用到了py自带的排序解决字典序问题 如果不用自带排序，则可以参考LeetCode31 注意：因为python中的字符串不可以更改，所以，先将str转为list，在转为str添加进去 Code 1234567891011121314151617181920212223class Solution26_1: def __init__(self): self.res = [] def Permutation(self, ss): # write code here if not ss: return [] def allkinds(s1,s2): if len(s2) == 1: s = ''.join(s1+s2) self.res.append(s) return for i in range(len(s2)): # 将选中元素替换到s2第一位 temp = s2[i] s2[i]=s2[0] s2[0]=temp allkinds(s1+[s2[0]],s2[1:]) return s = sorted(ss) allkinds([],s) self.res = list(set(self.res)) return sorted(self.res) 思路2：itertools.permutations用来返回所有排列（元组形式）的list’’.join() 将list、元组内的字符结合成字符串map函数将f应用于右边可迭代的每一个对象 Code 12345678import itertoolsclass Solution26_2: def Permutation(self, ss): # write code here if not ss : return [] else: return sorted(list(set(map(''.join,itertools.permutations(ss))))) 最小的k个数Q:输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路1：python式 Code 123456class Solution28_1: def GetLeastNumbers_Solution(self, tinput, k): # write code here if k&gt;len(tinput): return [] return sorted(tinput)[:k] 思路2：partition函数法（快排）：如果下标刚好是k(k-1)则左边(k-1则包含本身)便是所求，如果下标&gt;k则递归左边，下标&lt;k递归右边 Code 1234567891011121314151617181920212223242526272829class Solution28_2: def GetLeastNumbers_Solution(self, tinput, k): # write code here if k &gt; len(tinput): return [] def Partition(nums, k): i = 0 j = len(nums) - 1 temp = nums[0] while i &lt; j: while nums[j] &gt; temp: j -= 1 nums[i] = nums[j] i += 1 while nums[i] &lt;= temp: i += 1 nums[j] = nums[i] j -= 1 nums[i] = temp if i == k - 1 or i == k - 2: return elif i &gt; k - 1: return Partition(nums[:i], k) else: return Partition(nums[i + 1:], k - i - 1) Partition(tinput, k) return sorted(tinput[:k]) 连续子数组的最大和Q:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。 思路： 两个变量分别记录当前累加值(self.temp)与最大累加值(self.Max)。从头到尾累加数字如果self.temp&lt;0则在每次累加之前将其置0。最关键一点就是用self.temp记录最大值 动态规划思想：用f(i)表示以第i个数字结尾的子数组的最大和则max（f(i)）可由一下迭代公式求f(i)=Datai&lt;=0) f(i)=f(i-1)+Datai&gt;0) Code 12345678910111213class Solution29: def __init__(self): self.temp = -99 self.Max = -99 def FindGreatestSumOfSubArray(self, array): # write code here for i in range(len(array)): if self.temp &lt; 0: self.temp = 0 self.temp += array[i] if self.temp &gt; self.Max: self.Max = self.temp return self.Max 整数中1出现的次数Q:求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 思路： 10个数里面有1个个位1；每100个数里面有10个十位1（10、11、12……19）；每1000个数里面有100个百位1 …… 另外需要判断是否应该考虑剩余部分，剩余部分需要判断如115 里面有 10 + (115-110+1) 个十位1 Code 1234567891011121314151617181920212223242526class Solution30: def NumberOf1Between1AndN_Solution(self, n): # write code here if n &lt; 1: return 0 if n&lt;10: return 1 result = 0 # count代表n的位数 count = len(str(n)) # 这里相当于两位到 count-1位 第count 位要单独讨论 for i in range(1,count+1): # count为完整的倍数 times = n//(10**i) # num 为每一份对应的1的个数 num = 10 ** (i-1) # rest 为除掉完整的份数剩下的 rest = n - times*(10**i) result += times * num if rest &gt;= 2 * (10**(i-1)): result += 10**(i-1) elif rest &lt; (10**(i-1)): result += 0 else: result += rest - (10**(i-1)) + 1 return result 将数组排成最小的数Q:输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路：全部转化为字符串，用itertools.permutations列出全组合，直接用min 找全组合中最小的 注意：对itertools.permutations、map()、’ ‘.join的应用 Code 123456789class Solution31: def PrintMinNumber(self, numbers): # write code here if not numbers: return '' for i in range(len(numbers)): numbers[i] = str(numbers[i]) List = map(''.join,list(itertools.permutations(numbers,len(numbers)))) return int(min(List)) 序列化二叉树Q:请实现两个函数，分别用来序列化和反序列化二叉树 思路1：非递归，用栈 序列化：先序遍历得到字符串 反序列化：用栈记录字符串的节点，非#时入栈，flag指向添加方式1为左0为右，flag= =0时出栈，新元素入栈时flag = =1 遇到#号时flag= =0 注意：链接节点时候一定要注意指针。要用原节点去链接，而不是构造与原节点相同的节点链接（见注释） Code 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution_7_mine: def Serialize(self, root): # write code here if not root: return "#" else: return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') if not s: return None if len(s) == 1: return TreeNode(s[0]) root = TreeNode(s[0]) stack = [root] i = 1 flag = 1 # flag==1指示left添加且不用退栈，flag==0指示右边添加且要退栈 while i&lt;len(s): if s[i] != '#': if flag == 1: stack[-1].left = TreeNode(s[i]) # stack.append(TreeNode(s[i])) 是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接 stack.append(stack[-1].left) i += 1 else: stack[-1].right = TreeNode(s[i]) pop_node = stack[-1] stack = stack[:-1] # stack.append(TreeNode(s[i])) 是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接 stack.append(pop_node.right) i += 1 flag = 1 else: if flag == 1: #stack[-1].left = None flag = 0 i += 1 else: #stack[-1].right = None stack = stack[:-1] i += 1 return root 思路2：精简的递归思路 ①通过 def init(self):构造flag全局变量指示遍历位置 ②通过self.flag指示list位置建树，建树过程类似遍历过程，只不过遇到#return ③注意l元素本身为字符，给节点赋值时注意int化 123456789101112131415161718192021class Solution: def __init__(self): self.flag = -1 def Serialize(self, root): # write code her if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here self.flag += 1 l = s.split(',') if self.flag &gt;= len(l): return None if l[self.flag] == '#': return None else: root = TreeNode(int(l[self.flag])) root.left = self.Deserialize(s) root.right = self.Deserialize(s) return root 二叉树的第K个节点Q:给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / 3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 思路：二叉搜索树中序遍历就是升序 Code 123456789101112131415class Solution_5: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if k == 0 or not pRoot: return res = [] def dfs(root,res=[]): if not root: return dfs(root.left,res) res.append(root) dfs(root.right,res) dfs(pRoot,res) return res[k-1] if k&lt;=len(res) else None 矩阵中的路径Q:请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路：先用嵌套for循环找出所有起始位置，对每个位置依次用递归函数搜寻 注意：每次开始要用新的空list记录路径 Code 12345678910111213141516171819202122232425262728class Solution_2: def hasPath(self, matrix, rows, cols, path): # write code here ok = [] for i in range(rows): ok.append([]) for _ in range(len(matrix)): ok[_//cols].append(matrix[_]) init = [] for i in range(rows): for j in range(cols): if ok[i][j] == path[0]: init.append([i,j]) def search(i,j,rows,cols,ok,path,List=[]): if not path: return True if i&lt;0 or j&lt;0 or i&gt;=rows or j&gt;=cols or [i,j] in List : return False if ok[i][j] == path[0]: List.append([i,j]) return True and (search(i+1,j,rows,cols,ok,path[1:],List) or search(i,j+1,rows,cols,ok,path[1:],List) or search(i-1,j,rows,cols,ok,path[1:],List) or search(i,j-1,rows,cols,ok,path[1:],List)) else: return False for x in range(len(init)): if search(init[x][0],init[x][1],rows, cols, ok, path,[]): return True return False 机器人运动范围Q:地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：递归模拟机器人走路，用个列表记录机器人走过的路就行 Code 123456789101112131415161718class Solution_1: def movingCount(self, threshold, rows, cols): # write code here def Sum(x): res = 0 while x != 0: res += x % 10 x = x//10 return res def search(i,j,rows,cols,threshold,List=[]): if threshold&lt;0: return 0 if i&gt;=cols or j&gt;=rows or Sum(i)+Sum(j)&gt;threshold or [i,j] in List: return 0 else: List.append([i,j]) return 1+search(i+1,j,rows,cols,threshold,List)+search(i,j+1,rows,cols,threshold,List) return search(0,0,rows,cols,threshold) 二叉树的下一个节点Q:给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路：有right就沿着right的left一直找下去找到尽头没有right就沿着父节点一直向上找，直到导找到该节点是父节点的left Code 123456789101112131415class Solution: def GetNext(self, pNode): # write code here if not pNode: return pNode p = pNode if p.right: post = p.right while post.left: post = post.left return post while p.next: if p.next.left == p: return p.next p = p.next 二叉树的深度Q:输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路1：用self.temp记录当前深度，self.Max记录最大深度。先序self.temp+1，后序self.temp-1注意：不要思维定式先中后序只用一个 Code 123456789101112131415class Solution: def __init__(self): self.temp = 0 self.Max = 0 def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 self.temp += 1 if self.temp &gt; self.Max: self.Max = self.temp self.TreeDepth(pRoot.left) self.TreeDepth(pRoot.right) self.temp -= 1 return self.Max **思路2：更棒的方法 通过 左子树或右子树最大深度+1为当前子树深度 进行递归 Code 12345678class Solution: def TreeDepth(self, pRoot): # write code here if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) return max(left, right)+1 平衡二叉树Q:输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路1：写一个递归函数判断深度，注意对max(left,right)的运用，即左子树或右子树最大深度+1为当前子树的深度（写出递归的关键所在）然后从根节点开始递归判断每个节点 缺点：根节点开始递归判断每个节点缺点：重复遍历节点，时间复杂度高 Code 1234567891011121314class Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs( self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right) ) &gt; 1: return False return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right) def TreeDepth(self, pRoot): if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) return max(left,right) + 1 思路2：同样写一个递归函数判断深度，但是一旦出现不满足返回值便为 -1 ，同时在后序中 left &lt; 0 or right &lt; 0 的运用保证了一旦出现非平衡子树，-1就一直会传递到最后，最后只需在主函数中判断深度是否 &gt;=0 。 对 -1 的传递真是太赞，好好体会 Code 123456789101112class Solution: def IsBalanced_Solution(self, pRoot): # write code here return self.TreeDepth(pRoot) &gt;= 0 def TreeDepth(self, pRoot): if not pRoot: return 0 left = self.TreeDepth(pRoot.left) right = self.TreeDepth(pRoot.right) if (left &lt; 0 or right &lt; 0 or abs(left - right) &gt; 1): return -1 return max(left, right) + 1 对称的二叉树Q:请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路：写递归函数（输入为两个节点）递归比较，递归方式为haha(left.left,right.right) and haha(left.right,right.left) Code 123456789101112class Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.haha(pRoot.left,pRoot.right) def haha(self,left,right): if not left and not right: return True if not left or not right or left.val != right.val : return False return self.haha(left.left,right.right) and self.haha(left.right,right.left) 把二叉树打印成多行Q:从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路：据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，NextLayer为贮存下层节点的临时list，遍历处理完本层节点后通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环。 Code 1234567891011121314151617181920class Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] NodeList = [pRoot] res = [] while NodeList: NextLayer = [] ValList = [] for node in NodeList: ValList.append(node.val) if node.left: NextLayer.append(node.left) if node.right: NextLayer.append(node.right) res.append(ValList) NodeList = NextLayer return res 按之字形打印二叉树Q:地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，NextLayer为贮存下层节点的临时list，遍历处理完本层节点后通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环。最后按照奇偶顺序修改val列表即可。 注意：将节点加入NextLayer时要判断存在与否，否则空类型也会被添加 Code 12345678910111213141516171819202122232425262728293031class Solution: def Print(self, pRoot): # write code here if not pRoot: return [] # Nodeque为循环遍历的node list Nodeque = [pRoot] # res为嵌套list,每个元素list为每层的val res = [] # 通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环 # 即每一圈while为每层的处理 while Nodeque: # NextLayer为本层节点的所有孩子节点 NextLayer = [] # ValList存取本层所有节点的val ValList = [] for node in Nodeque: ValList.append(node.val) if node.left: NextLayer.append(node.left) if node.right: NextLayer.append(node.right) res.append(ValList) Nodeque = NextLayer transres = [] for i,v in enumerate(res): if i % 2: transres.append(v[::-1]) else: transres.append(v) return transres 两个链表的第一个公共节点Q:输入两个链表，找出它们的第一个公共结点。这里的是指两个链表在某个节点之后会汇入同一个链表。 思路：最后两个链表汇入一个链表，即最后公共长度是一样的。因此可以先遍历两个链表，得出长度差在较长链表上提前多走长度差的步数，再一一比较 Code 123456789101112131415161718192021222324252627282930class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here if not pHead1 or not pHead2: return None p1 = pHead1 p2 = pHead2 length1 = 0 length2 = 0 while p1: length1 += 1 p1 = p1.next while p2: length2 += 1 p2 = p2.next p1 = pHead1 p2 = pHead2 differ = abs(length1 - length2) if length1 &gt; length2: for i in range(differ): p1 = p1.next else: for i in range(differ): p2 = p2.next while p1 and p2: if p1.val == p2.val: return p1 p1 = p1.next p2 = p2.next return None]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2F2018%2F02%2F26%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode1.Two SumQ:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路：建立字典，key为值，val为值所对应位置 Code 12345678910111213class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ tag = &#123;&#125; for i in range(len(nums)): if nums[i] in tag: return[tag[nums[i]],i] else: tag[target-nums[i]]=i 2.Add Two NumbersQ:You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路：很简单 Code 123456789101112131415161718192021222324252627class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ takeover = 0 root = n = ListNode(0) while l1 or l2 or takeover: if l1: takeover += l1.val l1 = l1.next if l2: takeover += l2.val l2 = l2.next takeover, val = divmod(takeover, 10) # 以下两行可以写成 # n.next = n = ListNode(val) n.next = ListNode(val) n = n.next return root.next 3.Longest Substring Without Repeating CharactersQ:Given a string, find the length of the longest substring without repeating characters. Example: 12345Given "abcabcbb", the answer is "abc", which the length is 3.Given "bbbbb", the answer is "b", with the length of 1.Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring. 思路：建立字典key为值，val为该值最后一次出现的位置，用指针pre指向每次寻找的子串的开头位置 注意：自己思路是对的，但是错在没考虑嵌套重复如 abcddoua 遍历到第二个d时候重复pre指向第二个d 而遍历到第二个a时pre指向第一个a后的b，显然错的（即pre应该始终在字典回溯值之前，pre只能向后移动） Code 1234567891011def lengthOfLongestSubstringonglen(s): usedchar = &#123;&#125; maxlen = 0 pre = 0 for i in range(len(s)): if s[i] in usedchar and pre &lt;= usedchar[s[i]]: pre = usedchar[s[i]] + 1 else: maxlen = max(maxlen, i-pre+1) usedchar[s[i]] = i return maxlen 5. Longest Palindromic SubstringQ:Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 12345Input: "babad"Output: "bab"Note: "aba" is also a valid answer. 思路： ①for遍历选中心元素，找齐所有中心元素（第一个while 向后 找出所有与所选中心元素重复的元素） ② l r 指示回文边界，向两遍扩展 注意： ①l r 始终指向有效边界（闭区间，考虑边界值仍然是回文区域） ②注意边界情况判断，如第一个while循环判定条件有两个，应该把边界判断放在前面，要不会出现index越界 Code 1234567891011121314151617def longestPalindrome(s): if len(s) &lt;= 2: return s maxlen = real_l = real_r = 0 for i in range(len(s) - 1): l, r, pos = i, i, i+1 while ( pos &lt;= len(s) - 1) and s[r] == s[pos]: r = pos pos += 1 while (l &gt;= 1 and r &lt; (len(s) - 1)) and s[l - 1] == s[r + 1]: l -= 1 r += 1 if r - l + 1 &gt; maxlen: maxlen = r - l + 1 real_l = l real_r = r return s[real_l:real_r+1] 7. Reverse IntegerQ:Given a 32-bit signed integer, reverse digits of an integer. Example: 123456Input: 123Output: 321Input: -123Output: -321Input: 120Output: 21 思路： ①flag表示符号判断正数1负数-1 ②将int转为字符串形式，[::-1]表示字符串反转 ③bit_length表示位数的判断 注意： 注意对大数的判断 Code 1234def reverse(x): flag = (x&gt;0)-(x&lt;0) val = flag*int(str(abs(x))[::-1]) return val*(val.bit_length()&lt;32) 8. String to Integer (atoi)Q:Implement atoi to convert a string to an integer. Example: 12 思路：此题太乱没做，总结答案 str.strip（）用于移除首位指定字符串 str.isdigit()判断字符是否是数值 ord()将字符转换为ASCII码 chr()将ASCII码转为字符如ord(‘a’) -&gt; 97 chr(97) -&gt; ‘a’4. 字符串跟数值问题注意overflow问题，这里是有符号函数所以max=231-1 min=-231 注意： 注意对大数的判断 Code 1234567891011121314151617def myAtoi(self, s): """ :type str: str :rtype: int """ ###better to do strip before sanity check (although 8ms slower): if len(s) == 0: return 0 ls = list(s.strip()) sign = -1 if ls[0] == '-' else 1 if ls[0] in ['-', '+']: del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit(): ret = ret * 10 + ord(ls[i]) - ord('0') i += 1 return max(-2 ** 31, min(sign * ret, 2 ** 31 - 1)) 9. Palindrome NumberQ:Determine whether an integer is a palindrome. Do this without extra space. Example: 12 思路： 1.负数不是回文数、非零且末位为零不是回文数 2.用数字一半部分来比较避免了翻转数字overflow问题（赞） 注意： 注意对大数的处理（用数字一半部分作比较） Code 123456789101112def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0 or (x % 10 == 0 and x != 0): return False res = 0 while x &gt; res: res = res * 10 + x % 10 x = x // 10 return (x == res or x == res // 10) 11.Container With Most WaterQ:Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Example: 12 思路：分析此题可以得到一个解题基础：最终得到的两块挡板左挡板L和右挡板R，L左边的所有挡板一定短于L，R右边的所有挡板一定短于R。据此，可以从轴两遍开始向内遍历，每次记录最值，并且下次从较短的挡板继续向内遍历。 注意： 注意对python 中用while True: if XX: break 来代替do while Code 1234567891011121314151617181920212223242526272829def maxArea( height): """ :type height: List[int] :rtype: int """ l = 0 r = len(height) - 1 l_h = height[l] r_h = height[r] val = maxval = min(l_h, r_h) * (r - l) while (l &lt; r): if l_h &lt;= r_h: while True: l += 1 if height[l] &gt; l_h or l &gt;= r: if r &gt; l: l_h = height[l] break elif l_h &gt; r_h: while True: r -= 1 if height[r] &gt; r_h or l &gt;= r: if r &gt; l: r_h = height[r] break val = min(l_h, r_h) * (r - l) if val &gt; maxval: maxval = val return maxval 14.Longest Common PrefixQ:Write a function to find the longest common prefix string amongst an array of strings. Example: 1找到字符串们的最长前缀 思路：关于zip()以及zip(* )的用法 前者相当于压缩到一个list中，后者相当于分开 12345678910111213141516a=[1,2,3]b=[4,5,6,7]c=[8,9,10,11,12]zz=zip(a,b,c)print(zz)x,y,z=zip(*zz)print(x)print(y)print(z)输出：[(1, 4, 8), (2, 5, 9), (3, 6, 10)](1, 2, 3)(4, 5, 6)(8, 9, 10) Code 1234567891011def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' for i, group in enumerate(zip(*strs)): if len(set(group)) != 1: return strs[0][:i] return min(strs) 15.3 SumQ:Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路：开头 排序 为了跳过重复元素（用dup记录上一元素）遍历一次用twosum函数返回（twosum函数也要去重） Code 12345678910111213141516171819202122232425class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums = sorted(nums) result = [] dup = -999 for i in range(len(nums)-1): if nums[i] != dup: result.extend(self.twosum(nums[i],nums[i+1:],nums[i]*-1)) dup = nums[i] return result def twosum(self,p,arr,val): box = set() threesum = [] for i in range(len(arr)): if (val-arr[i] in box): temp = sorted([p,arr[i],val-arr[i]]) if temp not in threesum: threesum.append(temp) else: box.add(arr[i]) return threesum 16.3 Sum ClosestQ:Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 思路：排序后根据大小查找 Code 12345678910111213141516171819202122def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() close = nums[0]+nums[1]+nums[2] for i in range(len(nums)-1): j = i+1 k = len(nums)-1 while j&lt;k: sum = nums[i]+nums[j]+nums[k] if sum == target: return sum if abs(target-sum) &lt; abs(target-close): close = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return close 17.Letter Combinations of a Phone NumbertQ:Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Example: 12Input:Digit string "23"Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 思路：递归思想 字符串拼接用 + Code 1234567891011121314def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ mapping = &#123;'0': ' ', '1': '', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl' , '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if len(digits) == 0: return [] if len(digits) == 1: return list(mapping[digits[0]]) pre_comb = self.letterCombinations(digits[:-1]) last = mapping[digits[-1]] return [s + v for s in pre_comb for v in last] 18.4 SumQ:Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路：列表之间的拼接用 ‘+’先两层嵌套for循环将所有两两组合之和求出来，再用twosum思想 去重 保证每个元素只添加一次(通过变量保存下标而不是值) Code 1234567891011121314151617181920212223def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ dic = &#123;&#125; result = [] for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): twosum = nums[i] + nums[j] if target - twosum in dic: for two in range(len(dic[target - twosum])): thisfour = sorted([nums[i], nums[j]] + [nums[dic[target - twosum][two][0]], nums[dic[target - twosum][two][1]]]) # and前条件用于去重；and后条件用于去除元素是否重复利用 if thisfour not in result and len(set([i, j]) | set(dic[target - twosum][two])) == 4: result.append(thisfour) if twosum not in dic: dic[twosum] = [[i, j]] else: dic[twosum].append([i, j]) return result 19.Remove Nth Node From End of ListQ:Given a linked list, remove the nth node from the end of list and return its head. Note:Given n will always be valid.Try to do this in one pass. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 思路：构造一个长度为n的滑窗，滑到最后注意判断如果删除了第一个元素（此时post.next = null）应返回head.next Code 123456789101112131415161718def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ pre = head post = head for i in range(n): post = post.next # 注意这一步，如果删除的是head，直接返回head.next if not post: return head.next while post.next: pre = pre.next post = post.next pre.next = pre.next.next return head 20. Valid ParenthesesQ:Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not.. Example: 12 思路：not valid 只有三种情况，找准这三种情况的特点注意一手对ord()的应用 Code 1234567891011121314151617181920def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] for i in range(len(s)): if s[i] in ['(','&#123;','[']: stack = stack + [s[i]] else: if len(stack)==0: # 右括号比左括号多的情况 return False if ord(s[i])-ord(stack[-1])!= 1 and ord(s[i])-ord(stack[-1])!= 2: #左右括号不对称的情况 return False else: stack = stack[:-1] if len(stack) == 0: return True else: # 左括号比右括号多的情况 return False 21. Merge Two Sorted ListsQ:Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路： 1.正常思路，用and终止while，l1 或 l2 的尾巴可以一并加上 2.递归思想找准结束条件，链表一个一个拼接 Code 123456789101112131415161718192021222324252627282930313233# 第一种做法def mergeTwoLists( l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ head = p = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 or l2 #加上小尾巴 return head.next# 递归做法def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 22.Generate ParenthesesQ:Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: Example: 1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路： 不带返回值的递归（用于添加或者修改），递归生成每个str Left right 分别为左右括号的计数器 Init_str为目前生成的字符串 Code 123456789101112131415161718192021class Solution22: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if not n: return [] left, right, init_str = n, n, '' result = [] self.generate(left,right,init_str,result) return result def generate(self,left,right,init_str,result): if not left and not right: result.append(init_str) return if left: self.generate(left-1,right,init_str+'(',result) #left &lt; right 为添加右括号条件 if right and left &lt; right: self.generate(left,right-1,init_str+')',result) 24.wap Nodes in PairsQ:Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Example: 12input:1-&gt;2-&gt;3-&gt;4output:2-&gt;1-&gt;4-&gt;3. 思路：基本操作，但是遇到return head报错，return init.next就正确，没找到原因 Code 123456789101112131415161718192021def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ init = ListNode(0) pre = init pre.next = head while pre.next and pre.next.next: p = pre.next post = p.next p.next = post.next post.next = p pre.next = post if not p.next: break else: pre = p p = p.next post = p.next return init.next 24.wap Nodes in PairsQ:Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Example: 12input:1-&gt;2-&gt;3-&gt;4output:2-&gt;1-&gt;4-&gt;3. 思路：基本操作，但是遇到return head报错，return init.next就正确，没找到原因 Code 123456789101112131415161718192021def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ init = ListNode(0) pre = init pre.next = head while pre.next and pre.next.next: p = pre.next post = p.next p.next = post.next post.next = p pre.next = post if not p.next: break else: pre = p p = p.next post = p.next return init.next 26.Remove Duplicates from Sorted ArrayQ:Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example: 1234Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn't matter what you leave beyond the new length. 思路：简单题，在数组内删除重复元素，两个指针write、read,修改时候 A[write + 1] = A[read] Code 12345678910111213141516171819202122class Solution26(object): def removeDuplicates(self, A): """ :type nums: List[int] :rtype: int """ if not A: return 0 if len(A) == 1: return 1 write = 0 read = 1 while read &lt; len(A): if A[write] != A[read]: # 修改重复元素的方法 A[write + 1] = A[read] write += 1 read += 1 else: read += 1 A = A[:write + 1] return len(A) 27.Remove ElementQ:Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: 123Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2. 思路：简单的双指针 Code 1234567891011121314151617class Solution27: def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if not nums: return 0 read = write =0 while read &lt; len(nums): if nums[read] != val: nums[write] = nums[read] write += 1 read += 1 nums = nums[:write] return len(nums) 29.Divide Two IntegersQ:Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. Example: 12 思路：不会位运算，看了discussion此题两个while循环，第一个为结束条件，第二个循环每次减去除数的1、2、4、8……倍，结束第二个循环继续从一倍开始。减完回到第一个循环的判定条件判断是否需要再进行第二个while，相当于指数高效的记录倍数 Code 1234567891011121314151617181920class Solution29: def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i temp &lt;&lt;= 1 i &lt;&lt;= 1 if not positive: res = -res return min(max(-2 ** 31,res), 2**31-1) 31.Next PermutationQ:Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 从这几个数组合中找到下一个比他大的数 Example: 1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路：较简单，尽可能更改最后几位，并且从后往前如果一直是递增则就是这几个数的最大排列如4321，从后找到第一个非递增的数字p（如1245763中的5），然后将此数字与之后数字中 大于它且最接近于它 的数字（6）交换，交换后将该位置之后的数字升序排列（1246357）该题要求在原数组中修改，因此我把之后按升序拍了的数组建立一个临时数组temp_list，用for循环写入原数组 list.sort() 和 sorted(list)的区别 12345678a = [3,2,1]list.sort()就地修改无返回值 sorted(list)返回新列表，对所有可迭代对象均有效print(a.sort()) -&gt; Noneprint(sorted(a)) -&gt; [1,2,3]a.sort() print(a) -&gt; [1,2,3]#对于切片列表：a[1:].sort() print(a) -&gt;[3,2,1] 无效print(sorted(a[1:])) -&gt;[1,2] 注意： ①找与p交换的数字时从后往前找可以避免index越界问题 ②考虑有重复数字问题 ③while遍历时候考虑左右边界问题（如while p and 条件 -&gt;此为不超过左边界） Code 12345678910111213141516171819202122232425262728class Solution31: def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if not nums: return None p = len(nums) - 1 # while p用以阻止左边界越界 while p and nums[p-1] &gt;= nums[p]: p -= 1 if p == 0: nums.sort() return None else: p = p - 1 post = len(nums) - 1 # while post用以阻止左边界越界，同时从后往前找防止右边界越界 while post and nums[post]&lt;=nums[p]: post -= 1 temp = nums[p] nums[p] = nums[post] nums[post] = temp temp_list = sorted(nums[p+1:]) for i in range(p+1,len(nums)): nums[i] = temp_list[i-p-1] return None 33.Search in Rotated Sorted ArrayQ:Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Example: 12 思路：在排序或类排序数组中查找首先想到二分法此题因为不需要考虑重复元素，较为简单，列出所有情况来即可，我的代码比较繁琐，边界值判定条件应该可以统一一下，懒得改了因为最后的6种判定条件互斥，所以用 抑或^ 或者 or 都行分情况讨论如图（类似高中数学题） Code 12345678910111213141516171819202122232425class Solution33: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 1 and nums[0] == target: return 0 left = 0 right = len(nums)-1 while left &lt; right: mid = (left +right) // 2 if nums[left] == target: return left if nums[right] == target: return right if nums[mid] == target: return mid if (nums[mid]&gt;target and target &gt; nums[right])^(nums[right]&gt;nums[mid] and nums[mid]&gt;target )^(target&gt;nums[right] and nums[right]&gt;nums[mid]): right = mid - 1 else: left = mid + 1 return -1 34.Search for a RangeQ:Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example: 12Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 思路：很简单，因为是排序数组，所以先用二分法查找target,在从这个位置往两边扩展 注意： ①类似while pre&gt;0 and nums[pre] == target: 中判断while结束后的pre是否指向target(有可能因为边界条件跳出循环，并且边界仍满足target)来判断pre是否 -1 ②第一个while l&lt;=r: 中‘=’存在不构成死循环的原因如果l=r且指向target接下来会return，如果l=r不指向target之后对于mid与target判定仍会跳出循环 Code 12345678910111213141516171819202122232425262728293031class Solution34: def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if not nums or (len(nums)==1 and nums[0] != target): return [-1,-1] l = 0 r = len(nums) - 1 if l == r and nums[0]==target: return [0,0] while l &lt;= r: mid = (l+r) // 2 if nums[mid] == target: pre = post = mid while pre&gt;0 and nums[pre] == target: pre -= 1 while post&lt;len(nums)-1 and nums[post] == target: post += 1 if nums[pre] != target: pre += 1 if nums[post] != target: post -= 1 return [pre, post] elif nums[mid] &gt; target: r = mid - 1 else: l = mid + 1 return [-1, -1] 35.Search Insert PositionQ:Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example: 12345678Input: [1,3,5,6], 5Output: 2Input: [1,3,5,6], 2Output: 1Input: [1,3,5,6], 7Output: 4Input: [1,3,5,6], 0Output: 0 思路：没什么好说的，排序数列二分查找，注意边界值问题及while中的等号问题while 中 加’=’保证在无target的情况，mid在连续两位中的右边一位 注意：target&gt;max情况 Code 12345678910111213141516171819202122232425class Solution35: def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if not nums or (len(nums)==1 and nums[0]&gt;=target): return 0 if len(nums)==1 and nums[0]&lt;target: return 1 l = 0 r = len(nums)-1 while l &lt;= r: # 加‘=’保证在无target的情况，mid在连续两位中的右边一位 mid = (l + r) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: l = mid + 1 else: r = mid - 1 if nums[mid]&gt;target: return mid else: # target&gt;max情况 return mid+1 **]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>代码</tag>
      </tags>
  </entry>
</search>
