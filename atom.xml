<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Malped]]></title>
  <subtitle><![CDATA[Make a little progress every day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T13:28:37.200Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Malped]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何在高维球体表面相对均匀分布n个点]]></title>
    <link href="http://yoursite.com/2018/05/15/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%AB%98%E7%BB%B4%E7%90%83%E4%BD%93%E8%A1%A8%E9%9D%A2%E7%9B%B8%E5%AF%B9%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83n%E4%B8%AA%E7%82%B9/"/>
    <id>http://yoursite.com/2018/05/15/如何在高维球体表面相对均匀分布n个点/</id>
    <published>2018-05-15T08:23:50.000Z</published>
    <updated>2018-05-16T13:28:37.200Z</updated>
    <content type="html"><![CDATA[<p>如何在一个高维球面尽可能均匀的分布$n$个点？</p>
<p>几天前导师让我思考这么一个问题，我的第一感觉是，寻找球内接正多面体，但是自己没找到数值化的推导，也没找到推广到高维方法；接着我又想：有没有类似’熵’的指标，类比最大熵用来衡量空间中向量分布的均匀程度？很遗憾这个也没找到 : (</p>
<p>恰好我知乎关注大牛<a href="https://www.zhihu.com/people/maigo/activities" target="_blank" rel="noopener">王赟</a>也思考过这个问题，并且找到了二维圆面、三维球面的解决方案、以及原理解释。这里我参考他文章中对二维圆面、三维球面解决方案，尝试给出高维球面的解决方案。</p>
<p>如何量化这个问题？可以想到的一种思路是：令点之间最短距离最大化（类似于支持向量机）。这样定义出来的问题叫做<a href="https://en.wikipedia.org/wiki/Tammes_problem" target="_blank" rel="noopener">$Tammes problem$</a>, 是密铺问题的一个特例。不幸的是，密铺问题往往没有很优雅的解。另一种定义方法是：把各个点看成同种电荷，让整个系统的电势能最小。这个问题可以通过模拟电荷的运动来解决，但计算复杂度非常高，而且只能得到数值解。</p>
<p>王赟在$StackOverflow$上面找到了一种可靠地近似解法:<a href="https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/26127012#26127012" target="_blank" rel="noopener">$Evenly distributing n points on a sphere$</a>, 这种生成的点阵被称为<strong>斐波那契网格</strong>（$Fibonacci lattice $或 $Fibonacci grid$）。至于为什么叫菲波那契网格，目前可以简单地用「黄金分割比也出现在菲波那契数列中」来解释，在下文中你还会见到菲波那契数的出现。这篇文章（<a href="https://link.zhihu.com/?target=http%3A//citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.742.7550%26rep%3Drep1%26type%3Dpdf" target="_blank" rel="noopener">$Measurement of areas on a sphere using Fibonacci and latitude–longitude lattices$</a>）说明，使用菲波那契网格测量球面上不规则图形的面积，与用经纬网格（并加权）相比，误差可以减小 40%。</p>
<p>方法中运用<em>黄金分割比</em>的原理分析过程主要依赖连分式（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Continued_fraction" target="_blank" rel="noopener">$Continued fraction$</a>）,主要依赖于不同连分式的观察分析，这里具体可以看<a href="https://zhuanlan.zhihu.com/p/25998937" target="_blank" rel="noopener">王赟文章</a></p>
<h2 id="二维圆面"><a href="#二维圆面" class="headerlink" title="二维圆面"></a>二维圆面</h2><p>二维圆面中给出的公式如下（其中$\phi$为黄金分割比$\sqrt5 + 1\over 2$）:</p>
<script type="math/tex; mode=display">x_n=\sqrt n \cos(2\pi n \phi)</script><script type="math/tex; mode=display">y_n=\sqrt n \sin(2\pi n \phi)</script><p>先来看看效果：</p>
<p><img src="/2018/05/15/如何在高维球体表面相对均匀分布n个点/二维圆面.jpg" alt=""></p>
<p>让我们来分析一下生成公式：</p>
<p>这两个公式从几何角度很好理解：对于第$n$个点，该点到原点的距离$\sqrt n$，然后该点所在角度为在上一个点（第$n-1$个点）的基础上旋转$2\pi\phi$，如此简单便完成近似均匀分布。</p>
<p>为什么这种思路会$work$呢？可以这样来看，对于第$k$个点，离原点距离为$\sqrt k$，它位于圆周上，则这个圆面积为$\pi k$，同理对于第$k-1$个点，园面积为$\pi (k-1)$，故第$k$个点所在圆环面积为$\pi$。由此可以看出，每一个点所占圆环面积均为$\pi$，这种情况保证了宏观上的均匀性：每$\pi$面积上就有一个点。但是这样还不够，不能保证环与环之间的点混乱均匀，对此就要用到黄金分割比保证不同环之间点选择的混乱均匀性，这里的原理具体可以看<a href="https://zhuanlan.zhihu.com/p/25998937" target="_blank" rel="noopener">王赟文章</a>。</p>
<p>这里附上我的$python$实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_2D</span><span class="params">(samples, radius)</span>:</span></span><br><span class="line">    n, r = samples, radius</span><br><span class="line">    indices = arange(<span class="number">0</span>, samples, dtype=float) + <span class="number">0.5</span></span><br><span class="line">    r_pts = sqrt(indices * r / n)</span><br><span class="line">    theta = pi *(<span class="number">5</span>**<span class="number">0.5</span> - <span class="number">1</span>) * indices  <span class="comment"># theta为2pi_n_phi</span></span><br><span class="line">    x, y = r_pts*cos(theta), r_pts*sin(theta)</span><br><span class="line">    <span class="keyword">return</span>  [x, y]</span><br></pre></td></tr></table></figure>
<h2 id="三维球面"><a href="#三维球面" class="headerlink" title="三维球面"></a>三维球面</h2><p>三维球面中点生成公式：</p>
<script type="math/tex; mode=display">z_n = (2n-1)/N -1</script><script type="math/tex; mode=display">x_n=\sqrt{1-z_n^2}\cos(2\pi n \phi)</script><script type="math/tex; mode=display">y_n=\sqrt{1-z_n^2}\sin(2\pi n \phi)</script><p>先来看看效果：</p>
<p><img src="/2018/05/15/如何在高维球体表面相对均匀分布n个点/三维球面.jpg" alt=""></p>
<p>这三条公式对$\phi$值非常敏感。哪怕$\phi$稍微偏离黄金分割一点点，做出图的效果就不好。</p>
<p><img src="/2018/05/15/如何在高维球体表面相对均匀分布n个点/偏离.jpg" alt=""></p>
<p>下面解释一下这三条公式：</p>
<ol>
<li>$z_n = (2n-1)/N -1$(这里将球心归到原点)，说明各个点<em>竖坐标成等差序列</em>，相当于把球面切成相同厚度的$N$层，并且在<strong>每一层厚度中点处的表面上取一个点</strong>。由于球冠表面积公式$S = 2 \pi Rh$，所以这样子切出来的各层有一个性质：侧面积都相等。这个性质保证了点阵在宏观上的均匀性：每$4\pi/N$面积上就有一个点。</li>
<li>第二、三条公式用到黄金分割比保证不同环之间点选择的混乱均匀性，这里的原理具体可以看<a href="https://zhuanlan.zhihu.com/p/25998937" target="_blank" rel="noopener">王赟文章</a>。</li>
</ol>
<p>下面附上我实现三维球面密铺的$python$代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_3D</span><span class="params">(samples, radius, orign = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span>:</span></span><br><span class="line">    n, r = samples, radius</span><br><span class="line">    <span class="comment"># + 0.5 表示在厚度的中点处取点</span></span><br><span class="line">    indices = arange(<span class="number">0</span>, samples, dtype=float) + <span class="number">0.5</span></span><br><span class="line">    theta = pi *(<span class="number">5</span>**<span class="number">0.5</span> - <span class="number">1</span>) * indices</span><br><span class="line">    z = <span class="number">2</span> * indices * r / n - r</span><br><span class="line">    x, y = sqrt(r ** <span class="number">2</span> - (z ** <span class="number">2</span>))*cos(theta), sqrt(r ** <span class="number">2</span> - (z ** <span class="number">2</span>))*sin(theta)</span><br><span class="line">    x, y, z = x+orign[<span class="number">0</span>], y+orign[<span class="number">1</span>], z +orign[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> [x, y, z]</span><br></pre></td></tr></table></figure>
<h2 id="高维球面"><a href="#高维球面" class="headerlink" title="高维球面"></a>高维球面</h2><p>高维球面这部分是自己联想推导，不敢保证正确性。</p>
<p>$m$x$n$维矩阵来代表最终的$n$个点（行代表维度、列代表样本是生成函数生成矩阵方便的原因）</p>
<p><img src="/2018/05/15/如何在高维球体表面相对均匀分布n个点/高维.jpg" alt=""></p>
<p>看二维圆面、三维球面可以看出，斐波那契网格主要思想就是通过<strong>等分某一维坐标将超球体等分为体积相等n个环，在环厚度中心位置取点，每次取点旋转角度通过黄金分割比来确定</strong>。比如说对于三维球体，选中第三维厚度中点后，剩下的只是一个二维圆周，只需要确定角度就可以了。那么对于四维呢，确定一维坐标后，剩下的三维组成球体，那么如何确定剩下的点？<strong>我的想法是对于高维球体某一维坐标确定后得到子超球体，继续用高维球体密铺的方法处理子超球体，只不过只取相对位的那一个点（比如当前要铺第五个点，那么在子超球体中，只取第五个点）</strong>。具体方法是假设需要密铺$m$维球体，前$m-2$维都用<strong>等分维度的方法确定坐标</strong>，但是要注意<strong>当前维度的超球体半径需要通过总半径减去前几维同一列(同一列即同一个样本)的平方和然后开根号</strong>（$for$循环中的$temp_r$，比如$x^2+y^2+z^2+w^2=$，3确定$z=1,w=1$之后，$x、y$相应变为$x^2+y^2=1$）。<strong>对于矩阵的列代表不同的$n$个样本，每一列（每个样本）均对应不同的相对位置（用$pts_ratio$表示该列（样本）的分位数）。</strong>对于最后两维，用三维的方法确定即可，不过这里半径依然满足上述规则。</p>
<p>下面附上我实现高维球面密铺的$python$代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci_ND</span><span class="params">(dimension, samples, radius )</span>:</span></span><br><span class="line">    r = radius</span><br><span class="line">    res = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(dimension)]</span><br><span class="line">    <span class="comment"># + 0.5 表示在厚度的中点处取点 pts_ratio记录不同点的相对位置。</span></span><br><span class="line">    pts_ratio = (arange(<span class="number">0</span>, samples, dtype=float) + <span class="number">0.5</span>) / samples</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">2</span> * pts_ratio * r -r</span><br><span class="line">    <span class="comment"># temp_dim 用于记录当前维度确定的坐标的平方和</span></span><br><span class="line">    temp_dim = (<span class="number">2</span> * pts_ratio * r -r) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, dimension<span class="number">-2</span>):</span><br><span class="line">        <span class="comment"># temp_r为确定前几维后剩下的超球体半径</span></span><br><span class="line">        temp_r = sqrt(r ** <span class="number">2</span> - temp_dim)</span><br><span class="line">        new = <span class="number">2</span> * temp_r * pts_ratio - temp_r</span><br><span class="line">        res[i] = new</span><br><span class="line">        temp_dim += new ** <span class="number">2</span></span><br><span class="line">    temp_r = sqrt(r ** <span class="number">2</span> - temp_dim)</span><br><span class="line">    <span class="comment"># theta 为 2_pi_n_phi</span></span><br><span class="line">    theta = pi * ( <span class="number">5</span> ** <span class="number">0.5</span> - <span class="number">1</span>) * (arange(<span class="number">0</span>, samples, dtype=float) + <span class="number">0.5</span>)</span><br><span class="line">    temp_x, temp_y = temp_r * cos(theta), temp_r * sin(theta)</span><br><span class="line">    res[dimension - <span class="number">2</span>], res[dimension - <span class="number">1</span>] = temp_x, temp_y</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>因为高维球面的密铺没法通过作图来目测验证，这里我用到自己写的函数（不知科学与否）来大概推测。</p>
<p>具体方案如下：因为大家的半径相等，所以点乘可以衡量两个点之间的角度差异，具体为差越小两个点越靠近。在这里我每次选取随机点，计算出这个随机点到其他点点乘值的排序$list$，选择最大点和第五大点添加到输出队列，最后$print$输出队列的最大值和最小值（两个最值可能来自不同随机点）看差别，如果差别很小暂可认为，算法较为均匀。</p>
<p>下面为我的$python$代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 嵌套list转置函数 ##</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mat_trans</span><span class="params">(list)</span>:</span></span><br><span class="line">    list2 = []</span><br><span class="line">    row, col = len(list), len(list[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(col):</span><br><span class="line">        list2.append([y[i] <span class="keyword">for</span> y <span class="keyword">in</span> list])</span><br><span class="line">    <span class="keyword">return</span> list2</span><br><span class="line"><span class="comment">## 验证函数 ##</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle_count</span><span class="params">(hh, n_rand, samples)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    mat = mat_trans(hh)</span><br><span class="line">    <span class="comment"># n_rand为随机数的个数,随机选择一个点，然后将这个点与其他点的点乘输出为</span></span><br><span class="line">    <span class="comment"># 排序序列temp_list。因为半径都相等，点乘可以估量角度差值（越大差值越小）。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_rand):</span><br><span class="line">        temp_list = []</span><br><span class="line">        rand = random.randint(<span class="number">0</span>, samples<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(samples):</span><br><span class="line">            <span class="keyword">if</span> j != rand:</span><br><span class="line">                temp_dot = [mat[rand][i] * mat[j][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat[<span class="number">0</span>]))]</span><br><span class="line">                temp_list.append(sum(temp_dot))</span><br><span class="line">        temp_list.sort()</span><br><span class="line">        <span class="comment"># 将每个随机点第一大跟第五大点乘值加入</span></span><br><span class="line">        res.append(temp_list[<span class="number">-1</span>])</span><br><span class="line">        res.append(temp_list[<span class="number">-5</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">samp = Fibonacci_ND(<span class="number">4</span>, <span class="number">1000</span>, <span class="number">10</span>)</span><br><span class="line">kankan = angle_count(samp, <span class="number">500</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 输出最大和最小（可能来源不同点随机）</span></span><br><span class="line">print(min(kankan), max(kankan))</span><br></pre></td></tr></table></figure>
<p>简单试验，对于三维球面，样本量为1000，$min$和$max$误差在$0.7\%$；对于四维球面，样本量为1000，$min$和$max$误差在$1.4\%$。这里认为分布较为均匀。</p>
]]></content>
    <summary type="html">
    <![CDATA[从二维圆面、三维球面到高维球面的密铺]]>
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="斐波那契网格" scheme="http://yoursite.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%BD%91%E6%A0%BC/"/>
    
      <category term="密铺" scheme="http://yoursite.com/tags/%E5%AF%86%E9%93%BA/"/>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]梯度下降优化算法综述]]></title>
    <link href="http://yoursite.com/2018/03/23/%E8%BD%AC-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/03/23/转-梯度下降优化算法综述/</id>
    <published>2018-03-23T08:28:34.000Z</published>
    <updated>2018-03-24T03:10:46.995Z</updated>
    <content type="html"><![CDATA[<p><strong><em>本文转载自：</em></strong><a href="https://blog.csdn.net/google19890102/article/details/69942970" target="_blank" rel="noopener">https://blog.csdn.net/google19890102/article/details/69942970</a></p>
<hr>
<blockquote>
<p>本文翻译自Sebastian Ruder的“An overview of gradient descent optimization algoritms”，作者首先在其博客中发表了这篇文章，其博客地址为：<a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algoritms</a>，之后，作者将其整理完放在了arxiv中，其地址为：<a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="noopener">An overview of gradient descent optimization algoritms</a>，在翻译的过程中以作者发布在Arxiv的论文为主，参考其在博客中的内容。</p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>虽然梯度下降优化算法越来越受欢迎，但通常作为黑盒优化器使用，因此很难对其优点和缺点的进行实际的解释。本文旨在让读者对不同的算法有直观的认识，以帮助读者使用这些算法。在本综述中，我们介绍梯度下降的不同变形形式，总结这些算法面临的挑战，介绍最常用的优化算法，回顾并行和分布式架构，以及调研用于优化梯度下降的其他的策略。</p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>梯度下降法是最著名的优化算法之一，也是迄今优化神经网络时最常用的方法。同时，在每一个最新的深度学习库中都包含了各种优化的梯度下降法的实现（例如：参见<a href="http://lasagne.readthedocs.org/en/latest/modules/updates.html" target="_blank" rel="noopener">lasagne</a>，<a href="http://caffe.berkeleyvision.org/tutorial/solver.html" target="_blank" rel="noopener">caffe</a>和<a href="http://keras.io/optimizers/" target="_blank" rel="noopener">keras</a>的文档）。然而，这些算法通常是作为黑盒优化器使用，因此，很难对其优点和缺点的进行实际的解释。</p>
<p>本文旨在让读者对不同的优化梯度下降的算法有直观的认识，以帮助读者使用这些算法。在第2部分，我们首先介绍梯度下降的不同变形形式。在第3部分，我们将简要总结在训练的过程中所面临的挑战。随后，在第4部分，我们将介绍最常用的优化算法，包括这些算法在解决以上挑战时的动机以及如何得到更新规则的推导形式。在第5部分，我们将简单讨论在并行和分布式环境中优化梯度下降的算法和框架。最后，在第6部分，我们将思考对优化梯度下降有用的一些其他策略。</p>
<p>梯度下降法是最小化目标函数$J(θ)$的一种方法，其中，$θ∈ℝ^d$为模型参数，梯度下降法利用目标函数关于参数的梯度$∇_θJ(θ)$的反方向更新参数。学习率$η$决定达到最小值或者局部最小值过程中所采用的步长的大小。即，我们沿着目标函数的斜面下降的方向，直到到达谷底。如果你对梯度下降法不熟悉，你可以从<a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="noopener">http://cs231n.github.io/optimization-1/</a>找到介绍神经网络优化的材料。</p>
<h1 id="2-梯度下降法的变形形式"><a href="#2-梯度下降法的变形形式" class="headerlink" title="2 梯度下降法的变形形式"></a>2 梯度下降法的变形形式</h1><p>梯度下降法有$3$种变形形式，它们之间的区别为我们在计算目标函数的梯度时使用到多少数据。根据数据量的不同，我们在参数更新的精度和更新过程中所需要的时间两个方面做出权衡。</p>
<h2 id="2-1-批梯度下降法"><a href="#2-1-批梯度下降法" class="headerlink" title="2.1 批梯度下降法"></a>2.1 批梯度下降法</h2><p>$Vanilla$梯度下降法，又称为批梯度下降法$（batch gradient descent）$，在整个训练数据集上计算损失函数关于参数θ的梯度：</p>
<script type="math/tex; mode=display">θ=θ−η⋅∇_θJ(θ)</script><p>因为在执行每次更新时，<strong>我们需要在整个数据集上计算所有的梯度，所以批梯度下降法的速度会很慢，同时，批梯度下降法无法处理超出内存容量限制的数据集。批梯度下降法同样也不能在线更新模型，即在运行的过程中，不能增加新的样本。</strong></p>
<p>批梯度下降法的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    params_grad = evaluate_gradient(loss_function, data, params)</span><br><span class="line">    params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure>
<p>对于给定的迭代次数，首先，我们利用全部数据集计算损失函数关于参数向量<code>params</code>的梯度向量<code>params_grad</code>。注意，最新的深度学习库中提供了自动求导的功能，可以有效地计算关于参数梯度。如果你自己求梯度，那么，梯度检查是一个不错的主意（关于如何正确检查梯度的一些技巧可以参见<a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">http://cs231n.github.io/neural-networks-3/</a>）。</p>
<p>然后，我们利用梯度的方向和学习率更新参数，学习率决定我们将以多大的步长更新参数。对于凸误差函数，批梯度下降法能够保证收敛到全局最小值，对于非凸函数，则收敛到一个局部最小值。</p>
<h2 id="2-2-随机梯度下降法"><a href="#2-2-随机梯度下降法" class="headerlink" title="2.2 随机梯度下降法"></a>2.2 随机梯度下降法</h2><p>相反，随机梯度下降法$（stochastic gradient descent, SGD）$根据每一条训练样本$x^{(i)}$和标签$y^{(i)}$更新参数：</p>
<script type="math/tex; mode=display">θ=θ−η⋅∇_θJ(θ;x^{(i)};y^{(i)})</script><p><strong>对于大数据集，因为批梯度下降法在每一个参数更新之前，会对相似的样本计算梯度，所以在计算过程中会有冗余。而$SGD$在每一次更新中只执行一次，从而消除了冗余。因而，通常$SGD$的运行速度更快，同时，可以用于在线学习。$SGD$以高方差频繁地更新，导致目标函数出现如图$1$所示的剧烈波动。</strong></p>
<p><img src="/2018/03/23/转-梯度下降优化算法综述/SGD波动.png" alt=""></p>
<p>与批梯度下降法的收敛会使得损失函数陷入局部最小相比，由于$SGD$的波动性，<strong>一方面，波动性使得$SGD$可以跳到新的和潜在更好的局部最优。另一方面，这使得最终收敛到特定最小值的过程变得复杂，因为SGD会一直持续波动。</strong>然而，<strong>已经证明当我们缓慢减小学习率，SGD与批梯度下降法具有相同的收敛行为，对于非凸优化和凸优化，可以分别收敛到局部最小值和全局最小值。</strong>与批梯度下降的代码相比，SGD的代码片段仅仅是在对训练样本的遍历和利用每一条样本计算梯度的过程中增加一层循环。注意，如$6.1$节中的解释，在每一次循环中，我们打乱训练样本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">        params_grad = evaluate_gradient(loss_function, example, params)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure>
<h2 id="2-3-小批量梯度下降法"><a href="#2-3-小批量梯度下降法" class="headerlink" title="2.3 小批量梯度下降法"></a>2.3 小批量梯度下降法</h2><p>小批量梯度下降法最终结合了上述两种方法的优点，在每次更新时使用$n$个小批量训练样本：</p>
<script type="math/tex; mode=display">θ=θ−η⋅∇_θJ(θ;x^{(i:i+n)};y^{(i:i+n)})</script><p>这种方法:</p>
<ul>
<li>减少参数更新的方差，这样可以得到更加稳定的收敛结果；</li>
<li>可以利用最新的深度学习库中高度优化的矩阵优化方法，高效地求解每个小批量数据的梯度。通常，小批量数据的大小在50到256之间，也可以根据不同的应用有所变化。当训练神经网络模型时，小批量梯度下降法是典型的选择算法，当使用小批量梯度下降法时，也将其称为$SGD$。注意：在下文的改进的$SGD$中，为了简单，我们省略了参数$x^{(i:i+n)};y^{(i:i+n)}$。</li>
</ul>
<p>在代码中，不是在所有样本上做迭代，我们现在只是在大小为50的小批量数据上做迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=<span class="number">50</span>):</span><br><span class="line">        params_grad = evaluate_gradient(loss_function, batch, params)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure>
<h1 id="3-挑战"><a href="#3-挑战" class="headerlink" title="3 挑战"></a>3 挑战</h1><p>虽然$Vanilla$小批量梯度下降法并不能保证较好的收敛性，但是需要强调的是，这也给我们留下了如下的一些挑战：</p>
<ul>
<li>选择一个合适的学习率可能是困难的。学习率太小会导致收敛的速度很慢，学习率太大会妨碍收敛，导致损失函数在最小值附近波动甚至偏离最小值。</li>
<li>学习率调整$[17]$试图在训练的过程中通过例如退火的方法调整学习率，即根据预定义的策略或者当相邻两代之间的下降值小于某个阈值时减小学习率。然而，策略和阈值需要预先设定好，因此无法适应数据集的特点$[4]$。</li>
<li>此外，对所有的参数更新使用同样的学习率。如果数据是稀疏的，同时，特征的频率差异很大时，我们也许不想以同样的学习率更新所有的参数，对于出现次数较少的特征，我们对其执行更大的学习率。</li>
<li>高度非凸误差函数普遍出现在神经网络中，在优化这类函数时，另一个关键的挑战是使函数避免陷入无数次优的局部最小值。$Dauphin$等人$[5]$指出出现这种困难实际上并不是来自局部最小值，而是来自鞍点，即那些在一个维度上是递增的，而在另一个维度上是递减的。这些鞍点通常被具有相同误差的点包围，因为在任意维度上的梯度都近似为0，所以$SGD$很难从这些鞍点中逃开。</li>
</ul>
<h1 id="4-梯度下降优化算法"><a href="#4-梯度下降优化算法" class="headerlink" title="4 梯度下降优化算法"></a>4 梯度下降优化算法</h1><p>下面，我们将列举一些算法，这些算法被深度学习社区广泛用来处理前面提到的挑战。我们不会讨论在实际中不适合在高维数据集中计算的算法，例如诸如<a href="https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization" target="_blank" rel="noopener">牛顿法</a>的二阶方法。</p>
<h2 id="4-1-动量法"><a href="#4-1-动量法" class="headerlink" title="4.1 动量法"></a>4.1 动量法</h2><p>$SGD$很难通过陡谷，即在一个维度上的表面弯曲程度远大于其他维度的区域[19]，这种情况通常出现在局部最优点附近。在这种情况下，$SGD$摇摆地通过陡谷的斜坡，同时，沿着底部到局部最优点的路径上只是缓慢地前进，这个过程如图$2a$所示。</p>
<p><img src="/2018/03/23/转-梯度下降优化算法综述/动量.bmp" alt=""></p>
<p>$图2$</p>
<p>如图$2b$所示，动量法$[16]$是一种<strong>帮助$SGD$在相关方向上加速并抑制摇摆的一种方法。动量法将历史步长的更新向量的一个分量γ增加到当前的更新向量中（部分实现中交换了公式中的符号）</strong></p>
<script type="math/tex; mode=display">vt=γv_{t−1}+η∇_θJ(θ)</script><p>$θ=θ−v_t$</p>
<p>从本质上说，<strong>动量法，就像我们从山上推下一个球，球在滚下来的过程中累积动量，变得越来越快，（类似惯性？）（直到达到终极速度，如果有空气阻力的存在，则γ&lt;1）</strong>。同样的事情也发生在参数的更新过程中：对于在梯度点处具有相同的方向的维度，其动量项增大，对于在梯度点处改变方向的维度，其动量项减小。因此，我们可以得到更快的收敛速度，同时可以减少摇摆。</p>
<h2 id="4-2-Nesterov-加速梯度下降法"><a href="#4-2-Nesterov-加速梯度下降法" class="headerlink" title="4.2 $Nesterov$加速梯度下降法"></a>4.2 $Nesterov$加速梯度下降法</h2><p>然而，球从山上滚下的时候，盲目地沿着斜率方向，往往并不能令人满意。<strong>我们希望有一个智能的球，这个球能够知道它将要去哪，以至于在重新遇到斜率上升时能够知道减速。</strong></p>
<p>$Nesterov$加速梯度下降法（$Nesterov accelerated gradient，NAG$）$[13]$是一种能够给动量项这样的预知能力的方法。我们知道，我们利用动量项$γv_{t−1}$来更新参数θ。通过计算$θ−γv_{t−1}$能够告诉我们参数未来位置的一个近似值（梯度并不是完全更新），这也就是告诉我们参数大致将变为多少。通过计算关于参数未来的近似位置的梯度，而不是关于当前的参数θ的梯度，我们可以高效的求解 ：</p>
<script type="math/tex; mode=display">vt=γv_{t−1}+η∇_θJ(θ−γv_{t−1})</script><script type="math/tex; mode=display">θ=θ−v_t</script><p>自己的理解：在动量的基础上求梯度求得是<strong>双倍移动后的梯度（其实并没有双倍移动，只是不是用当前点的梯度了，用的是上次移动后更前面的点，这样梯度可能更陡，这次下降将更快）</strong></p>
<p>同时，我们设置动量项γγ大约为0.9。动量法首先计算当前的梯度值（图3中的小的蓝色向量），然后在更新的累积梯度（大的蓝色向量）方向上前进一大步，Nesterov加速梯度下降法NAG首先在先前累积梯度（棕色的向量）方向上前进一大步，计算梯度值，然后做一个修正（绿色的向量）。这个具有预见性的更新防止我们前进得太快，同时增强了算法的响应能力，这一点在很多的任务中对于RNN的性能提升有着重要的意义[2]。</p>
<p><img src="/2018/03/23/转-梯度下降优化算法综述/nesterov.png" alt=""></p>
<p>对于NAG的直观理解的另一种解释可以参见<a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">http://cs231n.github.io/neural-networks-3/</a>，同时Ilya Sutskever在其博士论文[18]中给出更详细的综述。</p>
<p>既然我们能够使得我们的更新适应误差函数的斜率以相应地加速SGD，我们同样也想要使得我们的更新能够适应每一个单独参数，以根据每个参数的重要性决定大的或者小的更新。</p>
<h2 id="4-3-Adagrad"><a href="#4-3-Adagrad" class="headerlink" title="4.3 $Adagrad$"></a>4.3 $Adagrad$</h2><p>$Adagrad[7]$是这样的一种基于梯度的优化算法：<strong>让学习率适应参数，对于出现次数较少的特征，我们对其采用更大的学习率，对于出现次数较多的特征，我们对其采用较小的学习率</strong>。因此，Adagrad非常<strong>适合处理稀疏数据</strong>。Dean等人[6]发现Adagrad能够极大提高了SGD的鲁棒性并将其应用于Google的大规模神经网络的训练，其中包含了<a href="http://www.wired.com/2012/06/google-x-neural-network/" target="_blank" rel="noopener">YouTube视频</a>中的猫的识别。此外，Pennington等人[15]利用Adagrad训练Glove词向量，因为低频词比高频词需要更大的步长。</p>
<p>前面，我们每次更新所有的参数θ时，每一个参数$θ_i$都使用的是相同的学习率η。由于<strong>$Adagrad$在$t$时刻对每一个参数$θ_i$使用了不同的学习率</strong>，我们首先介绍$Adagrad$对每一个参数的更新，然后我们对其向量化。为了简洁，令$g_{t,i}$为在$t$时刻目标函数关于参数$θ_i$的梯度：</p>
<script type="math/tex; mode=display">g_{t,i}=∇_θJ(θ_i)</script><p>在$t$时刻，对每个参数$θ_i$的更新过程变为：</p>
<script type="math/tex; mode=display">θ_{t+1,i}=θ_{t,i}−η⋅g_{t,i}</script><p>对于上述的更新规则，在$t$时刻，基于对$θ_i$计算过的历史梯度，$Adagrad$修正了对每一个参数$θ_i$的学习率：</p>
<script type="math/tex; mode=display">θ_{t+1,i}=θ_{t,i}−{\eta\over\sqrt{G_{t,ii}+\epsilon}}⋅g_{t,i}</script><p>其中，$G_t∈ℝ^{d×d}$是一个对角矩阵，对角线上的元素$[i,i]$是直到$t$时刻为止，所有关于$θ_i$的梯度的平方和（$Duchi$等人$[7]$将该矩阵作为包含所有先前梯度的外积的完整矩阵的替代，因为即使是对于中等数量的参数$d$，矩阵的均方根的计算都是不切实际的。）,ϵ是平滑项，用于防止除数为0（通常大约设置为$1e−8$）。比较有意思的是，如果没有平方根的操作，算法的效果会变得很差。</p>
<p>由于$G_t$的对角线上包含了关于所有参数θ的历史梯度的平方和，现在，我们可以通过$G_t$和$g_t$之间的元素向量乘法⊙向量化上述的操作：</p>
<script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over\sqrt{\mathbf G_t+\epsilon}}⊙\mathbf g_t</script><p>$Adagrad$算法的一个主要<strong>优点是无需手动调整学习率</strong>。在大多数的应用场景中，通常采用常数$0.01$。</p>
<p>$Adagrad$的一个主要缺点是它在分母中累加梯度的平方：由于没增加一个正项，在整个训练过程中，<strong>累加的和会持续增长。这会导致学习率变小以至于最终变得无限小</strong>，在学习率无限小时，$Adagrad$算法将无法取得额外的信息。接下来的算法旨在解决这个不足。</p>
<h2 id="4-4-Adadelta"><a href="#4-4-Adadelta" class="headerlink" title="4.4 Adadelta"></a>4.4 Adadelta</h2><p>$Adadelta[21]$是$Adagrad$的一种扩展算法，以处理$Adagrad$学习速率单调递减的问题。不是计算所有的梯度平方，<strong>$Adadelta$将计算计算历史梯度的窗口大小限制为一个固定值$w$。</strong></p>
<p>在$Adadelta$中，无需存储先前的$w$个平方梯度，而是将梯度的平方递归地表示成所有历史梯度平方的均值。在$t$时刻的均值$E[g^2]_t$只取决于先前的均值和当前的梯度（分量γ类似于动量项）：</p>
<script type="math/tex; mode=display">E[g^2]_t=γE[g^2]_{t−1}+(1−γ)g^2_t</script><p>我们将γ设置成与动量项相似的值，即$0.9$左右。为了简单起见，我们利用参数更新向量$Δθ_t$重新表示$SGD$的更新过程：</p>
<script type="math/tex; mode=display">Δθ_t=−η⋅g_{t,i}</script><script type="math/tex; mode=display">\theta_{t+1}=\theta_t+\Delta\theta_t</script><p>我们先前得到的Adagrad参数更新向量变为：</p>
<script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over\sqrt{\mathbf G_t+\epsilon}}⊙\mathbf g_t</script><p>现在，我们简单将对角矩阵GtGt替换成历史梯度的均值$E[g^2]_t$：</p>
<script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over\sqrt{E[g^2]_t+\epsilon}}g_t</script><p>由于分母仅仅是梯度的均方根$（root mean squared，RMS）$误差，我们可以简写为：</p>
<script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over RMS[g]_t}g_t</script><p>作者指出上述更新公式中的每个部分（与SGD，动量法或者Adagrad）并不一致，即更新规则中必须与参数具有相同的假设单位。为了实现这个要求，作者首次定义了另一个指数衰减均值，这次不是梯度平方，而是参数的平方的更新：</p>
<script type="math/tex; mode=display">E[Δθ^2]t=γE[Δθ^2]_{t−1}+(1−γ)Δθ^2t</script><p>因此，参数更新的均方根误差为：</p>
<script type="math/tex; mode=display">RMS[\Delta\theta^2]_t=\sqrt{E[\Delta\theta^2]_t+\epsilon}</script><p>由于$RMS[Δθ]_t$是未知的，我们利用参数的均方根误差来近似更新。利用$RMS[Δθ]_{t−1}$替换先前的更新规则中的学习率η，最终得到$Adadelta$的更新规则：</p>
<script type="math/tex; mode=display">\Delta\theta_t=-{RMS[\Delta\theta]_{t-1}\over RMS[g]_t}g_t</script><script type="math/tex; mode=display">\theta_{t+1}=\theta_t+\Delta\theta_t</script><p>使用$Adadelta$算法，我们甚至都无需设置默认的学习率，因为更新规则中已经移除了学习率。</p>
<h2 id="4-5-RMSprop"><a href="#4-5-RMSprop" class="headerlink" title="4.5 $RMSprop$"></a>4.5 $RMSprop$</h2><p>$RMSprop$是一个未被发表的自适应学习率的算法，该算法由$Geoff Hinton$在其<a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="noopener">Coursera课堂的课程6e</a>中提出。</p>
<p>$RMSprop$和$Adadelta$在相同的时间里被独立的提出，都起源于对Adagrad的极速递减的学习率问题的求解。实际上，$RMSprop$是先前我们得到的$Adadelta$的第一个更新向量的特例：</p>
<script type="math/tex; mode=display">E[g^2]_t=0.9E[g^2]_{t−1}+0.1g^2_t</script><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over \sqrt{E[g^2]_t+\epsilon}}g_t</script><p>同样，$RMSprop$将学习率分解成一个平方梯度的指数衰减的平均。$Hinton$建议将$γ$设置为$0.9$，对于学习率η，一个好的固定值为$0.001$。</p>
<h2 id="4-6-Adam"><a href="#4-6-Adam" class="headerlink" title="4.6 Adam"></a>4.6 Adam</h2><p>自适应矩估计$（Adaptive Moment Estimation，Adam）[9]$是另一种自适应学习率的算法，$Adam$对每一个参数都计算自适应的学习率。除了像$Adadelta$和$RMSprop$一样存储一个指数衰减的历史平方梯度的平均$v_t$，$Adam$同时还保存一个历史梯度的指数衰减均值$m_t$，类似于动量：</p>
<script type="math/tex; mode=display">m_t=β_1m_{t−1}+(1−β_1)g_t</script><script type="math/tex; mode=display">v_t=β_2v_{t−1}+(1−β_2)g^2_t</script><p>$m_t$和$v_t$分别是对梯度的一阶矩（均值）和二阶矩（非确定的方差）的估计，正如该算法的名称。当$m_t$和$v_t$初始化为$0$向量时，$Adam$的作者发现它们都偏向于$0$，尤其是在初始化的步骤和当衰减率很小的时候（例如$β_1$和$β_2$趋向于1）。</p>
<p>通过计算偏差校正的一阶矩和二阶矩估计来抵消偏差：</p>
<script type="math/tex; mode=display">m̂ _t={m_t\over 1-\beta^t_1}</script><script type="math/tex; mode=display">\hat v_t={v_t\over 1-\beta^T_2}</script><p>正如我们在$Adadelta$和$RMSprop$中看到的那样，他们利用上述的公式更新参数，由此生成了$Adam$的更新规则：</p>
<script type="math/tex; mode=display">\theta_{t+1}=\theta_t-{\eta\over\sqrt{\hat v_t}+\epsilon}\hat m_t</script><p>作者建议$β_1$取默认值为$0.9$,$β2$为$0.999$，ϵ为$10^{−8}$。他们从经验上表明$Adam$在实际中表现很好，同时，与其他的自适应学习算法相比，其更有优势。</p>
<h2 id="4-7-算法可视化"><a href="#4-7-算法可视化" class="headerlink" title="4.7 算法可视化"></a>4.7 算法可视化</h2><p><img src="/2018/03/23/转-梯度下降优化算法综述/可视化.gif" alt=""></p>
<h2 id="4-8-选择使用哪种优化算法？"><a href="#4-8-选择使用哪种优化算法？" class="headerlink" title="4.8 选择使用哪种优化算法？"></a>4.8 选择使用哪种优化算法？</h2><p>那么，我们应该选择使用哪种优化算法呢？如果输入数据是稀疏的，选择任一自适应学习率算法可能会得到最好的结果。选用这类算法的另一个好处是无需调整学习率，选用默认值就可能达到最好的结果。</p>
<p>总的来说，$RMSprop$是$Adagrad$的扩展形式，用于处理在$Adagrad$中急速递减的学习率。$RMSprop$与$Adadelta$相同，所不同的是$Adadelta$在更新规则中使用参数的均方根进行更新。最后，$Adam$是将偏差校正和动量加入到$RMSprop$中。在这样的情况下，$RMSprop、Adadelta$和$Adam$是很相似的算法并且在相似的环境中性能都不错。$Kingma$等人$[9]$指出在优化后期由于梯度变得越来越稀疏，偏差校正能够帮助Adam微弱地胜过$RMSprop$。综合看来，$Adam$可能是最佳的选择。</p>
<p>有趣的是，最近许多论文中采用不带动量的$SGD$和一种简单的学习率的退火策略。已表明，通常$SGD$能够找到最小值点，但是比其他优化的$SGD$花费更多的时间，与其他算法相比，$SGD$更加依赖鲁棒的初始化和退火策略，同时，$SGD$可能会陷入鞍点，而不是局部极小值点。因此，如果你关心的是快速收敛和训练一个深层的或者复杂的神经网络，你应该选择一个自适应学习率的方法。</p>
<h1 id="5-并行和分布式-SGD"><a href="#5-并行和分布式-SGD" class="headerlink" title="5 并行和分布式$SGD$"></a>5 并行和分布式$SGD$</h1><p>当存在大量的大规模数据和廉价的集群时，利用分布式$SGD$来加速是一个显然的选择。$SGD$本身有固有的顺序：一步一步，我们进一步进展到最小。$SGD$提供了良好的收敛性，但$SGD$的运行缓慢，特别是对于大型数据集。相反，$SGD$异步运行速度更快，但客户端之间非最理想的通信会导致差的收敛。此外，我们也可以在一台机器上并行$SGD$，这样就无需大的计算集群。以下是已经提出的优化的并行和分布式的$SGD$的算法和框架。</p>
<h2 id="5-1-Hogwild"><a href="#5-1-Hogwild" class="headerlink" title="5.1 $Hogwild!$"></a>5.1 $Hogwild!$</h2><p>$Niu$等人[14]提出称为$Hogwild!$的更新机制，$Hogwild!$允许在多个$CPU$上并行执行$SGD$更新。在无需对参数加锁的情况下，处理器可以访问共享的内存。这种方法只适用于稀疏的输入数据，因为每一次更新只会修改一部分参数。在这种情况下，该更新策略几乎可以达到一个最优的收敛速率，因为$CPU$之间不可能重写有用的信息。</p>
<h2 id="5-2-Downpour-SGD"><a href="#5-2-Downpour-SGD" class="headerlink" title="5.2 $Downpour SGD$"></a>5.2 $Downpour SGD$</h2><p>$Downpour SGD$是$SGD$的一种异步的变形形式，在$Google，Dean$等人[6]在他们的$DistBelief$框架（$TensorFlow$的前身）中使用了该方法。$Downpour SGD$在训练集的子集上并行运行多个模型的副本。这些模型将各自的更新发送给一个参数服务器，参数服务器跨越了多台机器。每一台机器负责存储和更新模型的一部分参数。然而，因为副本之间是彼此不互相通信的，即通过共享权重或者更新，因此可能会导致参数发散而不利于收敛。</p>
<h2 id="5-3-延迟容忍-SGD"><a href="#5-3-延迟容忍-SGD" class="headerlink" title="5.3 延迟容忍$SGD$"></a>5.3 延迟容忍$SGD$</h2><p>通过容忍延迟算法的开发，$McMahan$和$Streeter[11]$将$AdaGraad$扩展成并行的模式，该方法不仅适应于历史梯度，同时适应于更新延迟。该方法已经在实践中被证实是有效的。</p>
<h2 id="5-4-TensorFlow"><a href="#5-4-TensorFlow" class="headerlink" title="5.4 $TensorFlow$"></a>5.4 $TensorFlow$</h2><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>[1]是Google近期开源的框架，该框架用于实现和部署大规模机器学习模型。TensorFlow是基于DistBelief开发，同时TensorFlow已经在内部用来在大量移动设备和大规模分布式系统的执行计算。在<a href="http://googleresearch.blogspot.ie/2016/04/announcing-tensorflow-08-now-with.html" target="_blank" rel="noopener">2016年4月</a>发布的分布式版本依赖于图计算，图计算即是对每一个设备将图划分成多个子图，同时，通过发送、接收节点对完成节点之间的通信。</p>
<h2 id="5-5-弹性平均-SGD"><a href="#5-5-弹性平均-SGD" class="headerlink" title="5.5 弹性平均$SGD$"></a>5.5 弹性平均$SGD$</h2><p>$Zhang$等人[22]提出的弹性平均$SGD（Elastic Averaging SGD，EASGD）$连接了异步$SGD$的参数客户端和一个弹性力，即参数服务器存储的一个中心变量。$EASGD$使得局部变量能够从中心变量震荡得更远，这在理论上使得在参数空间中能够得到更多的探索。经验表明这种增强的探索能力通过发现新的局部最优点，能够提高整体的性能。</p>
<h1 id="6-优化-SGD-的其他策略"><a href="#6-优化-SGD-的其他策略" class="headerlink" title="6 优化$SGD$的其他策略"></a>6 优化$SGD$的其他策略</h1><p>最后，我们介绍可以与前面提及到的任一算法配合使用的其他的一些策略，以进一步提高$SGD$的性能。对于其他的一些常用技巧的概述可以参见[10]。</p>
<h2 id="6-1-数据集的洗牌和课程学习"><a href="#6-1-数据集的洗牌和课程学习" class="headerlink" title="6.1 数据集的洗牌和课程学习"></a>6.1 数据集的洗牌和课程学习</h2><p>总的来说，我们希望避免向我们的模型中以一定意义的顺序提供训练数据，因为这样会使得优化算法产生偏差。因此，在每一轮迭代后对训练数据洗牌是一个不错的主意。</p>
<p>另一方面，在很多情况下，我们是逐步解决问题的，而将训练集按照某个有意义的顺序排列会提高模型的性能和$SGD$的收敛性，如何将训练集建立一个有意义的排列被称为课程学习[3]。</p>
<p>$Zaremba and Sutskever[20]$只能使用课程学习训练LSTM来评估简单程序，并表明组合或混合策略比单一的策略更好，通过增加难度来排列示例。</p>
<h2 id="6-2-批量归一化"><a href="#6-2-批量归一化" class="headerlink" title="6.2 批量归一化"></a>6.2 批量归一化</h2><p>为了便于学习，我们通常用0均值和单位方差初始化我们的参数的初始值来归一化。 随着不断训练，参数得到不同的程度的更新，我们失去了这种归一化，随着网络变得越来越深，这种现象会降低训练速度，且放大参数变化。</p>
<p>批量归一化[8]在每次小批量数据反向传播之后重新对参数进行0均值单位方差标准化。通过将模型架构的一部分归一化，我们能够使用更高的学习率，更少关注初始化参数。批量归一化还充当正则化的作用，减少（有时甚至消除）$Dropout$的必要性。</p>
<h2 id="6-3-Early-stopping"><a href="#6-3-Early-stopping" class="headerlink" title="6.3 $Early stopping$"></a>6.3 $Early stopping$</h2><p>如$Geoff Hinton$所说：“$Early Stopping$是美丽好免费午餐”（<a href="http://www.iro.umontreal.ca/~bengioy/talks/DL-Tutorial-NIPS2015.pdf" target="_blank" rel="noopener">NIPS 2015 Tutorial slides</a>）。你因此必须在训练的过程中时常在验证集上监测误差，在验证集上如果损失函数不再显著地降低，那么应该提前结束训练。</p>
<h2 id="6-4-梯度噪音"><a href="#6-4-梯度噪音" class="headerlink" title="6.4 梯度噪音"></a>6.4 梯度噪音</h2><p>$Neelakantan$等人[12]在每个梯度更新中增加满足高斯分布$N(0,σ^2_t)$的噪音：</p>
<script type="math/tex; mode=display">g_{t,i}=g_{t,i}+N(0,σ^2_t)</script><p>高斯分布的方差需要根据如下的策略退火：</p>
<script type="math/tex; mode=display">σ^2_t={\eta\over (1+t)^{\gamma}}</script><p>他们指出增加了噪音，使得网络对不好的初始化更加鲁棒，同时对深层的和复杂的网络的训练特别有益。他们猜测增加的噪音使得模型更优机会逃离当前的局部最优点，以发现新的局部最优点，这在更深层的模型中更加常见。</p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>在这篇博客文章中，我们初步研究了梯度下降的三个变形形式，其中，小批量梯度下降是最受欢迎的。 然后我们研究了最常用于优化SGD的算法：动量法，$Nesterov$加速梯度，$Adagrad，Adadelta，RMSprop，Adam$以及不同的优化异步$SGD$的算法。 最后，我们已经考虑其他一些改善$SGD$的策略，如洗牌和课程学习，批量归一化和$early stopping。$</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>[1] Abadi, M., Agarwal, A., Barham, P., Brevdo, E., Chen, Z., Citro, C., … Zheng, X. (2015). TensorFlow : Large-Scale Machine Learning on Heterogeneous Distributed Systems.</li>
<li>[2] Bengio, Y., Boulanger-Lewandowski, N., &amp; Pascanu, R. (2012). Advances in Optimizing Recurrent Networks. Retrieved from <a href="http://arxiv.org/abs/1212.0901" target="_blank" rel="noopener">http://arxiv.org/abs/1212.0901</a></li>
<li>[3] Bengio, Y., Louradour, J., Collobert, R., &amp; Weston, J. (2009). Curriculum learning. Proceedings of the 26th Annual International Conference on Machine Learning, 41–48. <a href="http://doi.org/10.1145/1553374.1553380" target="_blank" rel="noopener">http://doi.org/10.1145/1553374.1553380</a></li>
<li>[4] Darken, C., Chang, J., &amp; Moody, J. (1992). Learning rate schedules for faster stochastic gradient search. Neural Networks for Signal Processing II Proceedings of the 1992 IEEE Workshop, (September), 1–11. <a href="http://doi.org/10.1109/NNSP.1992.253713" target="_blank" rel="noopener">http://doi.org/10.1109/NNSP.1992.253713</a></li>
<li>[5] Dauphin, Y., Pascanu, R., Gulcehre, C., Cho, K., Ganguli, S., &amp; Bengio, Y. (2014). Identifying and attacking the saddle point problem in high-dimensional non-convex optimization. arXiv, 1–14. Retrieved from <a href="http://arxiv.org/abs/1406.2572" target="_blank" rel="noopener">http://arxiv.org/abs/1406.2572</a></li>
<li>[6] Dean, J., Corrado, G. S., Monga, R., Chen, K., Devin, M., Le, Q. V, … Ng, A. Y. (2012). Large Scale Distributed Deep Networks. NIPS 2012: Neural Information Processing Systems, 1–11. <a href="http://doi.org/10.1109/ICDAR.2011.95" target="_blank" rel="noopener">http://doi.org/10.1109/ICDAR.2011.95</a></li>
<li>[7] Duchi, J., Hazan, E., &amp; Singer, Y. (2011). Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12, 2121–2159. Retrieved from <a href="http://jmlr.org/papers/v12/duchi11a.html" target="_blank" rel="noopener">http://jmlr.org/papers/v12/duchi11a.html</a></li>
<li>[8] Ioffe, S., &amp; Szegedy, C. (2015). Batch Normalization : Accelerating Deep Network Training by Reducing Internal Covariate Shift. arXiv Preprint arXiv:1502.03167v3</li>
<li>[9] Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations, 1–13.</li>
<li>[10] LeCun, Y., Bottou, L., Orr, G. B., &amp; Müller, K. R. (1998). Efficient BackProp. Neural Networks: Tricks of the Trade, 1524, 9–50. <a href="http://doi.org/10.1007/3-540-49430-8_2" target="_blank" rel="noopener">http://doi.org/10.1007/3-540-49430-8_2</a></li>
<li>[11] Mcmahan, H. B., &amp; Streeter, M. (2014). Delay-Tolerant Algorithms for Asynchronous Distributed Online Learning. Advances in Neural Information Processing Systems (Proceedings of NIPS), 1–9. Retrieved from <a href="http://papers.nips.cc/paper/5242-delay-tolerant-algorithms-for-asynchronous-distributed-online-learning.pdf" target="_blank" rel="noopener">http://papers.nips.cc/paper/5242-delay-tolerant-algorithms-for-asynchronous-distributed-online-learning.pdf</a></li>
<li>[12] Neelakantan, A., Vilnis, L., Le, Q. V., Sutskever, I., Kaiser, L., Kurach, K., &amp; Martens, J. (2015). Adding Gradient Noise Improves Learning for Very Deep Networks, 1–11. Retrieved from <a href="https://blog.csdn.net/google19890102/article/details/Neelakantan,%20A.,%20Vilnis,%20L.,%20Le,%20Q.%20V.,%20Sutskever,%20I.,%20Kaiser,%20L.,%20Kurach,%20K.,%20&amp;%20Martens,%20J.%20%282015%29.%20Adding%20Gradient%20Noise%20Improves%20Learning%20for%20Very%20Deep%20Networks,%201%E2%80%9311.%20Retrieved%20from%20http://arxiv.org/abs/1511.06807" target="_blank" rel="noopener">http://arxiv.org/abs/1511.06807</a></li>
<li>[13] Nesterov, Y. (1983). A method for unconstrained convex minimization problem with the rate of convergence o(1/k2). Doklady ANSSSR (translated as Soviet.Math.Docl.), vol. 269, pp. 543– 547.</li>
<li>[14] Niu, F., Recht, B., Christopher, R., &amp; Wright, S. J. (2011). Hogwild! : A Lock-Free Approach to Parallelizing Stochastic Gradient Descent, 1–22.</li>
<li>[15] Pennington, J., Socher, R., &amp; Manning, C. D. (2014). Glove: Global Vectors for Word Representation. Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing, 1532–1543. <a href="http://doi.org/10.3115/v1/D14-1162" target="_blank" rel="noopener">http://doi.org/10.3115/v1/D14-1162</a></li>
<li>[16] Qian, N. (1999). On the momentum term in gradient descent learning algorithms. Neural Networks : The Official Journal of the International Neural Network Society, 12(1), 145–151. <a href="http://doi.org/10.1016/S0893-6080%2898%2900116-6" target="_blank" rel="noopener">http://doi.org/10.1016/S0893-6080(98)00116-6</a></li>
<li>[17] H. Robinds and S. Monro, “A stochastic approximation method,” Annals of Mathematical Statistics, vol. 22, pp. 400–407, 1951.</li>
<li>[18] Sutskever, I. (2013). Training Recurrent neural Networks. PhD Thesis.</li>
<li>[19] Sutton, R. S. (1986). Two problems with backpropagation and other steepest-descent learning procedures for networks. Proc. 8th Annual Conf. Cognitive Science Society.</li>
<li>[20] Zaremba, W., &amp; Sutskever, I. (2014). Learning to Execute, 1–25. Retrieved from <a href="http://arxiv.org/abs/1410.4615" target="_blank" rel="noopener">http://arxiv.org/abs/1410.4615</a></li>
<li>[21] Zeiler, M. D. (2012). ADADELTA: An Adaptive Learning Rate Method. Retrieved from <a href="http://arxiv.org/abs/1212.5701" target="_blank" rel="noopener">http://arxiv.org/abs/1212.5701</a></li>
<li>[22] Zhang, S., Choromanska, A., &amp; LeCun, Y. (2015). Deep learning with Elastic Averaging SGD. Neural Information Processing Systems Conference (NIPS 2015), 1–24. Retrieved from <a href="http://arxiv.org/abs/1412.6651" target="_blank" rel="noopener">http://arxiv.org/abs/1412.6651</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[转载一篇很全面的梯度下降优化算法综述]]>
    
    </summary>
    
      <category term="梯度下降" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最优化问题及KKT条件的几何理解]]></title>
    <link href="http://yoursite.com/2018/03/19/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%8F%8AKKT%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%87%A0%E4%BD%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/19/最优化问题及KKT条件的几何理解/</id>
    <published>2018-03-19T07:31:31.000Z</published>
    <updated>2018-03-25T04:30:53.527Z</updated>
    <content type="html"><![CDATA[<p>以二维空间$R^2$举例，从简单的无约束优化（0梯度条件），到等式约束优化（拉格朗日条件），再到不等式约束优化（KKT条件）解析优化问题解法的几何意义。</p>
<h2 id="无约束优化问题"><a href="#无约束优化问题" class="headerlink" title="无约束优化问题"></a>无约束优化问题</h2><p>$\min f(x)$，其中，<strong>$x=(x_1,x_2)$</strong></p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/无约束优化.jpg" alt=""></p>
<p>此时，对于$f(x)$的局部极小值点（红点）处梯度必然为0.因此优化问题可以转化为求解梯度为0的点。</p>
<h2 id="带等式约束的优化问题"><a href="#带等式约束的优化问题" class="headerlink" title="带等式约束的优化问题"></a>带等式约束的优化问题</h2><p>$\min f(x)$，其中，<strong>$x=(x_1,x_2)$</strong></p>
<p>$s.t. h(x)=0$</p>
<p>与无约束问题不同，此时极小值点被限制在曲线$h(x)=0$上，我们因此将$\{x|h(x)=0\}$成为<strong>可行域</strong>，解只能在这个可行域里面取。如下图所示，曲线$h(x)=0$（黑色实线）便是可行域，现在要求在可行域上面的极小点。可以想象从无约束问题的极小点（黑点）靠等高线向外扩展，当扩展等高线第一次接触可行域时候（相切，<strong>梯度方向相反</strong>）的交点便是可行域的极小点。所以，相切，梯度方向相反，是取得极小值点的必要条件。</p>
<p>补充：能够碰到极大极小值点的必要条件是：梯度场与切空间垂直，也就是梯度场不能够有任何流形切空间上的分量，否则在切空间方向有分量，在流形上沿分量方向走，函数值会增加，沿反方向走，函数值会减少，不可能为局部极小或者极大值点。</p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/等式约束优化.jpg" alt=""></p>
<p>两条曲线相切，梯度方向相反，即梯度差一个任意的常数乘子（取为$-\lambda$）：$\nabla f(x)=-\lambda \nabla h(x)$，调整后即可得到拉格朗日条件$\nabla (f(x)+\lambda h(x))=0$.</p>
<p>如此，带等式约束的优化问题转化为了无约束的优化问题，只需要对拉格朗日条件解方程组即可。这里$\lambda$便是拉格朗日乘子，有多少个等式约束就有多少个拉格朗日乘子。</p>
<h2 id="带不等式约束的优化问题"><a href="#带不等式约束的优化问题" class="headerlink" title="带不等式约束的优化问题"></a>带不等式约束的优化问题</h2><h3 id="只有一个不等式起作用时"><a href="#只有一个不等式起作用时" class="headerlink" title="只有一个不等式起作用时"></a>只有一个不等式起作用时</h3><p>$\min f(x)$</p>
<p>$s.t.  h(x)\le0$</p>
<p>当只有一个不等式起作用时，如下图所示，可行域变成了阴影部分，最小值点还是切点，跟等式约束条件完全一样，只需要把不等号当做等号去求解即可。</p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/不等式约束优化1.jpg" alt=""></p>
<h3 id="两个及以上不等式起作用时"><a href="#两个及以上不等式起作用时" class="headerlink" title="两个及以上不等式起作用时"></a>两个及以上不等式起作用时</h3><p>$\min f(x)$</p>
<p>$s.t.$</p>
<p>$g_1(x)\le0$</p>
<p>$g_2(x)\le0$</p>
<p>如下图，当$f(x)$等高线慢慢扩大时，等高线与可行域（阴影部分）第一次相遇的点是个顶点，2个不等式同时起作用。满足最小值点从原来黑点的位置（切点）移动到了红点的位置，现在跟哪条约束函数都不相切了。这时候就需要用到KKt条件了。这里的条件是指：某一个点它如果是最小值点的话，就必须满足这个条件（在含不等式约束的优化问题里）。这是个<strong>必要条件</strong>，前面说的也全部是<strong>必要条件</strong>。</p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/不等式约束优化2.jpg" alt=""></p>
<p>这个问题的解$x^*$应满足的KKT（卡罗需-库恩-塔克）条件为：</p>
<p>$1. \mu_1\ge0, \mu_2\ge0;$</p>
<p>$2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)=0;$</p>
<p>$3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)=0$</p>
<p>其中，$\mu$叫做KKT乘子，有多少个不等式约束就有多少个KKT乘子。加上本问题中的约束不封，就是完整版的KKT条件。<strong>对于有等式的情况：把其中一个不等式约束换成等式，可行域变成了半条曲线，最小值还是小红点，情况是一样的。</strong></p>
<p>接下来看看KKT条件的几何意义。上图中<strong>绿色箭头</strong>为两条曲线的<strong>负梯度</strong>方向，<strong>红色箭头</strong>为等高线的<strong>梯度</strong>方向。如果这个顶点为满足约束的最小值点，那么该点处等高线梯度（红色箭头）一定在两个绿色箭头之间（$-\nabla g(x)$方向（绿色箭头）一定指向$g(x)$减小方向，即$g(x)\lt0$一边）</p>
<p>$\mu_1\ge0,\mu_2\ge0$(红色箭头一定在绿色箭头之间)的解释：若三个向量的位置如下图所示，即$-\nabla f(x)$落在$\nabla g_1,\nabla g_2$所形成的锥形区域外侧。此时，作等高线（等值线）在点$x^k$处的切平面，可以发现：<strong>沿着与扶梯度$-\nabla f(x)$成锐角方向移动</strong>，只要能在红色阴影（阴影左界为当前等高线）取值，$f(x)$总能减小，而红色阴影区域为可行域，因此既可以建系哦啊目标函数值，又不破坏约束条件，所以当前$x^k$不是最优点。</p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/箭头中间.jpg" alt=""></p>
<h2 id="有些不等式约束不起作用时"><a href="#有些不等式约束不起作用时" class="headerlink" title="有些不等式约束不起作用时"></a>有些不等式约束不起作用时</h2><p>如下面这个优化问题：</p>
<p>$\min f(x)$</p>
<p>$s.t.$</p>
<p>$g_1(x)\le0$</p>
<p>$g_2(x)\le0$</p>
<p>$g_3(x)\le0$</p>
<p>如下图$g_3(x)\le0$是不起作用的</p>
<p><img src="/2018/03/19/最优化问题及KKT条件的几何理解/不等式约束优化3.jpg" alt=""></p>
<p>对于最小值点$x^*$，三个不等式约束的不同在于：</p>
<p>$g_1(x^￥)=0$（起作用）</p>
<p>$g_2(x^￥)=0$（起作用）</p>
<p>$g_3(x^￥)\lt0$（不起作用，最小值点不在$g_3(x)=0$上）</p>
<p>此时KKT条件1，2变为：</p>
<p>$1. \mu_1\ge0, \mu_2\ge0, \mu_3\ge0, $</p>
<p>$2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)+\mu_3\nabla g_3(x^￥)=0$</p>
<p>条件2中的$\mu_3\nabla g_3(x^￥)$让我们很苦恼，$g_3(x￥)$约束根本不起作用，要是能令$\mu_3=0$就好了。加上条件3：</p>
<p>$3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)+\mu_3g_3(x^￥)=0$</p>
<p>恰好能使$\mu_3=0​$。由于$g_1(x^￥)=0, g_2(x^￥)=0​$，所以前两项等于0，第三项$g_3(x^￥)\lt0​$,在条件3的作用下使得$\mu_3=0​$。正好满足哟啊求。如果再多几项不起作用的不等式约束，条件2都能在条件3的作用下实现：目标函数$f(x)​$的梯度$\nabla f(x)​$被起作用的不等式约束函数$g(x)​$的负梯度$-\nabla g(x)​$线性标出且系数$\mu​$全部非负（红色箭头被绿色箭头夹在中间）。这样，优化问题的求解就变成了对所有KKT条件解方程组。</p>
<p>如果再定义一个拉格朗日函数：</p>
<p>$L(x,\mu)=f(x)+\mu_1g_1(x)+\mu_2g_2(x)+…$</p>
<p>令它对<strong>$x$</strong>的偏导为0，就是KKT条件中的条件2了。</p>
<p>注意：以上所有都是局部极小值的点<strong>必要条件</strong>。据此求得的解不一定是局部极小值点（更别提全局），原因是上图中所画的等高线也许根本就不闭合，也急速实说我们一直想靠近的等高线和中间的黑点可能压根就是个鞍点或者近似鞍点。</p>
]]></content>
    <summary type="html">
    <![CDATA[从无约束最优化到等式约束优化，再到不等式优化，以及对拉格朗日对偶中KKT条件的几何理解]]>
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="KKT" scheme="http://yoursite.com/tags/KKT/"/>
    
      <category term="最优化" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GBDT&Xgboost]]></title>
    <link href="http://yoursite.com/2018/03/17/GBDT/"/>
    <id>http://yoursite.com/2018/03/17/GBDT/</id>
    <published>2018-03-17T14:02:03.000Z</published>
    <updated>2018-03-25T04:28:42.467Z</updated>
    <content type="html"><![CDATA[<h1 id="提升方法"><a href="#提升方法" class="headerlink" title="提升方法"></a>提升方法</h1><blockquote>
<p>在分类问题中，它通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，他通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，特高分类性能</p>
<p>对于提升方法，有两个问题需要回答：一是在每一轮如何改变训练数据的权值或概率分布；而是如何将弱分类器组合成一个强分类器。</p>
<p>​                                                    -《统计学习方法》</p>
</blockquote>
<h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><blockquote>
<p>$Adaboost$算法的特点是通过迭代每次学习一个基本分类器，每次迭代中，提高那些被前一轮分类器错误分类<strong>数据</strong>的权值，而降低那些被正确分类的<strong>数据</strong>的权值。最后$Adaboost$将基本分类器的线性组合作为强分类器，其中给分类误差率小的<strong>基本分类器</strong>大的权值，给分类误差率大的<strong>基本分类器</strong>小的权值</p>
</blockquote>
<h2 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h2><p>提升树正是一种前向分步的加法模型，但是其基分类器是树模型(二叉树)，分为二叉分类树和二叉回归树，提升树往往在实践中表现非常好。提升树的模型如下:</p>
<script type="math/tex; mode=display">f_M(x)=\sum^M_{m=1}T(x;\Theta)</script><p>其中$T(x;\Theta)$表示决策树，$M$为树的个数，$\Theta$表示树的参数。</p>
<p>首先确定初始提升树$f_0(x)=0$，第$m$步的模型是</p>
<script type="math/tex; mode=display">f_m(x)=f_{m-1}(x)+T(x;\Theta_m)</script><p>其中，$f_{m-1}(x)$为当前模型，通过经验风险极小化确定下一棵决策树的参数$\Theta_m$，第$m$步的模型是</p>
<script type="math/tex; mode=display">\hat \Theta_m=\arg \min_{\Theta_m}\sum^N_{i=1}L(y_i,\ f_{m-1}(x_i)+T(x_i;\Theta_m))</script><h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><h2 id="为什么拟合负梯度"><a href="#为什么拟合负梯度" class="headerlink" title="为什么拟合负梯度"></a>为什么拟合负梯度</h2><p>为什么要拟合负梯度（<strong>注意这里的梯度是对$\hat y_i^{t-1}$</strong>求导）呢？</p>
<p>跟梯度下降类似，我们不断减去$\partial f(x)\over \partial x$可以得到$\min_x f(x)$，同理不断减去$\partial L\over\partial \hat y^{t-1}_i$就能得到$\min_{\hat y}L(\hat y)$。所以其实GBDT就是在<strong>函数空间</strong>的梯度下降。</p>
<h2 id="传统GBDT算法"><a href="#传统GBDT算法" class="headerlink" title="传统GBDT算法"></a>传统GBDT算法</h2><p>算法流程：</p>
<p><img src="/2018/03/17/GBDT/算法流程.png" alt=""></p>
<p>乍一看，GBDT算法跟<strong>梯度下降</strong>算法很像，其实GBDT就是在<strong>函数空间</strong>的梯度下降，我们不断减去$\partial f(x)\over \partial x$可以得到$\min_x f(x)$，同理不断减去$\partial L\over\partial F_{K-1}$就能得到$\min_FL(F)$，注意这里是对$F_{K-1}$求导。</p>
<h2 id="基于残差的GBDT"><a href="#基于残差的GBDT" class="headerlink" title="基于残差的GBDT"></a>基于残差的GBDT</h2><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>$GBDT$全称$Gradient Boosting Decision Tree$, 其中$gradient$被称为梯度，更一般的理解，可以认为是一阶导，这里残差与梯度是什么关系呢。我们看平方损失函数${1\over 2}\sum^n_0(y_i-F(x_i))^2$，这个算是函数主要是针对回归类型的。</p>
<p>$    {1\over 2}\sum^n_{i=1}(y_i-F(x_i))^2$</p>
<p>$= {1\over 2}\sum^n_{i=1}(y_i-\hat y_i^t)^2$</p>
<p>$= {1\over 2}\sum^n_{i=1}(y_i-\hat y_i^{t-1}-f_t(x_i))^2$</p>
<p>令其对$\hat y_i^{t-1}$求导为0 得：</p>
<script type="math/tex; mode=display">-\sum^n_{i=1}(y_i-\hat y_i^{t-1}-f_t(x_i))=0</script><p>则：</p>
<script type="math/tex; mode=display">\sum_{i=1}^nf_t(x_i)=\sum_{i=1}^n(y_i-\hat y_i^{t-1})</script><p>所以基于残差的gbdt是一种特殊的gbdt模型，它的损失函数是平方损失函数，只能处理回归类的问题。</p>
<h3 id="为什么基于残差的gbdt不是一个好的选择"><a href="#为什么基于残差的gbdt不是一个好的选择" class="headerlink" title="为什么基于残差的gbdt不是一个好的选择"></a>为什么基于残差的gbdt不是一个好的选择</h3><p>首先基于残差的gbdt只能处理回归类的问题，不能处理分类问题，这是损失函数所限制的，所以更一般化的gbdt是基于梯度的算法，这也就意味着只要我给出的损失函数是可导的，那么我就能用gbdt的思想去解决问题。具体解决的问题就不会仅仅限于回归了。</p>
<p> 另外，基于残差的gbdt在解决回归问题上也不算是一个好的选择，一个比较明显的缺点就是对异常值过于敏感。</p>
<h2 id="Boosting的加法模型"><a href="#Boosting的加法模型" class="headerlink" title="Boosting的加法模型"></a>Boosting的加法模型</h2><p>gbdt模型可以认为是是由k个基模型组成的一个加法运算式：</p>
<p><img src="/2018/03/17/GBDT/公式0.svg" alt=""></p>
<p>其中F是指所有基模型组成的函数空，以回归任务为例，回归树可以看作为一个把特征向量映射为某个score的函数。该模型的参数为：$\Theta=\{f_1,f_2,…,f_K\}$。于一般的机器学习算法不同的是，加法模型不是学习d维空间中的权重，而是<strong>直接学习函数（决策树）集合</strong>。</p>
<p>那么一般化的损失函数是预测值$\hat y$与 真实值$y$之间的关系，如我们前面的平方损失函数，那么对于n个样本来说，则可以写成：</p>
<script type="math/tex; mode=display">L=\sum^n_{i=1}l(y_i,\ \hat y_i)</script><p>更一般的，我们知道一个好的模型，在偏差和方差上有一个较好的平衡，而算法的损失函数正是代表了模型的偏差面，<strong>最小化损失函数，就相当于最小化模型的偏差，但同时我们也需要兼顾模型的方差，所以目标函数还包括抑制模型复杂度的正则项</strong>，因此目标函数可以写成：</p>
<script type="math/tex; mode=display">Obj=\sum^n_{i=1}f_k(x_i)+\sum^K_{k=1}\Omega(f_k)</script><p>其中$\Omega$代表了基模型的复杂度，若基模型是书模型，则树的深度、叶子节点数等指标可以反映树的复杂度。</p>
<p>对于Boosting来说，它采用的是前向分布算法，即从前往后，逐渐建立基模型来优化逼近目标函数，具体过程如下：</p>
<p><img src="/2018/03/17/GBDT/equation0.svg" alt=""></p>
<p>那么，在每一步，如何学习一个新的模型呢，答案的关键还是在于gbdt的目标函数上，即新模型的加入总是以优化目标函数为目的的。</p>
<p>我们一第$t$步的模型拟合为例，在这一步，模型对第$i$个样本$x_i$的预测为：</p>
<script type="math/tex; mode=display">\hat y_i^t=\hat y^{t-1}_i+f_t(x_i)</script><p>其中$f_t(x_i)$就是我们这次需要加入的新模型，即需要拟合的模型，此时，目标函数就可以写成：</p>
<p><img src="/2018/03/17/GBDT/equation1.svg" alt=""></p>
<p>即此时最优化目标函数，就相当于求得了$f_t(x_i)$</p>
<h1 id="Xgboost"><a href="#Xgboost" class="headerlink" title="$Xgboost$"></a>$Xgboost$</h1><h2 id="Xgboost-的目标函数"><a href="#Xgboost-的目标函数" class="headerlink" title="$Xgboost$的目标函数"></a>$Xgboost$的目标函数</h2><blockquote>
<p><strong>泰勒公式：</strong>设$n$是一个正整数，如果定义在一个包含$a$的区间上的函数$f$在$a$点处$n+1$次可导，那么对于这个区间上的任意$x$都有：$f(x)=\sum^N_{n=0}{f^{(n)}(a)\over n!}(x-a)^n+R_n(x)$，其中的多项式称为函数在$a$处的泰勒展开式，$R_n(x)$是泰勒公式的余项且是$(x-a)^n$的高阶无穷小。</p>
<p>​                                                    ——维基百科</p>
</blockquote>
<p>二阶泰勒展开：</p>
<p><img src="/2018/03/17/GBDT/equation2.svg" alt=""></p>
<p>那么在等式$(1)$中，我们把$\hat y^{t-1}_i$看成是等式$(2)$中的$x$，$f_t(x_i)$看成是$\Delta x$，因此等式$(1)$可以写成：</p>
<p><img src="/2018/03/17/GBDT/equation3.svg" alt=""></p>
<p>其中$g_i$和$h_i$分别为$l(y_i, \hat y_i^{t-1})$<strong>关于$\hat y_i^{t-1}$</strong>的一阶导和二阶导。我们一平方损失函数为例$\sum^n_{i=1}(y_i-(\hat y^{t-1}_i+f_t(x_i) ) )^2$，则$g_i=\partial _{\hat y^{t-1}}(\hat y^{t-1}-y_i)^2=2(\hat y^{t-1}-y_i)$，$h_i=\partial^2_{\hat y^{t-1}}(\hat y^{t-1}-y_i)^2=2$。</p>
<p>由于在第$t$步$\hat y^{t-1}_i$其实是一个已知的值，所以$l(y_i, \hat y^{t-1}_i)$是一个常数，其对函数优化不会产生影响，因此，等式$(3)$可以写成：</p>
<p><img src="/2018/03/17/GBDT/equation4.svg" alt=""></p>
<p>所以我们只需要求出前一步损失函数的一阶和二阶导的值（由于前一步的$\hat y^{t-1}$是已知的，所以这两个值就是常数）带入等式$(4)$，然后优化目标函数，就可得到每一步的$f(x)$，最后根据加法模型的到一个整体的模型。</p>
<h2 id="如何用决策树来表示上一步的目标函数"><a href="#如何用决策树来表示上一步的目标函数" class="headerlink" title="如何用决策树来表示上一步的目标函数"></a>如何用决策树来表示上一步的目标函数</h2><p> 假设我们$boosting$的基模型用决策树来实现，则一颗生成好的决策树，即结构确定，也就是说树的叶子结点其实是确定了的。假设这棵树的叶子节点有$T$片叶子，而每片叶子对应的值$w\in R^T$。熟悉决策树的同学应该清楚，每一片叶子结点中样本的预测值都会是一样的，在分类问题中，是某一类；在回归问题中，是某一个值，那么肯定存在这样一个函数$q:R^d\rightarrow \{1,2,…,T\}$，及将$f_t(x)$中的每个样本映射到每一个叶子节点上，当然$f_t(x)$和$q$我们都是不知道的，但我们也不关心，这里只是说明一下决策树表达数据结构的方法是怎么样的，不理解也没有问题。</p>
<p>那么$f_t(x)$就可以转成$w_{q(x)}$，这里的$q(x)$代表了每个样本<strong>在哪个叶子节点上</strong>，而$w_{q(x)}$则代表了哪个叶子结点去什么$w$值，所以$w_{q(x)}$就代表了每个样本的取值$w$（即预测值）。</p>
<p>如果决策树的复杂度可以由正则项来定义$\Omega(f_t)=\gamma T+{1\over2}\lambda\sum_{j=1}^Tw_j^2$ (这是xgb的正则项)，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的$L2$范数决定。</p>
<p>我们假设<strong>$I_j=\{i|q(x_i)=j\}$</strong>为第$j$个叶子节点的样本集合，则等式$(4)$根据上面的一些变换可以写成：</p>
<p><img src="/2018/03/17/GBDT/equation5.svg" alt=""></p>
<p><em>即我们之前样本的集合，现在都改写成了叶子结点的集合，由于一个叶子结点有多个样本存在，因此才有了$\sum_{i\in I_j}g_i$和$\sum_{i\in I_j}h_i$这两项。</em></p>
<p>定义$G_j=\sum_{i\in I_j}g_i，H_j=\sum_{i\in I_j}h_i$，则等式$(5)$可以写成：</p>
<script type="math/tex; mode=display">Obj^{(t)}=\sum^T_{j=1}[G_jw_j+{1\over 2}(H_j+\lambda)w_j^2]+\gamma T</script><p>如果树结构是固定的，即$q$是确定的，或者说我们已经知道了每个叶子结点有哪些样本，所以$G_j$和$H_j$是确定的，但$w$不确定（$w$其实就是我们要预测的值），那么令目标函数一阶导数为$0$，则可以求得叶子结点$j$对应的值：</p>
<p><img src="/2018/03/17/GBDT/equation6.svg" alt=""></p>
<p>目标函数的值可以化简为：</p>
<p><img src="/2018/03/17/GBDT/equation7.svg" alt=""></p>
<h2 id="如何求树的结构（单线程版本）"><a href="#如何求树的结构（单线程版本）" class="headerlink" title="如何求树的结构（单线程版本）"></a>如何求树的结构（单线程版本）</h2><p> 那么对于单棵决策树，一种理想的优化状态就是枚举所有可能的树结构，因此过程如下：</p>
<ol>
<li>首先枚举所有可能的树结构；</li>
<li>计算每种树结构下的目标函数值，即等式$(7)$的值；</li>
<li>取目标函数最小（大）值为最佳的数结构，根据等式6求得每个叶子节点的$w$取值，即样本的预测值。</li>
</ol>
<p>然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。 </p>
<ol>
<li>从深度为0的树开始，对每个叶节点枚举所有的可用特征 </li>
<li>针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益（采用最佳分裂点时的收益） </li>
<li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集 </li>
<li>回到第1步，递归执行到满足特定条件为止</li>
</ol>
<p>那么如何计算上面的收益呢，很简单，仍然紧扣目标函数就可以了。假设我们在某一节点上二分裂成两个节点，分别是左$（L）$右$（R）$，则分列前的目标函数是$-{1\over 2}[{(G_L+G_R)^2\over H_L+H_R+\lambda}] $，分裂后则是$-{1\over 2}[{G_L^2\over H_L+\lambda}+{G_R^2\over H_R+\lambda}]+2\lambda$，则对于目标函数来说，分裂后的收益是（这里假设是最小化目标函数，所以用分列前减去分裂后）：</p>
<p><img src="/2018/03/17/GBDT/equation8.svg" alt=""></p>
<p><strong><em>等式$(8)$计算出来的收益，也是作为变量重要度输出的重要依据。</em></strong></p>
<p>这时，就有两种后续。一种是当最好的分割的情况下，GainGain为负时就停止树的生长，这样的话效率会比较高也简单，但是这样就放弃了未来可能会有更好的情况。另外一种就是一直分割到最大深度，然后进行修剪，递归得把划分叶子得到的Gain为负的收回。一般来说，后一种要好一些，于是我们采用后一种，完整的算法如下（没有写修剪）</p>
<p><img src="/2018/03/17/GBDT/贪婪算法.png" alt=""></p>
<h2 id="建树总结"><a href="#建树总结" class="headerlink" title="建树总结"></a>建树总结</h2><p>所以gbdt的算法可以总结为：</p>
<ol>
<li>算法在拟合的每一步都新生成一颗决策树；</li>
<li>在拟合这棵树之前，需要计算损失函数在每个样本上的一阶导和二阶导，即$g_i$和$h_i$;</li>
<li>通过上面的贪心策略生成一棵树，计算每个叶子节点的$G_j$和$H_j$，利用等式$(6)$计算预测值$w$;</li>
<li>把新生成的决策树$f_t(x)$加入$\hat y^t_i=\hat y^{t-1}_i+\epsilon f_t(x_i)$，其中$\epsilon$为学习率，主要为了<strong>抑制模型的过拟合</strong>。</li>
</ol>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><ol>
<li>按照某特征里的值进行排序，复杂度是$O(nlog n)$<br>  2. 扫描一遍该特征所有值得到最优分割点，因为该层（兄弟统一考虑）一共有$n$个样本，所以复杂度是$O(n)$<br>  3. 一共有$d$个特征，所以对于一层的操作，复杂度是$O(d(nlog n+n))=O(d nlog n)$<br>  4. 该树的深度为$k$。所以总复杂度是$O(k d nlog n)$</li>
</ol>
<h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><h3 id="近似算法思想"><a href="#近似算法思想" class="headerlink" title="近似算法思想"></a>近似算法思想</h3><p>枚举特征所有可能分割在计算上要求很高，为有效做到这一点，算法必须根据特征值对数据预先排序。贪心算法很强大，<strong>然而当数据量过大，无法装入整个内存中时，会非常不高效。</strong></p>
<p>树模型对特征取值范围不敏感，只对顺序敏感。近似算法首先根据特征分布的百分位提出候选分裂点，然后将连续特征映射到这些候选分割点形成的bucket中，聚合统计数据，并基于聚合数据找到最佳解决方案。<strong>近似算法通常使用加权百分位树选择候选分割点，使特征按照权重期望均匀分布在候选分割点之间。</strong></p>
<p>我们用$D_k=\{(x_{1k},h_1),(x_{2k},h_2),(x_{3k},h_3),…,(x_{nk},h_n)\}$代表每个样本的第$k$个特征和其对应的二阶梯度所组成的集合。那么我们就可以用百分比来定义这个排名函数$r_k:\mathbb{R}\rightarrow[0,1]$：</p>
<script type="math/tex; mode=display">r_k(z)={1\over \sum_{(x,h)\in D_k}h}\sum_{(x,h)\in D_k,\ x<z}h</script><p>上式表示的是该特征的值小于z的样本所占总样本的比例。于是我们就能用下面这个不等式来寻找分割点$\{s_{k1},s_{k2},s_{k3},…,s_{kl}\}$</p>
<script type="math/tex; mode=display">||r_k(s_{k,j})-r_k(s_{k,j+1})||<\epsilon,\ \ s_{k,1}=\min_ix_{ik}, \ s_{k,l}=\max_ix_{ik}</script><p>上式中$\epsilon$表示的是一个近似比例，或者说一个扫描步进。从最小值开始，每次增加$\epsilon(\max_ix_{ik}-\min_ix_{ik})$作为分割点。然后再这些分割点中选择一个 最大的分数作为最后的分割点。并且这里每个数据点被$h_i$加权,这里等式$(4)$可以写成如下形式：</p>
<script type="math/tex; mode=display">\sum^n_{i=1}{1\over 2}h_i(f_t(x_i)-g_i/h_i)^2+\Omega(f_t)+constant</script><p>可以把$h_i$看做方差损失函数的权值。</p>
<h3 id="两种近似算法"><a href="#两种近似算法" class="headerlink" title="两种近似算法"></a>两种近似算法</h3><p>很明显这里有两种分割思路：</p>
<ul>
<li>全局分割：建树前将所有特征分割完</li>
<li>局部分割：每次分裂节点后重新分割特征</li>
</ul>
<p>全局方法比局部方法需要更少的分割步骤，但是全局方法通常需要更多的候选点才能保证效果，因为候选在每次节点分裂之后不会被重新完善，局部分割在每次分裂节点后被重新完善，并且有可能适合更深的树。</p>
<h2 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h2><p>此部分引自知乎答主<a href="https://www.zhihu.com/question/41354392" target="_blank" rel="noopener">杨军</a></p>
<p>在$XGBoost$的实现中，对算法进行了模块化的拆解，几个重要的部分分别是：</p>
<p>​       I. $ObjFunction$：对应于不同的$Loss Function$，可以完成一阶和二阶导数的计算。</p>
<p>​       II. $GradientBooster$：用于管理$Boost$方法生成的$Model$，注意，这里的$Booster Model$既可以对应于线性$Booster Model$，也可以对应于$Tree Booster Model$。</p>
<p>​       III. $Updater$：用于建树，根据具体的建树策略不同，也会有多种$Updater$。比如，在$XGBoost$里为了性能优化，既提供了单机多线程并行加速，也支持多机分布式加速。也就提供了若干种不同的并行建树的$updater$实现，按并行策略的不同，包括：<br>       I). $inter-feature exact parallelism $（特征级精确并行）<br>       II). $inter-feature approximate parallelism$（特征级近似并行，基于特征分bin计算，减少了枚举所有特征分裂点的开销）<br>       III). $intra-feature parallelism$ （特征内并行）<br>       IV). $inter-node parallelism$  （多机并行）</p>
<h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><p>此部分引自知乎答主<a href="https://www.zhihu.com/search?type=content&amp;q=xgboost%20%E7%BC%BA%E5%A4%B1%E5%80%BC" target="_blank" rel="noopener">微调</a></p>
<p>$xgboost$处理缺失值的方法和其他树模型不同。根据作者$Tianqi Chen$在论文中章节3.4的介绍，$xgboost$把缺失值当做稀疏矩阵来对待，本身的在节点分裂时不考虑的缺失值的数值。通过这个工程$trick$来减少了为稀疏离散特征寻找$split point$的时间开销。缺失值数据会被分到左子树和右子树分别计算损失，选择较优的那一个。如果训练中没有数据缺失，预测时出现了数据缺失，那么默认被分类到右子树。具体的介绍可以参考<a href="https://github.com/dmlc/xgboost/issues/21" target="_blank" rel="noopener">链接1</a><a href="http://xgboost.readthedocs.io/en/latest/faq.html#how-to-deal-with-missing-value" target="_blank" rel="noopener">链接2</a>。</p>
<p><img src="/2018/03/17/GBDT/缺失值.jpg" alt=""></p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>下面介绍GBDT中抵抗过拟合的技巧</p>
<ol>
<li><strong>限制树的复杂度</strong>：$\Omega$函数对树的节点数和节点上预测值$\sum^T_{j=1}w_j^2$的平方和具有惩罚。除此之外，我们通常在终止条件上增加一条：树的深度。</li>
<li><strong>采样</strong>：训练每个树的时候，只使用一部分样本。</li>
<li><strong>列采样</strong>：即训练每个树的时候，只使用一部分特征。这里是$xgboost$的创新，它将随机森林思想引入。</li>
<li><strong>$Shrinkage$</strong>:进一步惩罚$\{w_j\}^T_1$,设定学习率$\epsilon$，防止过拟合。</li>
<li><strong>$Early stop$</strong>：因为GBDT的可叠加性，我们使用的模型不一定是最终的$ensemble$，而是根据测试集的情况，选择使用前若干棵树。</li>
</ol>
<hr>
<p><strong>参考链接：</strong></p>
<ol>
<li><a href="https://arxiv.org/pdf/1603.02754v1.pdf" target="_blank" rel="noopener">XGBoost: A Scalable Tree Boosting System</a></li>
<li><a href="http://xgboost.readthedocs.io/en/latest/" target="_blank" rel="noopener">xgboost</a></li>
<li><a href="http://djjowfy.com/2017/08/01/XGBoost%E7%9A%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">xgboost原理</a></li>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=xgboost%20%E7%BC%BA%E5%A4%B1%E5%80%BC" target="_blank" rel="noopener">知乎</a></li>
<li><a href="https://www.zybuluo.com/yxd/note/611571" target="_blank" rel="noopener">GBDT算法原理深入解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29765582" target="_blank" rel="noopener">机器学习-一文理解GBDT的原理-20171001</a></li>
<li><a href="http://www.flickering.cn/category/machine_learning/" target="_blank" rel="noopener">火光摇曳</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[从二阶泰勒展开（Xgboost）推导GBDT]]>
    
    </summary>
    
      <category term="GBDT" scheme="http://yoursite.com/tags/GBDT/"/>
    
      <category term="xgboost" scheme="http://yoursite.com/tags/xgboost/"/>
    
      <category term="梯度提升树" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E6%A0%91/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[说说生成模型与判别模型]]></title>
    <link href="http://yoursite.com/2018/03/09/%E8%AF%B4%E8%AF%B4%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/09/说说生成模型与判别模型/</id>
    <published>2018-03-09T14:16:06.000Z</published>
    <updated>2018-03-10T05:32:46.367Z</updated>
    <content type="html"><![CDATA[<p>本文主要是对<a href="https://www.zhihu.com/question/20446337" target="_blank" rel="noopener">知乎相关问题</a>的总结</p>
<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><hr>
<p>监督学习的任务就是学习一个模型，应用这一个模型，对给定的输入预测相应的输出。这个模型的一般形式为决策函数：$Y=f(X)$或者条件概率分布：$P(Y|X)$</p>
<p>监督学习方法又可以氛围生成方法和判别方法。所学到的模型分别称为生成模型和判别模型。</p>
<h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h3><p>书上的话：生成方法由数据学习<strong>联合概率分布P(X,Y)</strong>，<strong>然后</strong>求出<strong>条件概率分布$P(Y|X)$</strong>作为预测模型，即生成模型：$P(Y|X)={P(X,Y)\over P(X)}$</p>
<p>这样的方法称为生成方法，是因为<strong>模型表示了$X,Y$的生成关系</strong>。典型的<strong>生成模型</strong>有：<em>朴素贝叶斯法</em>、<em>隐马尔科夫模型、混合高斯模型、AODE、Latent Dirichlet allocation（unsup）、Restricted Boltzmann Machine</em></p>
<p>生成模型，就是生成（<strong>数据de分布</strong>）的模型，关注的是抓取样本的分布特征，通过建立每个类别的特征分布，最终建立很多类别模型（一般有多少类就有多少个），最后比较结果选择最优。生成模型输入$X$与输出$Y$之间<strong>没有因果关系</strong>。</p>
<h3 id="判定模型"><a href="#判定模型" class="headerlink" title="判定模型"></a>判定模型</h3><p>书上的话：判别方法由数据直接学习决策函数$f(x)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别方法关心的是对给定的输入$X$应该预测什么样的输出$Y$。典型的判别方法包括：<em>kNN，感知机，决策树，逻辑回归，最大熵模型，SVM，提升方法，条件随机场，神经网络等</em>。</p>
<p>判别模型，就是判别（<strong>数据输出量</strong>）的模型，直接采用<strong>输入特征</strong>去预测输出，或者说条件概率。判定模型只有一个模型，$X$往里面丢，$label$就出来了。判别模型输入$X$与输出$Y$之间<strong>有因果关系</strong></p>
<h2 id="用起来？"><a href="#用起来？" class="headerlink" title="用起来？"></a>用起来？</h2><hr>
<h3 id="生成模型-1"><a href="#生成模型-1" class="headerlink" title="生成模型"></a>生成模型</h3><p>优点：</p>
<p>1.生成模型给出的是<strong>联合分布$P(\hat x,\hat c)$</strong>，不仅能够由联合分布计算条件分布$P(\hat c|\hat x)$（反之不行），还可以给出其他信息，比如可以使用$P(\hat x)=\sum^k_{i=1}P(\hat x|\hat c_i)P(\hat c_i)$来计算边缘分布$P(\hat x)$。如果一个输入样本的边缘分布$P(\hat x)$很小的话，那么可以认为学处的这个模型可能不太适合对这个样本进行分类，分类效果可能会不好，这技术里所谓的$outlier detection$。</p>
<p>2.生成模型收敛速度比较快，即当样本数量较多时，生成模型能更快地收敛于真实模型。<br>3.生成模型能够应付存在隐变量的情况，比如混合高斯模型就是含有隐变量的生成方法。</p>
<p>4.生成模型所需计算资源是更少的，大部分情况下只要做统计计数就可以获得模型</p>
<p>缺点：</p>
<p>1.实践中多数情况下判别模型效果更好</p>
<h3 id="判别模型"><a href="#判别模型" class="headerlink" title="判别模型"></a>判别模型</h3><p>优点：</p>
<p>1.直接面对预测，准确率往往较生成模型高</p>
<p>2.由于直接学习$P(\hat c|\hat x)$而不需要求解类别条件概率，所以<strong>允许我们对输入进行抽象</strong>（比如降维、构造等），从而能够<strong>简化学习问题</strong>。</p>
<p>缺点：</p>
<p>1.判别模型所需资源更多，因为判别模型必须靠误差梯度下降法来获得模型，训练所需时间要多很多。</p>
<h2 id="过拟合："><a href="#过拟合：" class="headerlink" title="过拟合："></a>过拟合：</h2><hr>
<h3 id="生成模型-2"><a href="#生成模型-2" class="headerlink" title="生成模型"></a>生成模型</h3><p>‘‘没有考虑正则化很简单，因为他们<strong>很少过拟合</strong>’’。生成模型学习$X,Y$的联合概率分布$P(X,Y)$，直接学习的就是数据的分布，从整个数据的整体着手，<strong>很少会出现过拟合</strong>。</p>
<p>基本上属于<strong>高偏差/低方差</strong>分类器，<strong>当样本数量小于特征数量或样本数量不足时</strong>，应选用这种模型</p>
<h3 id="判别模型-1"><a href="#判别模型-1" class="headerlink" title="判别模型"></a>判别模型</h3><p>判别模型应当有<strong>正则化过程</strong>，因为是直接生成$f(x)$或者$p(y|x)$，所以很容易比较$y$跟$f(x)$的关系，按照现有数据照葫芦画瓢来判别，<strong>容易过拟合</strong>，所以正则化便有存在的意义。</p>
<p>基本上属于<strong>低偏差/高方差</strong>分类器，容易过拟合，需要正则项。<strong>数据量充足时</strong>选用判别模型</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>随着训练集的增大，<strong>低偏差/高方差</strong>分类器（判别模型）相对于<strong>高偏差/低方差</strong>分类器（生成模型）准确率高，因为随着数据量的增大，现有训练集数据的分布更接近于真实分布，此时生成模型优势变小，同时生成模型不能提高足够的准确率，此时，判别模型优势更大。</p>
<p>举个例子：</p>
<p>当一份分类数据的特征维度大于样本数量时。如果采用判别模型，极端情况下每条样本都有唯一的特征（或特征组合），此时如果正则化不够给力，那么该判别模型将极大限度拟合<strong>当前</strong>数据，训练集AUC可能将近1，那么就可能得到训练数据上准确率100%，测试数据准确率不如XJB猜的模型。</p>
]]></content>
    <summary type="html">
    <![CDATA[说道说道生成模型与判别模型在定义与特点上的不同]]>
    
    </summary>
    
      <category term="生成模型" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="判别模型" scheme="http://yoursite.com/tags/%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="模型" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2017 CCF 大数据竞赛Top4%]]></title>
    <link href="http://yoursite.com/2018/03/03/2017-CCF-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9BTop4/"/>
    <id>http://yoursite.com/2018/03/03/2017-CCF-大数据竞赛Top4/</id>
    <published>2018-03-03T14:58:29.000Z</published>
    <updated>2018-03-25T04:41:07.536Z</updated>
    <content type="html"><![CDATA[<h1 id="2017-CCF-大数据比赛记录（首赛）"><a href="#2017-CCF-大数据比赛记录（首赛）" class="headerlink" title="2017 CCF 大数据比赛记录（首赛）"></a>2017 CCF 大数据比赛记录（首赛）</h1><p>此次是在CCF平台与天池平台联合举办的大数据比赛，题目是：商场中精确定位用户所在店铺，主办方是蚂蚁金服。我和朋友两个人都是第一次参加这种大数据比赛，也算一步一个坑走了过来…线下赛最终经过反作弊筛选后是前100，共有2845支队伍。最后因为我俩临近期末考试，比赛也就就此结束了。</p>
<h1 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h1><p>给出用户在商场使用手机支付时所采集到的信息，包括用户信息，店铺信息，商场信息等，要求预测给出上述信息后精准预测用户所在店铺。具体给出的数据表可以点击<a href="https://tianchi.aliyun.com/competition/information.htm?spm=5176.100067.5678.2.3bb01226n9sWID&amp;raceId=231620" target="_blank" rel="noopener">这里</a>来看。</p>
<h1 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h1><ol>
<li>问题初看是多分类问题，但是如果直接处理的话$label$上千个。仔细观察题目可以发现， 不同商场里面的商店相互独立，所以这里考虑为每一个商场建立一个独立的预测模型。</li>
<li>WiFi信息信息量最大，为主要信息。但是所给WiFi信息繁杂不规范，给WiFi信息找到合理的处理模式至关重要（WiFi指纹）。</li>
<li>如何挖掘WiFi隐含信息，并建立其与$label$之间的关联（具体WiFi id、信号强度、连接与否）至关重要。</li>
<li>WiFi信息中有比较稳定的WiFi（商店自己的WiFi），有用户的个人热点，还有各种公共WiFi（CMCC之类的）。这里讲后两者当做是不稳定WiFi，或者说是噪音WiFi，预测时过滤掉</li>
<li>许多记录WiFi信息缺失，将此作为异常值直接删除（因为总数据量大，单条数据影响不大，WiFi信息又为最重要的信息）</li>
<li>不同商铺的经纬、WiFi信息有大量重合，说明商场存在多楼层问题，并且单单依靠原始WiFi信息无法全面对楼层进行区分。</li>
<li>按照商场划分模型后，每个商场还是有几十上百个$label$，可以多分类，或者二分类构造多分类。（因为$label$多，二分类构造多分类会遇到$label$不均衡的问题，需依靠采样来解决）</li>
<li>百万数据，训练时间成本太高，需要在特征工程、反复验证时减小时间成本。（前期用$LR$模型试错）</li>
<li>也算带有时间序列，如何构造可靠的线下验证集</li>
<li>顾客数据训练集与预测集交集仅为三分之一，顾客特征是否为噪音（我们尝试过顾客特征空值填充、保留，取顾客有交集的单独训练，效果均不好）</li>
</ol>
<h1 id="我们的具体操作"><a href="#我们的具体操作" class="headerlink" title="我们的具体操作"></a>我们的具体操作</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><ul>
<li>删除公共WiFi：如果一个WiFi在一个以上商场出现或者在某个商场覆盖率超过一定范围，那么可以断定此WiFi为噪音信息</li>
<li>删除移动热点或者出现次数较少的WiFi：如果一个wifi出现次数少于某个阈值或者出现时间仅有一天，那么可以断定次WiFi为噪音信息</li>
<li>训练集和测试集WiFi取交集，因为对于以后要构建的WiFi指纹</li>
<li>删除WiFi信息为空的记录</li>
<li>$GPS$离群点的删除</li>
<li>定义<strong>不同等级</strong>稳定WiFi列表（不同等级原因某些特征防止维度爆炸），WiFi出现总次数超过一定阈值或者频率前200</li>
<li>字典：shop历史WiFi</li>
</ul>
<h2 id="经纬度信息"><a href="#经纬度信息" class="headerlink" title="经纬度信息"></a>经纬度信息</h2><p>该题目给了两种经纬度信息店铺经纬度和购买发生时候的经纬度（预测集只有后者）。两种经纬度理论上差距应该很小，实际差距很大。单独利用经纬度信息训练的结果并不理想，印象中只有70%多一点。</p>
<ul>
<li>对经纬度数值做了泛化（精确小数点位数），印象中最后的粒度可能在10米左右</li>
<li>$L1、L2$距离，在商场中随意选择一个点做基准，经纬度到这个点的距离</li>
<li>经纬度聚类、以商铺经纬为质心聚类，然后哑编码（没有提升，后来没用）</li>
</ul>
<h2 id="时间特征的处理"><a href="#时间特征的处理" class="headerlink" title="时间特征的处理"></a>时间特征的处理</h2><ul>
<li>饭点指示器（万分位的提升）</li>
<li>早晨深夜指示器，因为这两种店铺可能比较固定</li>
</ul>
<h2 id="用户特征"><a href="#用户特征" class="headerlink" title="用户特征"></a>用户特征</h2><p>构造的所有的用户特征在我们这都是坑，一是因为训练集、预测集用户交集只有$1/3$左右，我们尝试过空值填充、空值保留、只保留交集部分用户特征、对交集部分用户单独训练预测…均是强力的反向上分特征。另一个原因可能是，每个用户在数据统计量均不足，没有统计意义，所以这就类似于$ID$类特征，妥妥没有现实意义的过拟合特征。</p>
<ul>
<li><del>用户购买力</del></li>
<li><del>用户常去商店</del></li>
<li><del>用户与WiFi相关特征</del></li>
</ul>
<h2 id="WiFi特征"><a href="#WiFi特征" class="headerlink" title="WiFi特征"></a>WiFi特征</h2><p>WiFi特征是最为重要的特征，我们构建的如下的WiFi特征</p>
<h3 id="当前记录连接到的最强WiFi"><a href="#当前记录连接到的最强WiFi" class="headerlink" title="当前记录连接到的最强WiFi"></a>当前记录连接到的最强WiFi</h3><p>仅用这一个特征采取规则预测准确率也可达到80%，是个强特。哑编码。</p>
<h3 id="记录中稳定WiFi的数量"><a href="#记录中稳定WiFi的数量" class="headerlink" title="记录中稳定WiFi的数量"></a>记录中稳定WiFi的数量</h3><h3 id="商场WiFi原点"><a href="#商场WiFi原点" class="headerlink" title="商场WiFi原点"></a>商场WiFi原点</h3><p>根据商场稳定WiFi（等级频率前50）建立一个基准点，计算每条数据到基准点的距离（离散化之后），没有的稳定WiFi按照强度为-99处理。</p>
<h3 id="WiFi指纹"><a href="#WiFi指纹" class="headerlink" title="WiFi指纹"></a>WiFi指纹</h3><p>根据商场稳定WiFi（等级频数大于20），训练集、预测集上下$concat$将所有WiFi id展开为特征，值为当前记录对应WiFi的强度，将强度离散化（粒度为10）.</p>
<h3 id="WiFi评分（最后仅用于规则）"><a href="#WiFi评分（最后仅用于规则）" class="headerlink" title="WiFi评分（最后仅用于规则）"></a>WiFi评分（最后仅用于规则）</h3><p>遍历数据建立嵌套字典$WiFi_score$，一层$key$为WiFi id，二层$key$为一层WiFi出现过的店铺，二层$val$为历史上该WiFi在该店铺强度的中位数。打分，对于每条数据的稳定WiFi信息，遍历嵌套字典$WiFi_score$，用打分函数对每条WiFi出现过的店铺打分。分数结果最高的直接作为结果。打分函数如下：</p>
<script type="math/tex; mode=display">f=1-tanh({|power_{now}-power_{middle}|\over k})</script><p>其中：</p>
<p>$tanh={e^x-e^{-x}\over e^x+e^{-x}}$</p>
<p>$power_{now}$表示当前记录中当前WiFi强度</p>
<p>$power_{middle}$表示嵌套字典中当前WiFi对各商店的强度中位数</p>
<p>$k$为参数，最后确定值为2</p>
<p>仅仅用该种规则，不用机器学习模型，精度就可以达到87%+（还是89%+来着）。但是当时将所得结果转化为特征加入模型训练，分数强力掉了一波。不用说，<strong>这里用了训练集构造的规则结果当特征继续加入训练集训练当然会造成$label leak$，也就是强力过拟合。</strong></p>
<p>遗憾的是，当时没考虑采用滑动窗口，更没有使用候选集，这个特征就放弃了…如果采用滑动窗口，在特征采取区间构造嵌套字典$WiFi_score$，打分结果加在训练区间的特征，结果应该不会差。</p>
<p>如果在滑动窗口的基础上，采用候选集（甚至可以用这个打分函数构造候选集），并把分数当做该条记录对候选商店的特征，绝对会是个强力特征（这里其实可以理解为类条件概率）</p>
<h3 id="WiFi-id组合的最长公共子串"><a href="#WiFi-id组合的最长公共子串" class="headerlink" title="WiFi id组合的最长公共子串"></a>WiFi id组合的最长公共子串</h3><p>典型看起来巧妙没有卵用系列</p>
<h2 id="xgb构造特征组合"><a href="#xgb构造特征组合" class="headerlink" title="xgb构造特征组合"></a>xgb构造特征组合</h2><p>用$model.apply()$返回叶子节点$index$构造特征。注意此部分一定要划分数据集，即一部分数据用于生成特征，另一部分数据集用于加入该部分生成特征并训练。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是比赛用到的、或者有代表性值得拿出来说的特征。这里发现其实我们的特征并不多，其实我们比赛时候尝试构造过远远比这多得多的特征，只是因为效果或者训练时间的原因，最后筛选剩这些。挖空心思构造各种想法复杂、实现困难、强力掉分的反向特征实在是能锤炼人强大的灵魂 ：）。</p>
<h3 id="滑窗的欠缺"><a href="#滑窗的欠缺" class="headerlink" title="滑窗的欠缺"></a>滑窗的欠缺</h3><ul>
<li>无法构造统计类特征，构造了会造成过拟合</li>
<li>训练集过大时间成本过高</li>
<li>既然也是时间序列，信息或多或少有时效性（比如WiFi）</li>
</ul>
<h3 id="候选集的欠缺"><a href="#候选集的欠缺" class="headerlink" title="候选集的欠缺"></a>候选集的欠缺</h3><ul>
<li>无法构造联合特征，商店-WiFi，商店-经纬度等等</li>
<li>完全丢弃了任何商店特征，包括特别重要的统计特征</li>
</ul>
<p>总之，这两种的欠缺也早早为我们的特征工程确定了天花板，也大大限制了我们特征的提取，少了这两项能够造的有效特征数量至少少了70%</p>
<h1 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h1><p>这里说一下我们实际的数据集划分，在最后给出可能的改进。</p>
<p>这是个时间相关的问题，而且数据量比较大，就放弃了分层$k$折交叉，我们选取一个周作为本地验证集</p>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>最开始我们用的是$xgboost$的多分类模型，分商场进行预测，效果一般。然后转向使用二分类实现多分类，提升显著。具体为每次将一个$label$作为正例，其他作为反例，每次输出每条记录是该正例的概率，最后以最大概率的$label$作为预测结果</p>
<h2 id="二分类-amp-样本不均衡"><a href="#二分类-amp-样本不均衡" class="headerlink" title="二分类&amp;样本不均衡"></a>二分类&amp;样本不均衡</h2><p>每次有将近100个$label$每次只将一个当做正例，正负样本比会非常小，会导致时间成本过长，精度下降，需要靠采样解决。</p>
<p>我们直接放弃了上采样跟随机下采样，前者会加大时间成本后者因为样本比相差悬殊，随机采样可能破坏边界样本的分布。我们直接选用了用规则下采样以保存边界有效信息，具体通过购买经纬度与店铺经纬度的距离与当前样本$top2$强度任一WiFi存在历史列表的shop的并集。这样加快了训练速度，但是精度略有损失，可能因为评价指标是$AUC$所以对样本不均衡不敏感。我们最后还是放弃了采样。</p>
<p>二分类还会造成一个问题：每次对于一个模型训练的时候，正样本平均只有小几百，负样本可能大几千甚至上万。这样正样本太少可能造成过拟合，因此我们模型部分着重调整了泛化部分的参数。</p>
<h2 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h2><p>xgb的模型参数就常用的那几个：</p>
<p><img src="/2018/03/03/2017-CCF-大数据竞赛Top4/xgb参数.jpg" alt=""></p>
<h3 id="1、eta-默认0-3"><a href="#1、eta-默认0-3" class="headerlink" title="1、eta[默认0.3]"></a>1、eta[默认0.3]</h3><p>和GBM中的 learning rate 参数类似。 通过减少每一步的权重，可以提高模型的鲁棒性。 典型值为0.01-0.2。</p>
<h3 id="2、min-child-weight-默认1"><a href="#2、min-child-weight-默认1" class="headerlink" title="2、min_child_weight[默认1]"></a>2、min_child_weight[默认1]</h3><p>建立每个模型所需要的最小样本数。决定最小叶子节点样本权重和。 和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小<em>样本权重的和</em>，而GBM参数是最小<em>样本总数</em>。 这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。 但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。</p>
<h3 id="3、max-depth-默认6"><a href="#3、max-depth-默认6" class="headerlink" title="3、max_depth[默认6]"></a>3、max_depth[默认6]</h3><p>和GBM中的参数相同，这个值为树的最大深度。 这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。 需要使用CV函数来进行调优。 典型值：3-10</p>
<h3 id="4、max-leaf-nodes"><a href="#4、max-leaf-nodes" class="headerlink" title="4、max_leaf_nodes"></a>4、max_leaf_nodes</h3><p>树上最大的节点或叶子的数量。 可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n2个叶子。 如果定义了这个参数，GBM会忽略max_depth参数。</p>
<h3 id="5、gamma-默认0"><a href="#5、gamma-默认0" class="headerlink" title="5、gamma[默认0]"></a>5、gamma[默认0]</h3><p>在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。 这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。</p>
<h3 id="6、max-delta-step-默认0"><a href="#6、max-delta-step-默认0" class="headerlink" title="6、max_delta_step[默认0]"></a>6、max_delta_step[默认0]</h3><p>这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。 通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。 这个参数一般用不到，但是你可以挖掘出来它更多的用处。</p>
<h3 id="7、subsample-默认1"><a href="#7、subsample-默认1" class="headerlink" title="7、subsample[默认1]"></a>7、subsample[默认1]</h3><p>和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。 减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。 典型值：0.5-1</p>
<h3 id="8、colsample-bytree-默认1"><a href="#8、colsample-bytree-默认1" class="headerlink" title="8、colsample_bytree[默认1]"></a>8、colsample_bytree[默认1]</h3><p>和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。 典型值：0.5-1</p>
<h3 id="9、colsample-bylevel-默认1"><a href="#9、colsample-bylevel-默认1" class="headerlink" title="9、colsample_bylevel[默认1]"></a>9、colsample_bylevel[默认1]</h3><p>用来控制树的每一级的每一次分裂，对列数的采样的占比。 我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。</p>
<h3 id="10、lambda-默认1"><a href="#10、lambda-默认1" class="headerlink" title="10、lambda[默认1]"></a>10、lambda[默认1]</h3><p>权重的L2正则化项。(和Ridge regression类似)。 这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。</p>
<h3 id="11、alpha-默认1"><a href="#11、alpha-默认1" class="headerlink" title="11、alpha[默认1]"></a>11、alpha[默认1]</h3><p>权重的L1正则化项。(和Lasso regression类似)。 可以应用在很高维度的情况下，使得算法的速度更快。</p>
<h3 id="12、scale-pos-weight-默认1"><a href="#12、scale-pos-weight-默认1" class="headerlink" title="12、scale_pos_weight[默认1]"></a>12、scale_pos_weight[默认1]</h3><p>在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。</p>
<h3 id="真正调参方法"><a href="#真正调参方法" class="headerlink" title="真正调参方法"></a>真正调参方法</h3><ul>
<li>选择较高的<strong>学习速率(learning rate)</strong>。一般情况下，学习速率的值为0.1。但是，对于不同的问题，理想的学习速率有时候会在0.05到0.3之间波动。选择<strong>对应于此学习速率的理想决策树数量</strong>。</li>
<li>对于给定的学习速率和决策树数量，进行<strong>决策树特定参数调优</strong>(max_depth, min_child_weight, gamma, subsample, colsample_bytree)。</li>
<li>xgboost的<strong>正则化参数</strong>的调优。(lambda, alpha)。这些参数可以降低模型的复杂度，从而提高模型的表现。</li>
<li>降低学习速率，确定理想参数。</li>
</ul>
<h3 id="实际上比赛的调参"><a href="#实际上比赛的调参" class="headerlink" title="实际上比赛的调参"></a>实际上比赛的调参</h3><p>因为数据量巨大，样本充足，所以实际上参数不是太差的话对结果影响不是很大。况且大的数据量调参时间成本太高，而且这个比赛自始至终不是一个分类器，90+的商场每个商场有多少个$label$就有多少个分类器，总共上千个不同分类器，也不可能找出每个分类器最适合的参数。因此本次比赛只是在刚开始时调整了一下树的深度，最后的时候调整了一下过拟合的参数。</p>
<h2 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h2><p>最后我们取了$0.65xgb+0.35lgb$简单的加权融合，融合方法是直接把二分类生成的概率加权相加，选出概率最大的当做$label$。</p>
<p>其实可以再融合上多分类，提高模型融合的多样性，但是因为我们没分滑窗，训练时间巨长，就没再添加。</p>
<p>本次比赛不可能$stacking$，就像不可能$CV$一样，训练一次时间都受不了，更别说反复多次。</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>这次比赛成绩不算好，但第一次正式参赛，通过比赛收获了很多，一整套流程熟悉了一遍，对模型、特征的理解也深了好多。我跟朋友两个一步一个坑，摸着石头过河，心情大起大落也是锻炼了心态…最后初赛要截止时候，我们还在复赛线边缘徘徊，眼看着自己慢慢掉出复赛线，反复讨论着各种可能，尝试构造各种复杂但看起来有意义的特征，每次连夜实现，怀着希望入睡，第二天都会被反向上分现实打脸。记得第一次掉出前100时候，我俩彻夜讨论到凌晨五点出了一套方案，从绝望到满怀希望，实际上上第二天还是究极反向上分，又坐了一次过山车：）（其实现在想想那套方案是明显的$label leak$）。</p>
<p>现在想想，这次比赛主要差在了套路经验上，没能构造滑窗和候选集严重限制了特征的构造，几乎所有统计特征、交叉特征、先验后延特征都无法构造，有效特征数量至少少了70%。特别是候选集，之前闻所未闻，各种地方也了解不到，后来才知道，这种方法可能从之前摩拜比赛大佬们一路传承了下来…</p>
<p>对样本特征的理解差也导致我们踩了好多坑。在一开始对数据分布、统计特征的构造不清楚导致我们训练时间成本巨大。现在想想当时构造的好多看起来有效的特征其实都是明显的$label leak$（先从当前数据提取特征，再用当前数据训练模型），这次比赛过后对标签泄露、过拟合是印象深刻了。</p>
]]></content>
    <summary type="html">
    <![CDATA[比赛的详细记录]]>
    
    </summary>
    
      <category term="大数据竞赛" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="天池" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B1%A0/"/>
    
      <category term="CCF" scheme="http://yoursite.com/tags/CCF/"/>
    
      <category term="wifi定位" scheme="http://yoursite.com/tags/wifi%E5%AE%9A%E4%BD%8D/"/>
    
      <category term="比赛" scheme="http://yoursite.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拉格朗日对偶性]]></title>
    <link href="http://yoursite.com/2018/03/03/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    <id>http://yoursite.com/2018/03/03/拉格朗日对偶性/</id>
    <published>2018-03-03T14:49:03.000Z</published>
    <updated>2018-03-04T08:04:05.776Z</updated>
    <content type="html"><![CDATA[<h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><p>​    假设$f(x), c_i(x), h_j(x)$是定义在<strong>$R^n$</strong>上面的连续可微函数，考虑约束最优化问题</p>
<script type="math/tex; mode=display">\min_{x\in R^n}f(x)</script><script type="math/tex; mode=display">s.t.\ c_i(x)\le0,\ i=1,2,…,k</script><script type="math/tex; mode=display">h_j(x)=0,\ j=1,2,…,l ​</script><p>​    称此约束最优化问题为原始最优化问题或原始问题。</p>
<p>​    首先，引进广义拉格朗日函数</p>
<script type="math/tex; mode=display">L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)</script><p>​    这里，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i\ge0$.</p>
<p>​    考虑函数(<strong><em>注意：此时$L(x,\alpha,\beta)$的变量是$\alpha_i\beta_j$</em></strong>)：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script><p>​    这里下标$P(Primal)$表示原始问题.对于此函数（关于$\alpha,\beta$的函数，$x$是常量），经过我们优化（不管什么方法），确定$\alpha,\beta$的值，就可以得到$L(x,\alpha,\beta)$的最大值，因为此时$\alpha,\beta$已经确定，显然最大值<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script>就是<strong><em>只和$x$有关的函数</em></strong></p>
<p>​    下面通过$x$是否绵竹约束条件两方面来分析这个函数：</p>
<p>​        1.考虑某个$x$违反了原始的约束，即$c_i\gt0$或者$h_j\neq0$，那么：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=\infty</script><p>​        2.考虑$x$满足原始的约束，则：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)]=f(x)</script><p>​    注意最大化确定$\alpha,\beta$的过程，$f(x)$就是个常量，常量的最大值显然是本身</p>
<p>​    通过上面两条分析可以得出：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\begin{cases}f(x),\ {x满足原始问题约束}\\+\infty,\ {其他}\\\end{cases}</script><p>​    那么<strong>在满足约束的条件下：</strong></p>
<script type="math/tex; mode=display">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script><p>​    即$\min_x\Theta_P(x)$与原始优化问题等价，所以常用$\min_x\Theta_P(x)$来代表原始问题，定义原始问题的最优值：</p>
<script type="math/tex; mode=display">p^*=\min_x\Theta_P(x)</script><p>​    原始问题讨论到这里，总结：重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题。</p>
<h2 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h2><p>​    定义<strong>关于$\alpha,\beta$的函数</strong>：</p>
<script type="math/tex; mode=display">\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)</script><p>​    注意上面等式<strong>右边是关于$x$的函数最小化,$x$确定之后，最小值就只与$\alpha,\beta$有关，所以此时是一个关于$\alpha,\beta$的函数</strong></p>
<p>​    再考虑极大化$\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$，即：</p>
<script type="math/tex; mode=display">\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)</script><p>​    这就是原始问题的对偶问题，再将原始问题写出来：</p>
<script type="math/tex; mode=display">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script><p>​    从形式上可以看出堆成，只不过<strong>原始问题先固定$L(x,\alpha,\beta)$中的$x$,优化参数$\alpha,\beta$，再优化$x$；而对偶问题是先固定$\alpha,\beta$，再优化$x$，然后再确定参数$\alpha,\beta$</strong></p>
<p>​    定义对偶问题的最优值：</p>
<script type="math/tex; mode=display">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)</script><h2 id="原始问题与对偶问题之间的关系"><a href="#原始问题与对偶问题之间的关系" class="headerlink" title="原始问题与对偶问题之间的关系"></a>原始问题与对偶问题之间的关系</h2><p>​    若原始问题和对偶问题都有最优值，则有$Min-Max$不等式：</p>
<script type="math/tex; mode=display">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)\le\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=p^*</script><p>​    当$L(x,\alpha,\beta)$对$x$为凸函数，对$\alpha,\beta$为凹函数，以上等号成立。而$L(x,\alpha,\beta)$对$\alpha,\beta$为天然凹函数，因此只要$L(x,\alpha,\beta)$对$x$为凸函数，等号便成立</p>
<p>​    证明：一个式子的最大值永远大于等于这个式子的最小值，哪怕是这个式子最小的最大值与最大的最小值相比（瘦死的骆驼比马大）。</p>
]]></content>
    <summary type="html">
    <![CDATA[对拉格朗日对偶性的理解]]>
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="拉格朗日对偶" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2017-JDD京东金融算法大赛12th解决方案]]></title>
    <link href="http://yoursite.com/2018/03/03/2017-JDD%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B12th%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/03/03/2017-JDD京东金融算法大赛12th解决方案/</id>
    <published>2018-03-03T04:08:59.000Z</published>
    <updated>2018-03-25T04:41:32.103Z</updated>
    <content type="html"><![CDATA[<h1 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h1><p>训练数据包含2017-04-30日之前270天之内若干店铺的每日订单量、销售额、顾客数、评价数、广告费用等数据，下架时间在2017-04-30之后或者未下架的商品数据，以及这些店铺2016年6月-2017年1月每月末后90天内的销售额。</p>
<p>通过竞赛数据中店铺过往的销售记录，商品信息，商品评价，以及广告费用等信息来建立预测模型，预测店铺未来90天内的销售额。</p>
<h1 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h1><ul>
<li>这是个时间序列问题，时间滑窗的选择是关键点。</li>
<li>数据是真实数据，难免会存在刷单、特殊节日、店铺停业等等特殊情况</li>
<li>不同店铺销量波动水平可能不同</li>
<li>特征的选择按照商品特征、订单特征、评价特征、交叉特征、销售额和下架分别构造特征</li>
</ul>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="刷单行为"><a href="#刷单行为" class="headerlink" title="刷单行为"></a>刷单行为</h2><p>通过DEA发现存在刷单行为，通过’&gt;本月销售中位数*10（根据线上选出的阈值）’判断删除该日订单</p>
<h2 id="活动促销"><a href="#活动促销" class="headerlink" title="活动促销"></a>活动促销</h2><p>双十一和618（因为双11不存在最终训练集里面，所以不用考虑训练集的影响。但是6.18在预测集里面，这里考虑用双11修正618的销量。具体挑出11月份销量波动大的店铺，计算修正系数，预测完相应店铺称该修正系数）</p>
<h2 id="特殊月份"><a href="#特殊月份" class="headerlink" title="特殊月份"></a>特殊月份</h2><p>过年、情人节等，EDA发现影响不大，故不作考虑</p>
<h2 id="下架商品"><a href="#下架商品" class="headerlink" title="下架商品"></a>下架商品</h2><p>某些店铺会在短时间内下架大量的商品</p>
<h1 id="特征部分"><a href="#特征部分" class="headerlink" title="特征部分"></a>特征部分</h1><p>商品、订单、评价（取平均的时候是按照有效评论日期取平均）、交叉特征、销售以及下架特征。（主要以本月为主部分特征加入前几个月的相关统计特征）</p>
<p>后来发现销售额有关特征重要性很强，于是又添加了额外的钱有关的本月统计有关特征（本月后三、二、一周）</p>
<p>特征部分实在是无法回忆清楚了，这个比赛来来回回构建了许多类似特征，特征的增减也是根据线上表现大刀阔斧地一群一群增删。下面写一下大致思路，不是所有特征都构建三个月的统计特征，印象中总销售、总订单量之类的总量特征会添加上月、上上月、上上上月的总量统计特征以及三月平均特征。平均数特征方面几乎没有构造统计特征。</p>
<h3 id="商品特征"><a href="#商品特征" class="headerlink" title="商品特征"></a>商品特征</h3><ul>
<li>在售总商品数</li>
<li>平均每个商品的订单量</li>
<li>平均每个商品的实际销量</li>
<li>平均每个商品的退货订单数</li>
<li>未售商品占总商品的比例</li>
</ul>
<h3 id="订单特征"><a href="#订单特征" class="headerlink" title="订单特征"></a>订单特征</h3><ul>
<li>总销售金额</li>
<li>平均每个订单销售金额</li>
<li>总优惠金额</li>
<li>平均每笔订单优惠金额</li>
<li>总优惠金额占总销售金额比</li>
<li>总订单量</li>
<li>总退货订单量</li>
<li>总实际订单量</li>
<li>总退货订单金额</li>
<li>退货金额占总销售额金额的比</li>
<li>总实际销售金额</li>
<li>平均每笔订单实际销售金额</li>
<li>总顾客数</li>
<li>平均每个顾客的订单量</li>
<li>平均每个顾客的购买金额</li>
<li>平均每个顾客的退货订单数</li>
<li>平均每个顾客的退货金额</li>
<li>总优惠笔数</li>
<li>总优惠金额占总退货金额比例</li>
<li>平均每笔订单总优惠金额占总退货金额比例</li>
<li>平均每笔优惠金额</li>
<li>平均销售金额增长率（每个月和前一个月算增长率，所有增长率取平均）</li>
<li>平均订单量增长率</li>
<li>平均退货订单增长率</li>
<li>平均退货金额增长率</li>
</ul>
<h3 id="评价特征（取平均的时候是按照有效评论日期取平均）"><a href="#评价特征（取平均的时候是按照有效评论日期取平均）" class="headerlink" title="评价特征（取平均的时候是按照有效评论日期取平均）"></a>评价特征（取平均的时候是按照有效评论日期取平均）</h3><ul>
<li>总好评数</li>
<li>总中评数</li>
<li>总差评数</li>
<li>总评论数</li>
<li>平均好评数</li>
<li>平均中评数</li>
<li>平均差评数</li>
<li>好评率</li>
<li>差评率</li>
<li>中评率</li>
<li>平均好评率增长率</li>
</ul>
<h3 id="交叉特征"><a href="#交叉特征" class="headerlink" title="交叉特征"></a>交叉特征</h3><ul>
<li>平均每个月的充值广告费用占总销售金额比</li>
<li>平均每个月的充值广告费用占实际销售金额比</li>
<li>平均每个订单的好评率</li>
<li>平均每个订单的差评率</li>
<li>平均每个订单的好评数</li>
<li>平均每个订单的差评数</li>
</ul>
<h3 id="销售额和下架特征"><a href="#销售额和下架特征" class="headerlink" title="销售额和下架特征"></a>销售额和下架特征</h3><ul>
<li>总销售额</li>
<li>当月销售额</li>
<li>前一个月总销售金额</li>
<li>前两个月总销售金额</li>
<li>前三个月总销售金额</li>
<li>前一个周总销售金额</li>
<li>前两个周总销售金额</li>
<li>前三个周总销售金额</li>
<li>前一个月下架商品数</li>
<li>前两个月下架商品数</li>
<li>前三个月下架商品数</li>
<li>最近一周下架商品数</li>
</ul>
<p>一开始加的特征比较多，因为效果还不错吧，所以也没有根据线上去判断一下哪些特征是否有用，而且这个比赛想构建一个比较稳定的线下验证是非常困难的，因为销量波动还是比较大的，所以到最后我还没构建出合理的线下验证集，更多的时候是以线上来验证我的一些想法。根据特征的重要性来看，跟销售金额有关的特征比较强一些，某些特征重要性非常低但是我也没删除。</p>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p>这部分没什么可说的，就是这次比赛数据量较少，只有3000条，相对而言特征维度较高，模型着重调整了正则化部分，防止过拟合</p>
<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>某些店铺销量变化巨大，所以想到通过方差筛选出波动比较大的店铺，该店铺在预测完成之后单独处理，规则是，把最后一个９０天，除以每家店铺上个月的销量，再将这个值取平均，结果是２.7左右，所以这个规则就是每个店最后一个月销量×２.7，这是规则基础版，同时可以根据每个月不同销量修改参数，例如（３月×0.2+4月×０.８）*2.7。</p>
<p>另外这次比赛不同模型预测结果差异很大，模型融合效果显著稳定上分。</p>
<p>$0.2lgb+0.8xgb$</p>
]]></content>
    <summary type="html">
    <![CDATA[比赛的记录]]>
    
    </summary>
    
      <category term="大数据竞赛" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="JDD" scheme="http://yoursite.com/tags/JDD/"/>
    
      <category term="销量预测" scheme="http://yoursite.com/tags/%E9%94%80%E9%87%8F%E9%A2%84%E6%B5%8B/"/>
    
      <category term="时间序列" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
      <category term="比赛" scheme="http://yoursite.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SVM与LR的异同]]></title>
    <link href="http://yoursite.com/2018/02/19/SVM%E4%B8%8ELR%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://yoursite.com/2018/02/19/SVM与LR的异同/</id>
    <published>2018-02-19T08:54:31.000Z</published>
    <updated>2018-03-25T04:33:41.344Z</updated>
    <content type="html"><![CDATA[<p>本篇文章主要是对几篇blog以及知乎回答的总结</p>
<p>[TOC]</p>
<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><hr>
<h2 id="1-LR和SVM都是有监督分类算法"><a href="#1-LR和SVM都是有监督分类算法" class="headerlink" title="1. LR和SVM都是有监督分类算法"></a>1. LR和SVM都是有监督分类算法</h2><h2 id="2-不考虑核函数，LR和SVM都是线性分类算法"><a href="#2-不考虑核函数，LR和SVM都是线性分类算法" class="headerlink" title="2. 不考虑核函数，LR和SVM都是线性分类算法"></a>2. 不考虑核函数，LR和SVM都是线性分类算法</h2><p>他们的分类决策面都是线性的。</p>
<h2 id="3-LR和SVM都是判别模型"><a href="#3-LR和SVM都是判别模型" class="headerlink" title="3. LR和SVM都是判别模型"></a>3. LR和SVM都是判别模型</h2><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><hr>
<h2 id="1-LR和SVM本质不同来自于-Loss-Function"><a href="#1-LR和SVM本质不同来自于-Loss-Function" class="headerlink" title="1. LR和SVM本质不同来自于$Loss Function$"></a>1. LR和SVM本质不同来自于$Loss Function$</h2><ul>
<li><p>LR是$logistical loss$:</p>
<script type="math/tex; mode=display">J(\theta)=-\sum_iy_i\log(p_{\theta}(x_i))+(1-y_i)\log(1-p_{\theta}(x_i))</script><p>SVM是$hinge loss$：</p>
<script type="math/tex; mode=display">\sum^N_{i=1}[1-y_i(wx_i+b)]_++\lambda||w||^2</script></li>
<li><p>不同的$loss function$代表了不同的假设前提，也就代表了不同的分类原理</p>
<p>LR方法基于<strong>概率理论</strong>，假设样本满足$logistic$分布，然后通过极大似然估计的方法估计出参数的值</p>
<p>SVM基于<strong>几何间隔</strong>最大化原理，认为存在的最大几何间隔的分类面为最优分类面</p>
</li>
<li><p>所以，<strong>SVM只考虑分类面上的点（支持向量），而LR考虑所有点，在SVM中，在支持向量之外添加或者减少任何点都对结果没有影响，而LR每个点都会影响决策。</strong></p>
</li>
<li><p><strong>$Linear SVM$不直接依赖于数据分布，分类平面不受一类点影响</strong></p>
<p>$LR$则是受所有点影响，所以<strong>受数据本身分布影响</strong>，如果数据不同类别$strongly unbalance$，一般需要先对数据$balancing$</p>
</li>
<li><p>两种$loss function$目的都是增加对分类影响比较大的点的数据点权重，减少与分类关系比较小的数据点的权重。</p>
<p>$SVM$的处理方法是只考虑$support vectors$，也就是和分类最相关的少数点，去学习分类器。</p>
<p>$LR$则通过非线性映射，大大减小了离分类平面较远的点的权重，提高了与分类最相关的数据点的权重。（$sigmoid$函数中间比较陡峭？）</p>
</li>
</ul>
<h2 id="2-LR可以产生概率，SVM不能产生概率"><a href="#2-LR可以产生概率，SVM不能产生概率" class="headerlink" title="2. LR可以产生概率，SVM不能产生概率"></a>2. LR可以产生概率，SVM不能产生概率</h2><ul>
<li><p>LR模型的原理就是基于伯努利分布的假设推导出来的（见LR文章），所以它产生的结果代表了分成某一类的概率</p>
<p>SVM不是基于概率的假设，无法输出概率</p>
</li>
</ul>
<h2 id="3-SVM依赖数据的测度，而LR则不受影响"><a href="#3-SVM依赖数据的测度，而LR则不受影响" class="headerlink" title="3. SVM依赖数据的测度，而LR则不受影响"></a>3. SVM依赖数据的测度，而LR则不受影响</h2><ul>
<li>SVM是基于距离的，所以受测度影响；LR是基于概率的，所以不受测度影响</li>
<li>SVM需要最小化${1\over 2}||w||^2$，所以其依赖于不同维度的测度不同，如果差别较大需要做$normalization$，当然如果LR要加上正则化时，也是需要$normalization$</li>
<li>如果用到梯度下降算法，则一般都需要$feature scaling$，如果不归一化，梯度下降会很慢</li>
</ul>
<h2 id="4-SVM自带结构风险最小化，LR不带正则项则是经验风险最小化"><a href="#4-SVM自带结构风险最小化，LR不带正则项则是经验风险最小化" class="headerlink" title="4. SVM自带结构风险最小化，LR不带正则项则是经验风险最小化"></a>4. SVM自带结构风险最小化，LR不带正则项则是经验风险最小化</h2><ul>
<li>因为SVM本身就是优化${1\over 2}||w||^2$最小化的，所以其优化的目标函数本身就含有结构风险最小化，所以<strong>不需要加正则项</strong></li>
<li>LR不加正则化的时候，优化目标就是经验风险最小化，所以最后<strong>需要加入正则项</strong>，增强模型泛化能力</li>
</ul>
<h2 id="5-SVM会用核函数而LR一般不用核函数的原因"><a href="#5-SVM会用核函数而LR一般不用核函数的原因" class="headerlink" title="5. SVM会用核函数而LR一般不用核函数的原因"></a>5. SVM会用核函数而LR一般不用核函数的原因</h2><ul>
<li>SVM转化为对偶问题后，分类只需要<strong>计算与少数个支持向量的距离（原因从KKT条件最后一条理解，非支持向量不提供约束）</strong>，这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量</li>
<li>LR则是<strong>每个点都需要两两计算核函数</strong>，计算量庞大</li>
</ul>
<h2 id="6-LR和SVM在实际应用中的区别"><a href="#6-LR和SVM在实际应用中的区别" class="headerlink" title="6. LR和SVM在实际应用中的区别"></a>6. LR和SVM在实际应用中的区别</h2><ul>
<li>根据经验来看，对于小规模数据集，SVM的效果要好于LR，但是在大数据中，SVM计算复杂度收到限制，而LR因为训练简单，可以在线训练，所以经常被大量采用。</li>
<li>$Andrew NG$在课里讲过：<ol>
<li>如果$Feature$的数量很大，这时候选用$LR$或者是$Linear Kernel$的$SVM$</li>
<li>如果$Feature$的数量较小，数据量中等，用$Gaussian Kernel$的$SVM$</li>
<li>如果$Feature$的数量较小，数据量比较大，构造特征，然后同第一种</li>
</ol>
</li>
</ul>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://www.cnblogs.com/zhizhan/p/5038747.html" target="_blank" rel="noopener">止战blog</a></li>
<li><a href="http://blog.csdn.net/haolexiao/article/details/70191667" target="_blank" rel="noopener">【机器学习】Linear SVM 和 LR 的联系和区别</a></li>
<li><a href="https://www.zhihu.com/question/21704547" target="_blank" rel="noopener">SVM和logistic回归分别在什么情况下使用？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[从几个方面比较SVM与LR的异同]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="SVM" scheme="http://yoursite.com/tags/SVM/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大熵模型]]></title>
    <link href="http://yoursite.com/2018/02/17/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/02/17/最大熵模型/</id>
    <published>2018-02-17T07:41:18.000Z</published>
    <updated>2018-04-10T15:03:08.425Z</updated>
    <content type="html"><![CDATA[<p>最大熵模型($The  Maximum Entropy$，从信息论的角度来讲，就是保留了最大的不确定性，也就是让熵达到最大。当我们需要对一个时间的概率分布进行预测是，最大熵原理告诉我们所有的预测应当满足全部已知的条件，而<strong>对未知的情况不要做任何主观假设（不做主观假设这点很重要）</strong>。也就是让概率分布最均匀，预测风险最小。</p>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>熵（$Entropy$）是热力学中的概念，由香农引入到信息论中。在信息论和概率统计中，熵用来表示随机变量不确定性的度量。</p>
<p><strong>定义：</strong>设$X\in\{x_1,x_2,x_3…,x_n\}$为一个离散随机变量，其概率分布为$p(X=x_i)=p_i, i=1,2,…,n$，则$X$的熵为</p>
<script type="math/tex; mode=display">H(X)=-\sum^n_{i=1}p_i\log p_i</script><p>其中，当$p_i=0$时，定义$0\log 0=0.$</p>
<p>注意：$H(x)$依赖于$X$的分布，而与$X$的具体值无关。$H(x)$越大，表示$X$的不确定性越大。</p>
<h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p><strong>定义：</strong>设$X\in\{x_1,x_2,x_3…,x_n\}, Y\in \{y_1,y_2,…,y_m\}$为离散随机变量，在已知$X$的条件下，$Y$的条件熵$(Conditional Entropy)$可定义为</p>
<script type="math/tex; mode=display">H(Y|X)=\sum^n_{i=1}H(Y|X=x_i)=-\sum^n_{i=1}p(x_i)\sum^m_{j=1}p(y_j|x_i)\log p(y_j|x_i)</script><p>它表示已知$X$的条件下，$Y$的条件概率分布的熵对$X$的数学期望。</p>
<h2 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h2><p>最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型集合，所以，<strong>最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型</strong>。</p>
<p>假设离散随机变量$X$的概率分布是$P(X)$，则其熵是</p>
<script type="math/tex; mode=display">H(P)=-\sum_xP(x)\log P(x)</script><p>熵满足下列不等式：</p>
<script type="math/tex; mode=display">0\le H(P)\le \log |X|</script><p><strong>式中，$|X|$是$X$的取值个数，当且仅当$X$的分布式均匀分布时右边的等号成立。这就是说，当$X$服从均匀分布时候，熵最大</strong>。</p>
<p>最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息条件下，那些不确定的成分是<strong>‘等可能的’</strong>。最大熵原理通过熵最大化来表示等可能性。‘等可能性’不易操作，而<strong>熵则是可优化的数值指标</strong>。</p>
<h2 id="最大熵模型定义"><a href="#最大熵模型定义" class="headerlink" title="最大熵模型定义"></a>最大熵模型定义</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>1.最大熵原理是统计学习的一般原理，将它应用到分类就得到了最大熵模型</p>
<p>2.假设分类模型是一个条件概率分布$P(Y|X),$$X$表示输入，$Y$表示输出。这个模型表示的是对于给定的输入$X$，一条件概率$P(Y|X)$输出$Y$。</p>
<p>3.给定一个训练数据集$T$，我们的目标就是利用最大熵原理选择最好的分类模型。</p>
<script type="math/tex; mode=display">T=\{(x_1,y_1),(x_2,y_2),…(x_N,y_N)\}</script><p>4.<strong>按照最大熵原理，我们应该优先保证模型满足一致的所有约束。那么如何得到这些约束的？</strong></p>
<p>$     $<strong>思路：从训练数据$T$中抽取若干特征（<em>依靠特征函数</em>），然后<em>要求这些特征在$T$上关于经验分布的期望与他们在模型中关于$p(x,y)$的数学期望相等，这样，一个特征就对应一个约束</em>。</strong></p>
<h3 id="特征函数"><a href="#特征函数" class="headerlink" title="特征函数"></a>特征函数</h3><h4 id="特征函数的作用"><a href="#特征函数的作用" class="headerlink" title="特征函数的作用"></a>特征函数的作用</h4><p>1.用特征函数$f(x)$描述输入$x$和输出$y$之间的某一个事实。</p>
<p>2.按照最大熵原理，应该优先保证模型满足一致的所有约束。<strong>通过特征函数来定义、量化以及得到这些约束</strong>。</p>
<p>3.特征函数的出现，可以让模型有更好的<strong>泛化能力</strong>（特征函数的选取、定义特别随意）。</p>
<p>特征函数可以类比决策树对于输入$x$的处理，假设输入$x$是一个有着多个属性值的实例，决策树在一个决策点并不是对所有属性都进行考虑，这就有点提取出了特征中更有信息量的属性。</p>
<p>如何让一个线性模型（例如$LR:h_{\theta}(x)=\sigma (\theta^Tx)$  ）也有类似的功能？答案就是特征函数，让输入$X$先经过一些列特征函数的处理，变成$g(x)$再送给模型分类（如：$h_{\theta}(x)=\sigma (\theta^Tg(x))$）.</p>
<p>此外，当输入的样本可能不是数值的向量，比如文本或图片时，特征函数的功能更像是特征向量的制作。对于给定输入$X$，使用<strong>一系列定义好的特征函数$\{g(x)\}$</strong>将其转换成需要的向量形式。</p>
<h4 id="对于特征函数中‘特征’的理解"><a href="#对于特征函数中‘特征’的理解" class="headerlink" title="对于特征函数中‘特征’的理解"></a>对于特征函数中‘特征’的理解</h4><p>一般说的“特征”都是指输入的特征，而最大熵模型中的“特征”指的是输入和输出共同的特征。最大熵模型中的每个特征会有一个权重，你可以把它理解成这个特征所描述的输入和输出有多么倾向于同时出现。</p>
<p>可以以多类logistic regression为例，来感受一下两种视角的不同。在一般的视角下，每条输入数据会被表示成一个n维向量，可以看成n个特征。而模型中每一类都有n个权重，与n个特征相乘后求和再经过softmax的结果，代表这条输入数据被分到这一类的概率。在最大熵模型的视角下，<strong><em>每条输入</em>的n个“特征”与k个类别共同组成了nk个特征，模型中有nk个权重，与特征一一对应。每个类别会触发nk个特征中的n个，这n个特征中的每个特征都会触发特征函数</strong>。</p>
<h3 id="经验分布"><a href="#经验分布" class="headerlink" title="经验分布"></a>经验分布</h3><p>经验分布是指通过训练数据$T$进行统计得到的分布。我们需要考察两个经验分布，分别是$x,y$的联合经验分布，以及$x$的经验分布。其定义如下：</p>
<script type="math/tex; mode=display">\hat p(x,y)={count(x,y)\over N},\ \hat p(x)={count(x)\over N}</script><p>对于任意特征函数$f$,记$E_{\hat p}(f)$表示$f$在训练数据$T$上关于$\hat p(x,y)$的数学期望。$E_p(f)$表示$f$在模型上关于$p(x,y)$的数学期望，由于<strong>模型中$p(x,y)$是未知的，并且我们建模的目标是$p(y|x)$，因此我们利用$Bayes$定理得到$p(x,y)=p(x)p(y|x)$，<em>此时，$p(x)$还是未知的</em>，我们可以使用经验分布$\hat p(x)$对$p(x)$进行近似</strong>。按照期望的定义有：</p>
<script type="math/tex; mode=display">E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)</script><script type="math/tex; mode=display">E_p(f)=\sum_{x,y}p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>对于概率分布$p(y|x)$我们希望特征$f$的期望应该和从训练数据中的到的一样的。（<strong>我的理解：特征函数是约束的提取量化，特征函数关于经验分布的期望与关于模型的期望相等就代表一个约束</strong>）因此我们可以提出约束：</p>
<script type="math/tex; mode=display">E_{\hat p}(f)=E_p(f)</script><script type="math/tex; mode=display">\sum_{x,y}\hat p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>假设从训练数据中抽取了n个特征，相应的便有n个特征函数以及n各约束条件。</p>
<script type="math/tex; mode=display">C_i:E_p(f_i)=E_{\hat p}(f_i):=\tau_i,i=1,2,…,n</script><h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><p>给定数据集$T$，我们的目标就是根据最大上原理选择一个最优分类器，假设满足所有约束条件的模型集合为：</p>
<script type="math/tex; mode=display">C=\{P\in\pi|E_p(f_i)=E_{\hat p}(f_i),i=1,2,…,n \}</script><p>定义在条件概率分布$P(Y|X)$上的条件熵为：</p>
<script type="math/tex; mode=display">H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><p>则模型集合$C$中条件熵$H(P)$最大的模型成为最大熵模型。式中的对数为<strong>自然对数</strong>。</p>
<h2 id="最大熵模型的学习"><a href="#最大熵模型的学习" class="headerlink" title="最大熵模型的学习"></a>最大熵模型的学习</h2><p>最大熵模型的学习可以形式化为约束最优化问题。对于给定训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\}$以及特征函数$f_i(x,y), i=1,2,3,…,n$，最大熵模型的学习等价于约束最优化问题(<strong>注意自变量为$P$</strong>)：</p>
<script type="math/tex; mode=display">\max_{P\in C}\ \ \ H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">\ \ \ s.t.\ \ \ E_P(f_i)=E_{\hat P}(f_i),\ i=1,2,….,n</script><script type="math/tex; mode=display">\sum_y P(y|x)=1\ \ \ \ \ \ \ \ \ \ \ \</script><p>按照最优化习惯，将求最大值问题改写为等价的求最小值问题：</p>
<script type="math/tex; mode=display">\min_{P\in C}\ \ \ -H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">\ \ \ s.t.\ \ \ E_P(f_i)-E_{\hat P}(f_i)=0,\ i=1,2,….,n</script><script type="math/tex; mode=display">1-\sum_y P(y|x)=0\ \ \ \ \ \ \ \ \ \ \ \</script><p>引入拉格朗日乘子$w_0,w_1,w_2,…,w_n$,定义拉格朗日函数$L(P,w)$(<strong>这里注意两自变量</strong>)：</p>
<script type="math/tex; mode=display">L(P,w)=-H(p)+w_0(1-\sum_yP(y|x))+\sum^n_{i=1}w_i(E_{\hat P}(f_i)-E_P(f_i))</script><p>又：</p>
<script type="math/tex; mode=display">-H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)</script><script type="math/tex; mode=display">E_p(f)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>带入得到$L(P,w)$:</p>
<script type="math/tex; mode=display">L(P,w)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)+w_0(1-\sum_yP(y|x)\ )+\sum ^n_{i=1}w_i(\sum_{x,y}\hat p(x,y)f(x,y)-\sum_{x,y}\hat p(x,y)f(x,y)\ )</script><p>对偶最优化的原始问题是（<strong>再次注意$min,max$的自变量是什么</strong>）：</p>
<script type="math/tex; mode=display">\min_{p\in C}\max_wL(P,w)</script><p>对偶问题是</p>
<script type="math/tex; mode=display">\max_w\min_{p\in C}L(P,w)</script><p>由于拉格朗日函数$L(P,w)$是$P$的凸函数，原始问题的解与对偶问题的解是等价的。这样，可以通过求解对偶问题来求解原始问题</p>
<p><em>注：以上的推理解释可在另一篇拉格朗日文章中找到</em></p>
<p>首先，求解对偶问题内部的极小化问题$\min_{p\in C}L(P,w)$。$\min_{p\in C}L(P,w)$是关于$w$的函数（<em>因为$\min_{p\in C}L(P,w)$代表$P$已经确定了</em>），将其记作：</p>
<script type="math/tex; mode=display">\Psi(w)=\min_{P\in C}L(P,w)=L(P_w,w),</script><p>注：上式的最后一项$L(P_w,w)$是归于$w$的函数，因为此时$P_w=\arg min_{P\in C}L(P,w)=P_w(y|x)$</p>
<p>$\Psi(x)$成为对偶函数，其解为$P_w$。</p>
<p>具体地，求$L(P,w)$对$P(y|x)$的偏导数（这里直接插入图片了手写这一段$mathjax$太累，将图片中$\lambda$换成$w$就行）<strong>注意蓝色字部分</strong></p>
<p><img src="/2018/02/17/最大熵模型/求偏导.jpg" alt=""></p>
<p>另偏导数等于0，在$\hat P(x)&gt;0$的情况下，解得：</p>
<script type="math/tex; mode=display">P(y|x)=exp(\ \sum^n_{i=1}w_if_i(x,y)+w_0-1\ )={exp(\sum^n_{i=1}w_if_i(x,y))\over \exp(1-w_0)}</script><p>由于$\sum_y P(y|x)=1$，得(关于$w$的函数)：</p>
<script type="math/tex; mode=display">P_w(y|x)={1\over Z_w(x)}exp(\ \sum^n_{i=1}w_if_i(x,y)\ )</script><p>其中，</p>
<script type="math/tex; mode=display">Z_w(x)=\sum_yexp(\ \sum^n_{i=1}w_if_i(x,y)\ )</script><p>$Z_w(x)$成为规范化因子；$f_i(x,y)$是特征函数；$w_i$是特征的权值。表示的模型$P_w=P_w(y|x)$就是最大熵模型。这里$w$是最大熵模型中的参数向量。</p>
<p>得到对偶问题内部的极小问题的解$P_w(y|x)$后，需要进一步求解外层的极大值问题。</p>
<script type="math/tex; mode=display">\max_w\Psi(w)</script><p>将其解记为$w^￥$,即：</p>
<script type="math/tex; mode=display">w^￥=\arg\ max_w\Psi(w)</script><p>令$\sum_{x,y}\hat P(x,y)f_i(x,y) = \tau_i$</p>
<p>$    \Psi (x)$</p>
<p>$=L(P_w,w)       注意这里P_w为定量是之前内部极小问题的解$</p>
<p>$=\sum_{x,y}\hat P(x)P_w(y|x)\log P_w(y|x)+\sum^n_{i=1}w_i( \tau_i-\sum_{x,y}\hat P(x)P_w(y|x)f_i(x,y) )$</p>
<p>$=\sum^n_{i=1}w_i\tau_i+\sum_{x,y}\hat P(x)P_w(y|x)( \log p_w(y|x)-\sum^n_{i=1}w_if_i(s,y) )$</p>
<p>又:$\log P_w(y|x)=\sum^n_{i=1}w_if_i(x,y)-\log Z_w(x)$</p>
<p>将上式带入到$\Psi$中，可以得到</p>
<p>$\Psi(w)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x,y}\hat P(x)P_w(y|x)\log Z_w(x)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x)\sum_y P_w(y|x)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x)          (这里利用了\sum_yP_w(y|x)=1 )$</p>
<h3 id="极大似然模型"><a href="#极大似然模型" class="headerlink" title="极大似然模型"></a>极大似然模型</h3><p>下面证明对偶函数的极大化等价于最大熵模型的极大似然估计。</p>
<p>注：极大似然估计$MLE$的一般形式表示为（<strong>推导下一小节给出</strong>）：</p>
<script type="math/tex; mode=display">L_{\hat P}=\Pi_xP(x)^{\hat P(x)}</script><p>一直训练数据的经验概率分布$\hat P(x,y)$，条件概率分布$P(Y|X)$的对数似然表示为：</p>
<script type="math/tex; mode=display">L_{\hat P}(P_w)=\log \Pi_{x,y}P(y|x)^{\hat P(x,y)}=\sum_{x,y}\hat P(x,y)\log P(y|x)</script><p>当条件概率分布$P(y|x)$是最大熵模型的内部极小函数的解释，对数似然函数$L_{\hat P}(P_w)$</p>
<p>为：</p>
<p><img src="/2018/02/17/最大熵模型/极大似然.png" alt=""></p>
<p>注：最后一步由$\sum_{x,y}\hat p(x,y)=\sum_x\hat p(x)\sum_yp(y|x)$且$\sum_yp(y|x)=1$得来</p>
<h3 id="最大熵模型中对数似然的解释"><a href="#最大熵模型中对数似然的解释" class="headerlink" title="最大熵模型中对数似然的解释"></a>最大熵模型中对数似然的解释</h3><p>转载自<a href="http://blog.csdn.net/wkebj/article/details/77965714" target="_blank" rel="noopener">CSDN</a></p>
<p>最近在学习最大熵模型，看到极大似然估计这部分，没有看明白条件概率分布$p(y|x)$的对数似然函数。上网查了很多资料都没有一个合理的解释。基本直接给出对数似然函数的一般形式 (<strong>$\hat p(x)$为经验概率，即：训练样本中x出现的概率，注意：这里$\Pi$下标是$x$的种类</strong>): </p>
<script type="math/tex; mode=display">L\hat p=\prod_xp(x)^{\hat p(x)}</script><p>其实第一眼之所以不理解，因为这是最大似然函数的另外一种形式。一般书上描述的最大似然函数的一般形式是各个样本集XX中各个样本的联合概率: </p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)=\prod^n_{i=1}p(x_i;\theta)</script><p>其实这个公式和上式是等价的。$x_1,x_2,…,x_n$是样本具体观测值。随机变量$X$是离散的，所以它的取值范围是一个集合，假设样本集的大小为$n$，$X$的取值有$k$个，分别是$v_1,v_2,…,v_k$。用$C(X=v_i)$表示在观测值中样本$v_i$出现的频率。所以$L(x_1,x_2,…,x_n;θ)$可以表示为： </p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)=\prod^k_{i=1}p(v_i;\theta)^{C(X=v_i)}</script><p>对等式两边同时开$n$次方得：</p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)^{1\over n}=\prod^k_{i=1}p(v_i;\theta)^{C(X=v_i)\over n}</script><p>因为经验概率$\hat p(x)={C(X=v_i)\over n}$，所以简写可以得到</p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)^{1\over n}=\prod_xp(x;\theta)^{\hat p(x)}</script><p>很明显对$L(x_1,x_2,…,x_n;θ)​$求最大值和对$L(x_1,x_2,…,x_n;θ)^{1\over n}​$求最大值的优化的结果是一样的。整理上式所以最终的最大似然函数可以表示为：</p>
<script type="math/tex; mode=display">L(x;\theta)=\prod_xp(x;\theta)^{\hat p(x)}</script><h2 id="从最大熵模型角度理解LR"><a href="#从最大熵模型角度理解LR" class="headerlink" title="从最大熵模型角度理解LR"></a>从最大熵模型角度理解LR</h2><p>LR是最大熵模型在类别为2时候的特例</p>
<p>假设<strong>每条输入</strong>第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。</p>
<script type="math/tex; mode=display">f(x,y) =\begin{cases}x_i,  & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}</script><p>根据最大熵模型：</p>
<script type="math/tex; mode=display">P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}</script><p>现在回到两类的情况$\{0,1\}$，此时分母上有两项：</p>
<script type="math/tex; mode=display">P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}</script><p>分子、分母同时除以分子，则有：</p>
<script type="math/tex; mode=display">P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}</script><p>这就变成了$logistic$函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[最大熵模型的理解、推导以及与LR的联系]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="最大熵模型" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="特征函数" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Logistic Regression的理解]]></title>
    <link href="http://yoursite.com/2018/02/16/Logistic-Regression%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/02/16/Logistic-Regression的理解/</id>
    <published>2018-02-16T12:52:28.000Z</published>
    <updated>2018-03-25T04:31:52.394Z</updated>
    <content type="html"><![CDATA[<h2 id="逻辑斯地回归模型"><a href="#逻辑斯地回归模型" class="headerlink" title="逻辑斯地回归模型"></a>逻辑斯地回归模型</h2><h3 id="逻辑斯谛分布"><a href="#逻辑斯谛分布" class="headerlink" title="逻辑斯谛分布"></a>逻辑斯谛分布</h3><p>设$X$是连续随机变量，$X$服从逻辑斯谛分布是指$X$具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">F(x)=P(X\le x)= {1 \over 1+e^{-(x-\mu )/\gamma}}</script><script type="math/tex; mode=display">f(x)=F'(x)={e^{-(x-\mu)/y} \over \gamma(1+e^{-(x-\mu)}/\gamma)^2}</script><p>式中，$\mu$为位置参数，$\gamma\gt0$为形状参数。密度函数与分布函数如下图所示。</p>
<p><img src="/2018/02/16/Logistic-Regression的理解/分布.jpg" alt=""></p>
<p><strong>注：逻辑斯谛分布的回归会在从广义线性模型角度理解LR时给出</strong></p>
<h3 id="二项逻辑斯谛回归模型"><a href="#二项逻辑斯谛回归模型" class="headerlink" title="二项逻辑斯谛回归模型"></a>二项逻辑斯谛回归模型</h3><p>二项逻辑斯谛回归模型是一种<strong>分类模型</strong>，由条件概率分布$P(Y|X)$表示，形式为参数化的逻辑斯谛分布。这里，随机变量取值为实数，随机变量Y，取值为1或0，即Y满足二项分布。</p>
<p><strong>定义：</strong>二项逻辑斯谛回归模型是如下的条件概率分布：</p>
<script type="math/tex; mode=display">P(Y=1|x)={exp(wx) \over 1+exp(wx) }={1\over 1+exp(-wx)}</script><script type="math/tex; mode=display">P(Y=0|x)={1 \over 1+exp(wx)}={exp(-wx) \over 1+exp(-wx)}</script><p>一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是$p$,那么该事件的几率是${p\over 1-p}$，该事件的对数几率或者logit函数是：</p>
<script type="math/tex; mode=display">logit(p)=\log {p \over 1-p}</script><p>这里$logit(p)$就是广义线性模型中的$\eta$。</p>
<p>对于逻辑斯谛回归而言</p>
<script type="math/tex; mode=display">\log {P(Y=1|x) \over 1-P(Y=1|x)}=wx\ \ \ 其实就是广义线性模型第三条假设</script><p>从广义线性模型角度，二项分布指数族解出的$\eta = \log{p\over 1-p}=logit(p)$,又由第三条假设，$\eta=wx$即可得到$\log {p\over 1-p}=wx$,求解出$p$来就是$P(Y=1|X)$的概率，又因为二项分布期望为$P$,所以收敛的结果就是$P$.</p>
<h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p>逻辑斯谛回归模型学习中，对于给定的训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_n)\}$ ，其中，$x_I\in R^n,y_i\in\{0,1\}$,可以应用<strong>极大似然估计法</strong>估计模型参数，从而得到逻辑斯谛回归模型。设：</p>
<script type="math/tex; mode=display">P(Y=1|x)=\pi(x),\ \ \ P(Y=0|x)=1-\pi(x)</script><p>似然函数为</p>
<script type="math/tex; mode=display">\Pi^N_{i=1}[\pi(x_i)^{y_i}][1-\pi(x)]^{1-y_i}</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">L(w)=\sum^N_{i=1}[y_i\log \pi(x_i)+(1-y_i)\log (1-\pi(x_i))]</script><script type="math/tex; mode=display">\ \ \ =\sum^N_{i=1}[y_i\log{\pi(x) \over 1-\pi(x_i)}+\log(1-\pi(x_i))]</script><script type="math/tex; mode=display">\ \ =\sum^N_{i=1}[y_i(wx)-\log(1+exp(wx))]\ \ \ \ \ \ \</script><h2 id="从最大熵模型角度理解LR"><a href="#从最大熵模型角度理解LR" class="headerlink" title="从最大熵模型角度理解LR"></a>从最大熵模型角度理解LR</h2><p>LR是最大熵模型在类别为2时候的特例</p>
<p>假设<strong>每条输入</strong>第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。</p>
<script type="math/tex; mode=display">f(x,y) =\begin{cases}x_i,  & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}</script><p>根据最大熵模型：</p>
<script type="math/tex; mode=display">P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}​</script><p>现在回到两类的情况$\{0,1\}$，此时分母上有两项：</p>
<script type="math/tex; mode=display">P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}</script><p>分子、分母同时除以分子，则有：</p>
<script type="math/tex; mode=display">P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}</script><p>这就变成了$logistic$函数。</p>
<h2 id="从广义线性模型角度理解LR"><a href="#从广义线性模型角度理解LR" class="headerlink" title="从广义线性模型角度理解LR"></a>从广义线性模型角度理解LR</h2><p>线性回归中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta) 服从N(\mu,\sigma^2)分布</script><p>$LR$中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta)服从Bernoulli(\phi)分布</script><p>其实他们只是广义线性模型($GlMs$)的特例。</p>
<h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p><strong>广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。</strong></p>
<p>注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$</p>
<h3 id="指数分布族（-The-exponential-family-）"><a href="#指数分布族（-The-exponential-family-）" class="headerlink" title="指数分布族（$The exponential family$）"></a>指数分布族（$The exponential family$）</h3><p>首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)：</p>
<script type="math/tex; mode=display">p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))</script><p>简单介绍一下其中的参数：</p>
<p>1.$\eta $是自然参数</p>
<p>2.$T(y)$是充分统计量(一般情况下$T(y)=y$)</p>
<p>3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $)</p>
<p>也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。</p>
<p>选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布</p>
<h2 id="广义线性模型的形式化定义"><a href="#广义线性模型的形式化定义" class="headerlink" title="广义线性模型的形式化定义"></a>广义线性模型的形式化定义</h2><p>GLM有三个假设：</p>
<p>1.$y|x;\theta$~$ExpFamily(\eta)$（某指数分布族）；给定样本$x$与参数$\theta$，样本分类$y$服从指数分布族中的某个分布；</p>
<p>2.给定一个$x$，我们需要的目标函数为$h_{\theta}(x)=E[T(y)|x]$</p>
<p>3.$\eta=\theta^Tx$</p>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p><img src="/2018/02/16/Logistic-Regression的理解/伯努利1.jpg" alt=""></p>
<p><img src="/2018/02/16/Logistic-Regression的理解/伯努利2.jpg" alt=""></p>
<p><img src="/2018/02/16/Logistic-Regression的理解/伯努利3.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[LR的推导以及从广义线性模型、最大熵模型角度的理解]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="最大熵模型" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="广义线性回归" scheme="http://yoursite.com/tags/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="逻辑斯谛回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广义线性模型]]></title>
    <link href="http://yoursite.com/2018/02/16/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/02/16/广义线性模型/</id>
    <published>2018-02-16T05:02:21.000Z</published>
    <updated>2018-03-25T04:31:59.388Z</updated>
    <content type="html"><![CDATA[<h1 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h1><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>本文将会说明线性回归和$LR$都是广义线性模型的一种特殊形式，介绍广义线性模型的一般求解步骤。</p>
<p>线性回归中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta) 服从N(\mu,\sigma^2)分布</script><p>$LR$中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta)服从Bernoulli(\phi)分布</script><p>其实他们只是广义线性模型($GlMs$)的特例。</p>
<h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p><strong>广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。</strong></p>
<p>注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$</p>
<h2 id="指数分布族（-The-exponential-family-）"><a href="#指数分布族（-The-exponential-family-）" class="headerlink" title="指数分布族（$The exponential family$）"></a>指数分布族（$The exponential family$）</h2><p>首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)：</p>
<script type="math/tex; mode=display">p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))</script><p>简单介绍一下其中的参数：</p>
<p>1.$\eta $是自然参数</p>
<p>2.$T(y)$是充分统计量(一般情况下$T(y)=y$)</p>
<p>3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $)</p>
<p>也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。</p>
<p>选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布</p>
<h2 id="广义线性模型的形式化定义"><a href="#广义线性模型的形式化定义" class="headerlink" title="广义线性模型的形式化定义"></a>广义线性模型的形式化定义</h2><p>GLM有三个假设：</p>
<p>1.$y|x;\theta$~$ExpFamily(\eta)$（某指数分布族）；给定样本$x$与参数$\theta$，样本分类$y$服从指数分布族中的某个分布；</p>
<p>2.给定一个$x$，我们需要的目标函数为$h_{\theta}(x)=E[T(y)|x]$</p>
<p>3.$\eta=\theta^Tx$</p>
<h2 id="高斯分布的另一种看法"><a href="#高斯分布的另一种看法" class="headerlink" title="高斯分布的另一种看法"></a>高斯分布的另一种看法</h2><p><img src="/2018/02/16/广义线性模型/高斯1.jpg" alt=""></p>
<p><img src="/2018/02/16/广义线性模型/高斯2.jpg" alt=""></p>
<p><img src="/2018/02/16/广义线性模型/高斯3.jpg" alt=""></p>
<h2 id="伯努利分布-LR回归的含义"><a href="#伯努利分布-LR回归的含义" class="headerlink" title="伯努利分布-LR回归的含义"></a>伯努利分布-LR回归的含义</h2><p><img src="/2018/02/16/广义线性模型/伯努利1.jpg" alt=""></p>
<p><img src="/2018/02/16/广义线性模型/伯努利2.jpg" alt=""></p>
<p><img src="/2018/02/16/广义线性模型/伯努利3.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[广义线性模型简析以及与LR的联系]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="理论" scheme="http://yoursite.com/tags/%E7%90%86%E8%AE%BA/"/>
    
      <category term="广义线性模型" scheme="http://yoursite.com/tags/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GLM" scheme="http://yoursite.com/tags/GLM/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[支持向量机SVM]]></title>
    <link href="http://yoursite.com/2018/01/18/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>http://yoursite.com/2018/01/18/支持向量机SVM/</id>
    <published>2018-01-18T13:34:16.000Z</published>
    <updated>2018-03-25T04:41:56.627Z</updated>
    <content type="html"><![CDATA[<h1 id="线性可分支持向量机与硬间隔最大化"><a href="#线性可分支持向量机与硬间隔最大化" class="headerlink" title="线性可分支持向量机与硬间隔最大化"></a>线性可分支持向量机与硬间隔最大化</h1><hr>
<h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p>考虑一个二分类问题，假设输入空间和特征空间为两个不同的空间。<strong>输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间。</strong>线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间中的输入映射为特征空间中的特征向量。非线性支持向量机利用一个从输入空间到特征空间的非线性映射将输入映射为特征向量。所以<strong>输入都有输入空间转换到特征空间，支持向量机的学习是在特征空间进行的。</strong></p>
<p><strong>定义   线性可分支持向量机：</strong>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为：</p>
<script type="math/tex; mode=display">w^￥x+b^￥=0</script><p>以及相应的分类决策函数：</p>
<script type="math/tex; mode=display">f(x)=sign(w^￥x+b^￥)</script><h2 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h2><p>一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度。在超平面$wx+b=0$确定的情况下，$|wx+b|$能够<strong>相对的</strong>表示点$x$距离超平面的远近。而$wx+b$的符号与类标记$y$的符号是否一致能够表示分类是否正确。所以可用量$y(wx+b)$来表示分类的正确性以及确信度，这就是<strong>函数间隔</strong>的概念。</p>
<p><strong><em>为什么$|wx+b|$是相对的表示距离：首先这指的是函数距离，同一个函数内有比较价值。其次因为$b$的影响，真正距离并不是这个，但是距离的比较都有这个$b$，所以这里就不再考虑</em></strong></p>
<p><strong>定义  函数间隔：</strong>对于给定的训练数据集$T$和超平面$(w,b)$，定义超平面$(w,b)$关于样本点$(x_i,y_i)$的函数间隔为</p>
<script type="math/tex; mode=display">\hat\gamma_i=y_i(wx_i+b)</script><p>定义超平面$(w,b)$关于训练数据集$T$的函数间隔为超平面$(w,b)$关于$T$中所有样本点$(x_i,y_i)$的函数间隔之最小值（<strong>注意这里是指到平面最小距离的点的距离，其实就是支持向量到分离超平面的距离</strong>），即：</p>
<script type="math/tex; mode=display">\hat\gamma=\min_{i=1,…,N}\hat\gamma_i</script><p>选择分离超平面时，只有函数间隔还不够，因为<strong><em>只要成比例的改变$w$和$b$，例如将它们改写为$2w$和$2b$，超平面并没有改变，但函数间隔却成为原来的$2$倍。所以可以对分离超平面的法向量$w$加某些约束，如规范化，$||w||=1$，使得间隔是确定的。</em></strong>这时函数间隔成为几何间隔。</p>
<p><strong>定义  几何间隔：</strong>对于给定的训练数据集$T$和超平面$(w,b)$，定义超平面$(w,b)$关于样本点$(x_i,y_i)$的几何间隔为：</p>
<script type="math/tex; mode=display">\gamma_i=y_i({w\over ||w||}x_i+{b\over||w||})</script><p>定义超平面$(w,b)$关于训练数据集$T$的函数间隔为超平面$(w,b)$关于$T$中所有样本点$(x_i,y_i)$的几何间隔之最小值（<strong>注意这里是指到平面最小距离的点的距离，其实就是支持向量到分离超平面的距离</strong>），即：</p>
<script type="math/tex; mode=display">\gamma=\min_{i=1,…,N}\hat\gamma_i</script><p>函数间隔和几何间隔的关系：</p>
<script type="math/tex; mode=display">\gamma={\hat\gamma\over||w||}\ \ \ \ \ (1)</script><p>如果$||w||=1$，那么函数间隔和几何间隔相等。如果超平面参数$w$和$b$成比例的改变（超平面没有改变），函数间隔也按此比例改变，而几何间隔不变。</p>
<h2 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h2><p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着一充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例有很好的分类预测能力。</p>
<h3 id="最大间隔分离超平面"><a href="#最大间隔分离超平面" class="headerlink" title="最大间隔分离超平面"></a>最大间隔分离超平面</h3><p>求一个几何间隔最大的分离超平面可以表示为下面问题的最优化：</p>
<script type="math/tex; mode=display">\max_{w,b}\ \ \ \gamma</script><script type="math/tex; mode=display">s.t.\ \ y_i({w\over||w||}x_i+{b\over||w||})\ge\gamma,\ \ i=1,2,…,N</script><p>我们希望最大化几何间隔$\gamma$（<strong>$\gamma$为所有点的中几何距离最短的点的几何距离，就是支持向量的几何距离</strong>），约束条件表示的是超平面关于每个训练样本点的几何间隔至少是$\gamma$。</p>
<p>考虑几何间隔与函数间隔的关系式$(1)$，可以将这个问题改写为(这里为了构造出$||w||$):</p>
<script type="math/tex; mode=display">\max_{w,b}\ \ \ {\hat\gamma\over||w||}</script><script type="math/tex; mode=display">s.t.\ \ y_i(wx_i+b)\ge\hat\gamma,\ \ i=1,2,…,N</script><p>**函数间隔$\hat\gamma$的取值并不影响最优化问题的解。将$w,b$按比例变化为$\lambda w,\lambda b$，超平面并未发生改变，函数间隔变为$\lambda\hat\gamma $。所以函数间隔的改变只影响$w,b$的系数，不改变超平面。这样就可以去$\hat\gamma=1$，并带入以上最优化问题。注意到最大化$1\over ||w||$和最小化${1\over 2}||w||^2$是等价地。于是就得到了下面线性可分支持向量机学习的最优化问题：</p>
<script type="math/tex; mode=display">\min_{w,b}\ \ \ {1\over 2}||w||^2</script><script type="math/tex; mode=display">s.t.\ \ \ y_i(wx_i+b)-1\ge0,\ \ \ i=1,2,…,N</script><p><strong><em>SVM部分暂时弃更，东西差不多都是《统计学习方法上的》，关于自己理解的部分也都标注在了书上，手码实在太多了，这部分先看书把。。</em></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[支持向量机自己的备忘录]]>
    
    </summary>
    
      <category term="SVM" scheme="http://yoursite.com/tags/SVM/"/>
    
      <category term="支持向量机" scheme="http://yoursite.com/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
      <category term="核函数" scheme="http://yoursite.com/tags/%E6%A0%B8%E5%87%BD%E6%95%B0/"/>
    
      <category term="拉格朗日" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性模型的判断]]></title>
    <link href="http://yoursite.com/2018/01/10/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/01/10/线性模型的判断/</id>
    <published>2018-01-10T07:03:08.000Z</published>
    <updated>2018-03-25T04:36:46.306Z</updated>
    <content type="html"><![CDATA[<h2 id="线性模型的判断"><a href="#线性模型的判断" class="headerlink" title="线性模型的判断"></a>线性模型的判断</h2><p>线性模型定义：如果模型是参数的线性函数，并且存在线性分类面就是线性模型，否则不是。</p>
<p>注意：线性模型可以用曲线拟合样本，但是分类的决策边界一定是直线的，例如$LR$</p>
<p>例子：</p>
<p>单层感知机（网络）无法解决异或问题（单层感知机是线性模型）</p>
<p>存在非线性激活函数的多层感知机（网络）可以解决异或问题（存在非线性激活函数多层感知机是非线性）</p>
<h2 id="快速判断线性非线性"><a href="#快速判断线性非线性" class="headerlink" title="快速判断线性非线性"></a>快速判断线性非线性</h2><h3 id="线性的情况"><a href="#线性的情况" class="headerlink" title="线性的情况"></a>线性的情况</h3><ol>
<li>看乘法式子中自变量$x$前的系数$w$，如果$w$只影响一个$x$，那么此模型为线性模型。（等价于对决策边界是否为超平面的判断）</li>
</ol>
<p>非线性的情况</p>
<ol>
<li>$(变量)^n$，且$n$不为1为非线性</li>
<li>$|变量|$有变量在绝对值内为非线性</li>
<li>$sgn (变量)$有变量在符号函数内为非线性</li>
</ol>
<h2 id="常见的模型"><a href="#常见的模型" class="headerlink" title="常见的模型"></a>常见的模型</h2><p>常见的线性分类器：$LR$，贝叶斯分类器，单层感知机，线性回归</p>
<p>常见的非线性分类器：决策树，$RF$，$GBDT$，多层感知机</p>
<p>$SVM$两种都有（看是线性核还是高斯核）</p>
<p>线性分类器速度快、编程方便，但是拟合效果可能不好</p>
<p>非线性分类器编程复杂，但是拟合能力强</p>
<h2 id="为什么朴素贝叶斯分类器是线性分类器？"><a href="#为什么朴素贝叶斯分类器是线性分类器？" class="headerlink" title="为什么朴素贝叶斯分类器是线性分类器？"></a>为什么朴素贝叶斯分类器是线性分类器？</h2><p><strong>这一部分我感觉我的理解出现了偏差，先写上了</strong></p>
<h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><p>假设了各特征之间相互独立，采用后验概率最大的类别</p>
<p>贝叶斯公式：</p>
<script type="math/tex; mode=display">p(C_k|x_1,x_2,…,x_n)={p(C_k)\Pi^n_{i=1}p(x_i|C_k)\over \sum_ip(x|C_i)p(C_i)}</script><p>训练时候只需要统计$p(C_k),p(x_i|C_k)$，可以说是$very  naive$了</p>
<h3 id="从线性模型角度理解"><a href="#从线性模型角度理解" class="headerlink" title="从线性模型角度理解"></a>从线性模型角度理解</h3><p>这里以二分类举例</p>
<p>我们将样本表示为$x=(x_1,x_2,…,x_n)$，$y=\{0,1\}$，$p_{ki}$表示$C_k$中$x_i$出现的概率</p>
<p>$\log p(C_k)p(x|C_k)$</p>
<p>$=\log p(C_k)+\sum_{i=1}^n\log p_{ki}$</p>
<p>对于上式，将$\log p_{ki}$看做$w_i$，而$x_i$为样本中$x_i$表示的值的出现，$x_i=1$。上式可以化为：</p>
<p>$=w^T_kx+b$</p>
]]></content>
    <summary type="html">
    <![CDATA[线性模型的判断，为什么朴素贝叶斯是线性模型？]]>
    
    </summary>
    
      <category term="线性模型" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="非线性模型" scheme="http://yoursite.com/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="朴素贝叶斯" scheme="http://yoursite.com/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[L1、L2正则化]]></title>
    <link href="http://yoursite.com/2018/01/01/L1%E3%80%81L2%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/01/L1、L2正则化/</id>
    <published>2017-12-31T16:30:03.000Z</published>
    <updated>2018-03-25T04:33:14.712Z</updated>
    <content type="html"><![CDATA[<h1 id="从概率角度推导"><a href="#从概率角度推导" class="headerlink" title="从概率角度推导"></a>从概率角度推导</h1><hr>
<p>本部分引<a href="https://www.zhihu.com/question/20447622/answer/25186207" target="_blank" rel="noopener">知乎用户bsdelf</a></p>
<p>从概率论的角度：</p>
<ol>
<li>$Least Square$的解析解可以用$Gaussian$分布以及最大似然估计求得</li>
<li>$Ridge$回归可以用$Gaussian$分布和最大后验估计解释</li>
<li>$Lasso$回归可以用$Laplace$分布和最大后验估计解释</li>
</ol>
<p>首先假设线性回归模型具有如下形式：</p>
<script type="math/tex; mode=display">f(x)=\sum^d_{j=1}{x_jw_j}+\epsilon=\mathbf{xw^T}+\epsilon</script><p>其中$\mathbf{x}\in \mathbb{R}^{1\times d}，\mathbf{w}\in \mathbb{R}^{n\times d}$，<strong>误差</strong>$\epsilon\in\mathbb{R}$。</p>
<p>当前一直$\mathbf{X}=(\mathbf{x_1,x_2,…,x_n})^T\in\mathbb{R}^{n\times d}，\mathbf{y}\in\mathbb{R}^{n\times 1}$，怎样求$\mathbf w$呢？</p>
<p><strong>策略1</strong>：假设$\epsilon_i\sim N(0,\sigma^2)$，也就是说$\mathbf{y_i}\sim N(\mathbf{x_iw^T,\sigma^2})$，那么用最大似然估计推导：</p>
<p>$\arg\max_{\mathbf{w}}L(\mathbf{w})$</p>
<p>$=\ln \prod^n_{i=1}{1\over \sigma\sqrt{2\pi}}\exp (-{1\over 2}({\mathbf y_i-\mathbf{x_iw^T}\over\sigma})^2)$</p>
<p>$-{1\over 2\sigma^2}\sum^n_{i=1}(\mathbf y_i-\mathbf{w_iw^T})^2-n\ln \sigma\sqrt{2\pi}$</p>
<p>$\arg\min_{\mathbf w}f(\mathbf w)$</p>
<p>$=\sum^n_{i=1}(\mathbf y_i-\mathbf{x_iw^T})^2$</p>
<p>$=||\mathbf y-\mathbf{Xw^T}||^2_2$</p>
<p>这不就是最小二乘吗？</p>
<p><strong>策略2</strong>:假设$\epsilon_i\sim N(0,\sigma^2)$，$\mathbf w_i\sim N(0,\tau^2)$，那么最后又最大后验估计推导：</p>
<p>$\arg\max_\mathbf{w}L(\mathbf w)$</p>
<p>$=\ln\prod^n_{i=1}{1\over \sigma\sqrt{2\pi}}\exp(-{1\over 2}({\mathbf y_i-\mathbf{x_iw^T}\over \sigma})^2)·\prod^d_{j=1}{1\over \tau\sqrt{2\pi}}\exp(-{1\over 2}({\mathbf w_j\over\tau})^2)$</p>
<p>$=-{1\over 2\sigma^2}\sum^n_{i=1}(\mathbf{y}_i-\mathbf{x_iw^T})^2-{1\over 2\tau^2}\sum^d_{j=1}\mathbf w^2_j-n\ln\sigma\sqrt{2\pi}-d\ln\tau\sqrt{2\pi}$</p>
<p>$\arg\min_\mathbf wf(\mathbf w)$</p>
<p>$=\sum^n_{i=1}(\mathbf y_i-\mathbf{x_iw^T})^2+\lambda\sum^d_{j=1}\mathbf w_j^2$</p>
<p>$=||\mathbf y-\mathbf{Xw^T||^2_2+\lambda||\mathbf w||^2_2}$</p>
<p>这不就是$Ridge$回归吗？</p>
<p><strong>策略3</strong>：假设$\epsilon_i\sim N(0,\sigma^2)$，$\mathbf w_i\sim Laplace(0,b)$，那么最后又最大后验估计推导：</p>
<p>$\arg\max_\mathbf{w}L(\mathbf w)$</p>
<p>$=\ln\prod^n_{i=1}{1\over \sigma\sqrt{2\pi}}\exp(-{1\over 2}({\mathbf y_i-\mathbf{x_iw^T}\over \sigma})^2)·\prod^d_{j=1}{1\over 2b}\exp(-{|\mathbf w_j|\over b})$</p>
<p>$=-{1\over 2\sigma^2}\sum^n_{i=1}(\mathbf{y}_i-\mathbf{x_iw^T})^2-{1\over 2\tau^2}\sum^d_{j=1}|\mathbf w_j|-n\ln\sigma\sqrt{2\pi}-d\ln\tau\sqrt{2\pi}$</p>
<p>$\arg\min_\mathbf wf(\mathbf w)$</p>
<p>$=\sum^n_{i=1}(\mathbf y_i-\mathbf{x_iw^T})^2+\lambda\sum^d_{j=1}|\mathbf w_j|$</p>
<p>$=||\mathbf y-\mathbf{Xw^T||^2_2+\lambda||\mathbf w||_1}$</p>
<p>这不就是$Lasso$吗？</p>
<h2 id="L1、L2-正则化各自的特点"><a href="#L1、L2-正则化各自的特点" class="headerlink" title="$L1、L2$正则化各自的特点"></a>$L1、L2$正则化各自的特点</h2><hr>
<h2 id="L1-正则化"><a href="#L1-正则化" class="headerlink" title="$L1$正则化"></a>$L1$正则化</h2><p>$L1$范数是指向量中各个元素绝对值之和，也叫<strong>“稀疏规则算子”</strong>。那么<strong>为什么$L1$范数会使<em>权值稀疏</em>？实际上：任何规则化孙子，如果它在$w_i=0$的地方不可微，并且可以分解为一个”求和”的形式，那么这个规则化算子就可以实现稀疏</strong></p>
<p><strong>权值稀疏</strong>的好处：</p>
<p><strong>1）特征选择：</strong></p>
<p>没有信息的特征权值比较小。</p>
<p><strong>2）可解释性</strong>：</p>
<p>我们可以相信权重非0的特征上面提供的信息远大于筛选掉的信息</p>
<p><strong>$L1$正则化不可导</strong>：</p>
<p>L1不可导可以使用$Proximal Algorithms$或者$ADMM$来解决。</p>
<h2 id="L2-正则化"><a href="#L2-正则化" class="headerlink" title="$L2$正则化"></a>$L2$正则化</h2><p>$L2$范数又称“<strong>岭回归</strong>”，也叫“<strong>权值衰减</strong>”。让权值都趋向0，可以修正过拟合，原因可能权值系数小了，模型<strong>“多项式性”</strong>就不明显了？。</p>
<p><strong>1）学习理论角度：</strong></p>
<p>$L2$范数可以防止过拟合，提升模型泛化能力</p>
<p><strong>2）优化计算角度：</strong></p>
<p>$L2$有助于处理$condition number$不好的情况</p>
<p>这篇<a href="https://zhuanlan.zhihu.com/p/32488420" target="_blank" rel="noopener">知乎文章</a>对$L2$正则化从四个方面深度剖析。</p>
<ol>
<li><p>$mse$损失函数</p>
<script type="math/tex; mode=display">L(w)={1\over N}(y-\hat y)^T(y-\hat y)={1\over N}(y-Xw)^T(y-Xw)</script><p>为使其达到最小，则关于$w$的偏导为0：</p>
<script type="math/tex; mode=display">\hat w=(X^TX)^{-1}X^Ty</script><p>然而会存在$X^TX$不可逆的情况。为了避免这个问题，将$X^TX$矩阵的对角元素增大一个量$\lambda$，变成$X^TX+\lambda I$。相当于在矩阵$X^TX$中的对角线上加一个值增高他的山岭。山岭增高后矩阵变成可逆的。带入得：</p>
<script type="math/tex; mode=display">\hat w_{bridge}=(X^TX+\lambda I)^{-1}X^Ty</script></li>
<li><p>从贝叶斯的角度，假设$w$服从$N(0,\sigma^2I_p)$分布，在最大似然的基础上加入了$w$的先验知识，相当于极大化后验概率。求解该极大化的后验概率，对应的先验知识就是正则化部分</p>
</li>
<li><p>$L2$正则化的解相当于先对数据做了主成分分析，然后对于方差小的主成分方向进行惩罚。主成分分析原样保留大方差方向，去掉小方差方向，相当于一个硬选择。而$ L2$ 正则根据方差的大小施加不同程度的惩罚，相当于软选择。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[L1、L2正则化的贝叶斯解释以及各自的特点]]>
    
    </summary>
    
      <category term="L1" scheme="http://yoursite.com/tags/L1/"/>
    
      <category term="L2" scheme="http://yoursite.com/tags/L2/"/>
    
      <category term="正则化" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
      <category term="先验概率" scheme="http://yoursite.com/tags/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87/"/>
    
      <category term="后验概率" scheme="http://yoursite.com/tags/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几种特征选择的方法]]></title>
    <link href="http://yoursite.com/2017/12/23/%E5%87%A0%E7%A7%8D%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/23/几种特征选择的方法/</id>
    <published>2017-12-23T07:33:33.000Z</published>
    <updated>2018-03-25T04:33:01.793Z</updated>
    <content type="html"><![CDATA[<p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p>
<ul>
<li>特征是否发散：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li>
<li>特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</li>
</ul>
<p>根据特征选择的形式又可以将特征选择方法分为3种：</p>
<ul>
<li>Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</li>
<li>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</li>
<li>Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</li>
</ul>
<p>　　我们使用sklearn中的feature_selection库来进行特征选择。</p>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="$Filter$"></a>$Filter$</h1><ul>
<li>优点：快速，主需要统计知识</li>
<li>缺点：难以挖局特征之间的组合效应</li>
</ul>
<h2 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h2><p>使用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。</p>
<h2 id="相关系数法"><a href="#相关系数法" class="headerlink" title="相关系数法"></a>相关系数法</h2><p>使用相关系数法，先要计算各个特征对目标值的相关系数以及相关系数的P值。</p>
<h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><p>经典的卡方检验是检验定性自变量对定性因变量的相关性。假设自变量有N种取值，因变量有M种取值，考虑自变量等于i且因变量等于j的样本频数的观察值与期望的差距，构建统计量：</p>
<script type="math/tex; mode=display">\chi^2=\sum{(A-E)\over E}</script><p>其中$A$为实际值，$E$为理论值。<strong>$\chi^2$用于衡量两个变量实际值与联合分布理论值的差异程度（也就是卡方检验的核心思想）</strong>，包含了一下两个信息：</p>
<ul>
<li>实际值与理论值偏差的绝对大小</li>
<li>差异程度与理论值的相对大小</li>
</ul>
<p>这个统计量含义就是<strong>自变量对因变量的相关性</strong>。</p>
<p>可以这么理解，对于这两个特征的联合分布矩阵，这两个变量不相关，那么通过边缘概率求得的期望值（$E$）就应该越接近于真实值（$A$），$\chi^2$越小；相反，这两个变量越相关，通关边缘概率分布求得的期望值（$E$）跟真实值（$A$）的差距就应该越大，$\chi^2$越大。</p>
<p>因此$\chi^2$越大，说明自变量与因变量相关性越强</p>
<h2 id="互信息法"><a href="#互信息法" class="headerlink" title="互信息法"></a>互信息法</h2><p>不多说</p>
<h1 id="Wrapper"><a href="#Wrapper" class="headerlink" title="$Wrapper$"></a>$Wrapper$</h1><ul>
<li>优点：直接面向算法优化，不需要太多知识</li>
<li>缺点：庞大的搜索空间，需要定义启发式策略</li>
</ul>
<p>递归消除特征法使用一个基模型来进行多轮训练，每轮训练后，消除若干权值系数的特征，再基于新的特征集进行下一轮训练。</p>
<h1 id="Embedded"><a href="#Embedded" class="headerlink" title="$Embedded$"></a>$Embedded$</h1><ul>
<li>优点：快速，并且面向算法</li>
<li>缺点：需要调整结构和参数配置</li>
</ul>
<h2 id="基于惩罚项的特征选择法"><a href="#基于惩罚项的特征选择法" class="headerlink" title="基于惩罚项的特征选择法"></a>基于惩罚项的特征选择法</h2><p>使用带$L1$惩罚项的基模型，除了筛选出特征外，同时也进行了降维。</p>
<p>$Lasso$的参数$\lambda$越大，参数的解越稀疏，选出的特征越少。</p>
<p><a href="http://www.zhihu.com/question/28641663/answer/41653367" target="_blank" rel="noopener">L1惩罚项降维的原理在于保留多个对目标值具有同等相关性的特征中的一个</a>，所以没选到的特征不代表不重要。故，可结合L2惩罚项来优化。具体操作为：若一个特征在L1中的权值为1，选择在L2中权值差别不大且在L1中权值为0的特征构成同类集合，将这一集合中的特征平分L1中的权值.</p>
<h2 id="基于树模型的特征选择法"><a href="#基于树模型的特征选择法" class="headerlink" title="基于树模型的特征选择法"></a><strong>基于树模型的特征选择法</strong></h2><p>各种树模型可以输出特征的重要性</p>
]]></content>
    <summary type="html">
    <![CDATA[简单盘述一下特征工程中的特征选择部分]]>
    
    </summary>
    
      <category term="特征选择" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]PCA]]></title>
    <link href="http://yoursite.com/2017/10/29/%E8%BD%AC-PCA/"/>
    <id>http://yoursite.com/2017/10/29/转-PCA/</id>
    <published>2017-10-29T14:06:32.000Z</published>
    <updated>2018-03-30T13:22:00.866Z</updated>
    <content type="html"><![CDATA[<p><strong><em>本文转载自：<a href="http://blog.codinglabs.org/articles/pca-tutorial.html，原文公式显示不出，所以放入本地markdown学习了" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/pca-tutorial.html，原文公式显示不出，所以放入本地markdown学习了</a></em></strong></p>
<p>$PCA​$（Principal Component Analysis）是一种常用的数据分析方法。<strong>$PCA​$通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。</strong>网上关于$PCA​$的文章有很多，但是大多数只描述了$PCA​$的分析过程，而没有讲述其中的原理。这篇文章的目的是介绍$PCA​$的基本数学原理，帮助读者了解$PCA​$的工作机制是什么。</p>
<p>当然我并不打算把文章写成纯数学文章，而是希望用直观和易懂的方式叙述$PCA$的数学原理，所以整个文章不会引入严格的数学推导。希望读者在看完这篇文章后能更好的明白$PCA$的工作原理。</p>
<h1 id="数据的向量表示及降维问题"><a href="#数据的向量表示及降维问题" class="headerlink" title="数据的向量表示及降维问题"></a>数据的向量表示及降维问题</h1><p>一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个淘宝店2012年全年的流量及交易情况可以看成一组记录的集合，其中每一天的数据是一条记录，格式如下：</p>
<p>(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)</p>
<p>其中“日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：</p>
<script type="math/tex; mode=display">(500,240,25,13,2312.15)^\mathsf{T}</script><p>注意这里我用了转置，因为习惯上使用列向量表示一条记录（后面会看到原因），本文后面也会遵循这个准则。不过为了方便有时我会省略转置符号，但我们说到向量默认都是指列向量。</p>
<p>我们当然可以对这一组五维向量进行分析和挖掘，不过我们知道，很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p>
<p><em>降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。</em></p>
<p>举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p>
<p>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。后面的章节中我们会给出相关性的严格数学定义。</p>
<p>这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。</p>
<p>上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？</p>
<p>要回答上面的问题，就要对降维问题进行数学化和形式化的讨论。而$PCA$是一种具有严格数学基础并且已被广泛采用的降维方法。下面我不会直接描述$PCA$，而是通过逐步分析问题，让我们一起重新“发明”一遍$PCA$。</p>
<h1 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h1><p>既然我们面对的数据被抽象为一组向量，那么下面有必要研究一些向量的数学性质。而这些数学性质将成为后续导出$PCA$的理论基础。</p>
<h2 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h2><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p>
<p>$(a_1,a_2,\cdots,a_n)^\mathsf{T}\cdot(b_1,b_2,\cdots,b_n)^\mathsf{T}=a_1b_1+a_2b_2+\cdots+a_nb_n$</p>
<p>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设A和B是两个n维向量，我们知道n维向量可以等价表示为n维空间中的一条从原点发射的有向线段，为了简单起见我们假设A和B均为二维向量，则$A=(x_1,y_1)$，$B=(x_2,y_2)$。则在二维平面上A和B可以用两条发自原点的有向线段表示，见下图：</p>
<p><img src="/2017/10/29/转-PCA/01.png" alt=""></p>
<p>好，现在我们从A点向B所在直线引一条垂线。我们知道垂线与B的交点叫做A在B上的投影，再设A与B的夹角是a，则投影的矢量长度为$|A|cos(a)$，其中$|A|=\sqrt{x_1^2+y_1^2}$是向量A的模，也就是A线段的标量长度。</p>
<p>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。</p>
<p>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：</p>
<script type="math/tex; mode=display">A\cdot B=|A||B|cos(a)</script><p>现在事情似乎是有点眉目了：A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，即让$|B|=1$，那么就变成了：</p>
<script type="math/tex; mode=display">A\cdot B=|A|cos(a)</script><p>也就是说，<strong>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度</strong>！这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。</p>
<h2 id="基"><a href="#基" class="headerlink" title="基"></a>基</h2><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：</p>
<p><img src="/2017/10/29/转-PCA/02.png" alt=""></p>
<p>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为(3,2)，这是我们再熟悉不过的向量表示。</p>
<p>不过我们常常忽略，<strong>只有一个$(3,2)$本身是不能够精确表示一个向量的</strong>。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量(3,2)实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。</p>
<p>更正式的说，向量(x,y)实际上表示线性组合：</p>
<script type="math/tex; mode=display">x(1,0)^\mathsf{T}+y(0,1)^\mathsf{T}</script><p>不难证明所有二维向量都可以表示为这样的线性组合。此处(1,0)和(0,1)叫做二维空间中的一组基。</p>
<p><img src="/2017/10/29/转-PCA/03.png" alt=""></p>
<p>所以，<strong>要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了</strong>。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。</p>
<p>我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。</p>
<p>例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为$(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$和$(-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$。</p>
<p>现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为$(\frac{5}{\sqrt{2}},-\frac{1}{\sqrt{2}})$。下图给出了新的基以及(3,2)在新基上坐标值的示意图：</p>
<p><img src="/2017/10/29/转-PCA/05.png" alt=""></p>
<p>另外这里要注意的是，我们列举的例子中基是正交的（即内积为0，或直观说相互垂直），但可以成为一组基的唯一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p>
<h2 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h2><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：</p>
<script type="math/tex; mode=display">\begin{pmatrix} 1/\sqrt{2} & 1/\sqrt{2} \\ -1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix} \begin{pmatrix} 3 \\ 2 \end{pmatrix} = \begin{pmatrix} 5/\sqrt{2} \\ -1/\sqrt{2} \end{pmatrix}</script><p>太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如$(1,1)，(2,2)，(3,3)$，想变换到刚才那组基上，则可以这样表示：</p>
<script type="math/tex; mode=display">\begin{pmatrix} 1/\sqrt{2} & 1/\sqrt{2} \\ -1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix} \begin{pmatrix} 1 & 2 & 3 \\ 1 & 2 & 3 \end{pmatrix} = \begin{pmatrix} 2/\sqrt{2} & 4/\sqrt{2} & 6/\sqrt{2} \\ 0 & 0 & 0 \end{pmatrix}</script><p>于是一组向量的基变换被干净的表示为矩阵的相乘。</p>
<p><strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果</strong>。</p>
<p>数学表示为：</p>
<script type="math/tex; mode=display">\begin{pmatrix} p_1 \\ p_2 \\ \vdots \\ p_R \end{pmatrix} \begin{pmatrix} a_1 & a_2 & \cdots & a_M \end{pmatrix} = \begin{pmatrix} p_1a_1 & p_1a_2 & \cdots & p_1a_M \\ p_2a_1 & p_2a_2 & \cdots & p_2a_M \\ \vdots & \vdots & \ddots & \vdots \\ p_Ra_1 & p_Ra_2 & \cdots & p_Ra_M \end{pmatrix}</script><p>其中$p_i$是一个行向量，表示第i个基，$a_j$是一个列向量，表示第j个原始数据记录。</p>
<p>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。</p>
<p>最后，上述分析同时给矩阵相乘找到了一种物理解释：<strong>两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去</strong>。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。</p>
<h1 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h1><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p>
<p>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p>
<p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：</p>
<script type="math/tex; mode=display">\begin{pmatrix} 1 & 1 & 2 & 4 & 2 \\ 1 & 3 & 3 & 4 & 4 \end{pmatrix}</script><p>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。</p>
<p>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：</p>
<script type="math/tex; mode=display">\begin{pmatrix} -1 & -1 & 0 & 2 & 0 \\ -2 & 0 & 0 & 1 & 1 \end{pmatrix}</script><p>我们可以看下五条数据在平面直角坐标系内的样子：</p>
<p><img src="/2017/10/29/转-PCA/06.png" alt=""></p>
<p>现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？</p>
<p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p>
<p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p>
<p>以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。</p>
<p>下面，我们用数学方法表述这个问题。</p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：</p>
<script type="math/tex; mode=display">Var(a)=\frac{1}{m}\sum_{i=1}^m{(a_i-\mu)^2}</script><p>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：</p>
<script type="math/tex; mode=display">Var(a)=\frac{1}{m}\sum_{i=1}^m{a_i^2}</script><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p><strong>关于协方差的解释知乎答主<a href="https://www.zhihu.com/question/20852004/answer/134902061" target="_blank" rel="noopener">GRAYLAMB</a>回答的非常赞</strong></p>
<p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p>
<p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p>
<p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p>
<p>$Cov(a,b)=\frac{1}{m}\sum_{i=1}^m{a_ib_i}$</p>
<p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p>
<p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p>
<p>至此，我们得到了降维问题的优化目标：<strong>将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）</strong>。</p>
<h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p>
<p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p>
<p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p>
<script type="math/tex; mode=display">X=\begin{pmatrix} a_1 & a_2 & \cdots & a_m \\ b_1 & b_2 & \cdots & b_m \end{pmatrix}</script><p>然后我们用X乘以X的转置，并乘上系数1/m：</p>
<script type="math/tex; mode=display">\frac{1}{m}XX^\mathsf{T}=\begin{pmatrix} \frac{1}{m}\sum_{i=1}^m{a_i^2} & \frac{1}{m}\sum_{i=1}^m{a_ib_i} \\ \frac{1}{m}\sum_{i=1}^m{a_ib_i} & \frac{1}{m}\sum_{i=1}^m{b_i^2} \end{pmatrix}</script><p>奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p>
<p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：</p>
<p><strong>设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设$C=\frac{1}{m}XX^\mathsf{T}$，则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差</strong>。</p>
<h2 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h2><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>
<p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：</p>
<script type="math/tex; mode=display">\begin{array}{l l l} D & = & \frac{1}{m}YY^\mathsf{T} \\ & = & \frac{1}{m}(PX)(PX)^\mathsf{T} \\ & = & \frac{1}{m}PXX^\mathsf{T}P^\mathsf{T} \\ & = & P(\frac{1}{m}XX^\mathsf{T})P^\mathsf{T} \\ & = & PCP^\mathsf{T} \end{array}</script><p>现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了<strong>寻找一个矩阵P，满足$ PCP^\mathsf{T}$是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件</strong>。</p>
<p>至此，我们离“发明”$PCA$还有仅一步之遥！</p>
<p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p>
<p>由上文知道，协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p>
<p>1）<strong>实对称矩阵不同特征值对应的特征向量必然正交。</strong></p>
<p>2）<strong>设特征向量$\lambda $重数为r，则必然存在r个线性无关的特征向量对应于$\lambda$，因此可以将这r个特征向量单位正交化</strong>。</p>
<p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为$e_1,e_2,\cdots,e_n $，我们将其按列组成矩阵：</p>
<script type="math/tex; mode=display">E=\begin{pmatrix} e_1 & e_2 & \cdots & e_n \end{pmatrix}</script><p>则对协方差矩阵C有如下结论：</p>
<script type="math/tex; mode=display">E^\mathsf{T}CE=\Lambda=\begin{pmatrix} \lambda_1 & & & \\ & \lambda_2 & & \\ & & \ddots & \\ & & & \lambda_n \end{pmatrix}</script><p>其中$\Lambda $为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</p>
<p>以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p>
<p>到这里，我们发现我们已经找到了需要的矩阵P：</p>
<script type="math/tex; mode=display">P=E^\mathsf{T}</script><p>P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照$\Lambda $中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>
<p>至此我们完成了整个$PCA$的数学原理讨论。在下面的一节，我们将给出$PCA$的一个实例。</p>
<h1 id="算法及实例"><a href="#算法及实例" class="headerlink" title="算法及实例"></a>算法及实例</h1><p>为了巩固上面的理论，我们在这一节给出一个具体的$PCA$实例。</p>
<h2 id="PCA-算法"><a href="#PCA-算法" class="headerlink" title="$PCA$算法"></a>$PCA$算法</h2><p>总结一下$PCA$的算法步骤：</p>
<p>设有m条n维数据。</p>
<p>1）将原始数据按列组成n行m列矩阵X</p>
<p>2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</p>
<p>3）求出协方差矩阵$C=\frac{1}{m}XX^\mathsf{T}$</p>
<p>4）求出协方差矩阵的特征值及对应的特征向量</p>
<p>5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</p>
<p>6）$Y=PX $即为降维到k维后的数据</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这里以上文提到的</p>
<script type="math/tex; mode=display">\begin{pmatrix} -1 & -1 & 0 & 2 & 0 \\ -2 & 0 & 0 & 1 & 1 \end{pmatrix}</script><p>为例，我们用$PCA$方法将这组二维数据其降到一维。</p>
<p>因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：</p>
<script type="math/tex; mode=display">C=\frac{1}{5}\begin{pmatrix} -1 & -1 & 0 & 2 & 0 \\ -2 & 0 & 0 & 1 & 1 \end{pmatrix}\begin{pmatrix} -1 & -2 \\ -1 & 0 \\ 0 & 0 \\ 2 & 1 \\ 0 & 1 \end{pmatrix}=\begin{pmatrix} \frac{6}{5} & \frac{4}{5} \\ \frac{4}{5} & \frac{6}{5} \end{pmatrix}</script><p>然后求其特征值和特征向量，具体求解方法不再详述，可以参考相关资料。求解后特征值为：</p>
<script type="math/tex; mode=display">\lambda_1=2,\lambda_2=2/5</script><p>其对应的特征向量分别是：</p>
<script type="math/tex; mode=display">c_1\begin{pmatrix} 1 \\ 1 \end{pmatrix},c_2\begin{pmatrix} -1 \\ 1 \end{pmatrix}</script><p>其中对应的特征向量分别是一个通解，$c_1$和$c_2$可取任意实数。那么标准化后的特征向量为：</p>
<script type="math/tex; mode=display">\begin{pmatrix} 1/\sqrt{2} \\ 1/\sqrt{2} \end{pmatrix},\begin{pmatrix} -1/\sqrt{2} \\ 1/\sqrt{2} \end{pmatrix}</script><p>因此我们的矩阵P是：</p>
<script type="math/tex; mode=display">P=\begin{pmatrix} 1/\sqrt{2} & 1/\sqrt{2} \\ -1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix}</script><p>可以验证协方差矩阵C的对角化：</p>
<script type="math/tex; mode=display">PCP^\mathsf{T}=\begin{pmatrix} 1/\sqrt{2} & 1/\sqrt{2} \\ -1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix}\begin{pmatrix} 6/5 & 4/5 \\ 4/5 & 6/5 \end{pmatrix}\begin{pmatrix} 1/\sqrt{2} & -1/\sqrt{2} \\ 1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix}=\begin{pmatrix} 2 & 0 \\ 0 & 2/5 \end{pmatrix}</script><p>最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：</p>
<script type="math/tex; mode=display">Y=\begin{pmatrix} 1/\sqrt{2} & 1/\sqrt{2} \end{pmatrix}\begin{pmatrix} -1 & -1 & 0 & 2 & 0 \\ -2 & 0 & 0 & 1 & 1 \end{pmatrix}=\begin{pmatrix} -3/\sqrt{2} & -1/\sqrt{2} & 0 & 3/\sqrt{2} & -1/\sqrt{2} \end{pmatrix}</script><p>降维投影结果如下图：</p>
<p><img src="/2017/10/29/转-PCA/07.png" alt=""></p>
<h1 id="进一步讨论"><a href="#进一步讨论" class="headerlink" title="进一步讨论"></a>进一步讨论</h1><p>根据上面对$PCA$的数学原理的解释，我们可以了解到一些$PCA$的能力和限制。<strong>$PCA$本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”，也就是让它们在不同正交方向上没有相关性</strong>。</p>
<p>因此，$PCA$也存在一些限制，例如它可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel $PCA$，通过Kernel函数将非线性相关转为线性相关，关于这点就不展开讨论了。另外，$PCA$假设数据各主特征是分布在正交方向上，如果在非正交方向上存在几个方差较大的方向，$PCA$的效果就大打折扣了。</p>
<p>最后需要说明的是，$PCA$是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以$PCA$便于通用实现，但是本身无法个性化的优化。</p>
<p>希望这篇文章能帮助朋友们了解$PCA$的数学理论基础和实现原理，借此了解$PCA$的适用场景和限制，从而更好的使用这个算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[转载一篇分析全面的PCA文章]]>
    
    </summary>
    
      <category term="PCA" scheme="http://yoursite.com/tags/PCA/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="降维" scheme="http://yoursite.com/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="特征值" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%80%BC/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <link href="http://yoursite.com/2017/10/27/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2017/10/27/剑指offer/</id>
    <published>2017-10-27T00:32:16.000Z</published>
    <updated>2018-03-26T13:20:29.931Z</updated>
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>Q:</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>思路：</strong>思路从右上开始，右上为一行最大，一列最小。target&lt;右上，删一列;  target&gt;右上,删一行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(array) <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>python式。。</p>
<p>其他语言思路：从头到尾遍历数空格数量，然后从后往前遍历，碰到空格后根据之前数好的数量移位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s= s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>Q:</strong>输入一个链表，从尾到头打印链表每个节点的值</p>
<p><strong>思路：</strong>遍历链表每次遍历的val从头插入list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        list = []</span><br><span class="line">        p = listNode</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            list = [p.val] + list</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>Q:</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>思路：</strong>先序第一个为根节点，中序中根节点左边全在左子树，右边全在右子树。据此用递归建树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的解法</span></span><br><span class="line"><span class="comment"># 对len==1的list判定，繁琐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution32</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span> <span class="keyword">and</span> len(tin) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root_index = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="number">0</span>:</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:root_index+<span class="number">1</span>],tin[:root_index])</span><br><span class="line">        <span class="keyword">if</span> root_index != len(tin)<span class="number">-1</span>:</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精简解法</span></span><br><span class="line"><span class="comment"># 对空list的判定，鲁棒性更强，更精简</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">    index = tin.index(root.val)</span><br><span class="line">    root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:index+<span class="number">1</span>], tin[<span class="number">0</span>:index])</span><br><span class="line">    root.right = self.reConstructBinaryTree(pre[index+<span class="number">1</span>:], tin[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>Q:</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>思路：</strong>太简单，不说了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        nums = rotateArray</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> p &gt; <span class="number">0</span> <span class="keyword">and</span> nums[p<span class="number">-1</span>]&lt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[p] &lt; min:</span><br><span class="line">                min = nums[p]</span><br><span class="line">        <span class="keyword">return</span> min</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><strong>Q:</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
<p><strong>思路：</strong>分别用while 与 递归实现</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不用递归，避免重复运算，运行时间短</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution6</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= n:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br><span class="line"><span class="comment"># 递归，代码简单，运行超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution62</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n<span class="number">-1</span>) + self.Fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>思路：</strong>斐波那契数列问题，斐波那契数列前移一位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution7</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<p><strong>思路：</strong></p>
<p>F(n) = F(n-1)+F(n-2)+F(n-3)+….+F(1)</p>
<p>第n项是前n-1项的和，所以第n+1项是第n项的两倍，都是二的指数次方</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution8</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> ** (number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><strong>Q:</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>思路：</strong>还是个斐波那契问题 n*2 矩形覆盖时候最后一步要不覆盖田，要不覆盖日，因此是斐波那契问题F(n) = F(n-1)+F(n-2)只不过题目规定F(0)=0</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution9</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>Q:</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>思路1：</strong>一个整数减去1，再和原整数做 与 运算，会把该整数最右边的1变成0（用补码表示的负数也是）。所以一个整数中有多少个1就可以进行多少次这种运算该法用python写超时</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution10</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>因为右移数字n会造成死循环（负数第一位是1），可以先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算……反复左移就能判断n的其中一位是不是1</p>
<p><strong>注意：</strong>1要是无符号整数(unsigned int)</p>
<p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count ++</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>Q:</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>思路：</strong>Life is short, you need python</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution11</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> pow(base, exponent)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"><a href="#调整数组是奇数位于偶数前并保证奇数偶数各自相对位置" class="headerlink" title="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"></a>调整数组是奇数位于偶数前并保证奇数偶数各自相对位置</h2><p><strong>Q:</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>思路：</strong>一个list存奇数一个list存偶数，两个合起来</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution12</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res1 = []</span><br><span class="line">        res2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">                res2.append(array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res1.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> res1+res2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>构造长度为K的滑窗（构造时考虑K过大问题），将滑窗滑至最后即可</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution13</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        post = pre = head</span><br><span class="line">        count = k</span><br><span class="line">        <span class="keyword">while</span> k<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post = post.next</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post.next:</span><br><span class="line">            post = post.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong>Q:</strong>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p><strong>思路：</strong>比较简单临近双指针遍历至最后，注意最后对边界值的处理</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution14</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        post = pHead.next</span><br><span class="line">        pHead.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                temp = post.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                post.next = pHead</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            post.next = pHead</span><br><span class="line">            pHead = post</span><br><span class="line">            post = temp</span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p><strong>Q:</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>思路：</strong>每次选出两个链表较小的头结点，然后用剩下的递归链接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution15</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="keyword">or</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>Q:</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p><strong>思路1：</strong>递归的查找子结构</p>
<p><strong>注意：</strong></p>
<p>①要全面遍历所有所可能（类似机器人路径中的找出所有起始位置），不能找到一对根节点相等的点，后面不等就return False；    这里体现在相等时候也留一手 or 类似与不等继续进行判断    </p>
<p> ②因为题中给出空节点不是子结构，而我迭代又要用到对pRoot2是否为空的判断，因此，先对pRoot2判断，再单独写了个函数     </p>
<p>③本题求的是子结构而非子树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution16</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">(pRoot1,pRoot2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1.val ==pRoot2.val:</span><br><span class="line">                <span class="comment"># 注意or的运用，遍历所有可能的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (  (Search(pRoot1.left,pRoot2.left) <span class="keyword">and</span> Search(pRoot1.right,pRoot2.right))</span><br><span class="line">                                 <span class="keyword">or</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2) )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2)</span><br><span class="line">        <span class="keyword">return</span> Search(pRoot1,pRoot2)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>更精简的分治递归</p>
<p>写一个函数判断两树是同一根节点的情况下pRoot2是否是pRoot1的子结构</p>
<p>在主函数里递归调用这个函数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(pRoot1,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.left,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.right,pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsSub</span><span class="params">(self,p1,p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> p1.val != p2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(p1.left,p2.left) <span class="keyword">and</span> self.IsSub(p1.right,p2.right)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>Q:</strong>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><strong>思路：</strong>递归实现没什么难度</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution17</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            temp = root.left</span><br><span class="line">            root.left = root.right</span><br><span class="line">            root.right = temp</span><br><span class="line">            Trans(root.left)</span><br><span class="line">            Trans(root.right)</span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><strong>Q:</strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><strong>思路：</strong>通过递归函数实现，每次添加最外一圈</p>
<p><strong>注意：</strong>对行列为2的判断（里面的if判断），过程中一个不满足就代表添加完毕</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution18</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.List = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        row_u = <span class="number">0</span></span><br><span class="line">        row_d = len(matrix) - <span class="number">1</span></span><br><span class="line">        col_l = <span class="number">0</span></span><br><span class="line">        col_r = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Printnum</span><span class="params">(matrix,row_u,row_d,col_l,col_r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> row_u &gt; row_d <span class="keyword">or</span> col_l &gt; col_r:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_l,col_r+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[row_u][j])</span><br><span class="line">                row_u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_u,row_d+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_r])</span><br><span class="line">                col_r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_r,col_l<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[row_d][j])</span><br><span class="line">                row_d -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_d,row_u<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_l])</span><br><span class="line">                col_l += <span class="number">1</span></span><br><span class="line">            Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        <span class="keyword">return</span> self.List</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="包含Min函数的栈"><a href="#包含Min函数的栈" class="headerlink" title="包含Min函数的栈"></a>包含Min函数的栈</h2><p><strong>Q:</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p><strong>思路：</strong>python式。。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution19</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack = self.stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> min(self.stack)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>Q:</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>思路：</strong>弹出一个便从压入list中记录index为p，并删除 这个元素。下一个弹出的元素的index只能是p的前一个位置(pre)或者后面位置，弹出后便继续更新p</p>
<p><strong>注意：</strong>压入list中删除元素后要更新index。list.remove(val)删除后会更新index，正好符合这道题。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution20</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pre = p = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(popV)):</span><br><span class="line">            <span class="comment"># 判断pushV popV是否一致</span></span><br><span class="line">            <span class="keyword">if</span> popV[i] <span class="keyword">not</span> <span class="keyword">in</span> pushV:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pushV.index(popV[i]) &lt; pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p = pushV.index(popV[i])</span><br><span class="line">            pushV.remove(popV[i])</span><br><span class="line">            <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">                pre = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = p - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p><strong>Q:</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>思路：</strong>简单的层序遍历</p>
<p><strong>注意：</strong>node=[] res=[] 跟 node=res=[]的区别，前面两个是两个[]，后面两个是同一个[]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution21</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = []</span><br><span class="line">        res = []</span><br><span class="line">        node.append(root)</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            res.append(node[<span class="number">0</span>].val)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].left:</span><br><span class="line">                node.append(node[<span class="number">0</span>].left)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].right:</span><br><span class="line">                node.append(node[<span class="number">0</span>].right)</span><br><span class="line">            node = node[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的后序遍历序列"><a href="#二叉树的后序遍历序列" class="headerlink" title="二叉树的后序遍历序列"></a>二叉树的后序遍历序列</h2><p><strong>Q:</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>二叉搜索树的中序遍历序列便相当于升序序列，因此将原序列排序便得到中序序列。然后判断能否成树判断能否成树的方法：后序最末位为根节点，通过此节点在中序中的位置（mid_index）分割左右子树节点。</p>
<p><strong><em>递归判断不能成树的条件是：递归中一旦出现两序列节点组成不一致的情况（最重要的思想！！！想死我了）</em></strong></p>
<p><strong>注意：</strong>其实此题不需要用到二叉搜索树left&lt;root&lt;right，或者说这个条件的全部信息都转化为升序序列为中序序列刚看此题想到中序序列以为此题得到解决，但是拘泥于二叉搜索树的性质写不出递归，其实可完全转化为一个中序一个后序能否成树问题。能否成树又可通过递归过程序列组成是否全程一致来判断。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mid = sorted(sequence)</span><br><span class="line">        post = sequence</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Define</span><span class="params">(mid, post)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mid <span class="keyword">and</span> <span class="keyword">not</span> post:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 不能成树的判定</span></span><br><span class="line">            <span class="keyword">if</span> set(mid)!= set(post):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            mid_index = mid.index(post[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> Define(mid[:mid_index],post[:mid_index]) <span class="keyword">and</span> Define(mid[mid_index+<span class="number">1</span>:],post[mid_index:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> Define(mid,post)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p><strong>Q:</strong>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p><strong>思路：</strong>定义全局list：self.res，用rest记录剩下路径所需拟合值，PathList记录当前路径。递归遍历节点如果root.val拟合完毕，将PathList并入全局res，并且rest重置为expectNumber，重置PathList=[]，从孩子节点从头递归；如果root.val不拟合rest，则将这个节点加入当前PathList，左右孩子传承此PathList继续递归寻找接下来的Path，左右孩子也要不继承PathList把rest重置为expectNumber从头递归</p>
<p><strong>注意：</strong></p>
<p>①root.val拟合或者不拟合都要在左右孩子加一个递归重置rest为expectNumber，重置PathList=[]继续寻找     </p>
<p>②左右节点继承当前PathList递归时，PathList要分开指代，要不右节点会继承左节点的PathList     </p>
<p>③PathList2=PathList这种方法指代，这俩指针还是指向同一list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution23</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Path</span><span class="params">(root, expectNumber, rest, PathList=[] )</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.val == rest:</span><br><span class="line">                PathList=PathList+[root.val]</span><br><span class="line">                <span class="comment"># 不加以下这个if结构是任意子路径，加了代表路径结尾必须是叶子节点。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    self.res.append(PathList)</span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                PathList.append(root.val)</span><br><span class="line">                rest -= root.val</span><br><span class="line">                <span class="comment"># 将此节点填入路径继续递归</span></span><br><span class="line">                <span class="comment"># 接下来两个递归会操作同一个PathList，这两个不应该操作统一list</span></span><br><span class="line">                <span class="comment"># 直接令PathList2=PathList这俩还是指向同一个</span></span><br><span class="line">                PathList2 = []</span><br><span class="line">                PathList2 += PathList</span><br><span class="line">                Path(root.left,expectNumber,rest,PathList)</span><br><span class="line">                Path(root.right,expectNumber,rest,PathList2)</span><br><span class="line">                <span class="comment"># 从此节点的子节点开始从头寻找路径</span></span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        Path(root,expectNumber,expectNumber,[])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>Q:</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p><strong>思路1：</strong>难点在给随机指针赋值时候怎样指向已存在的节点，这里的思路是通过next复制节点时，构造原节点与新节点一一对应的字典此方法因为用到哈希，空间复杂度较大</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24</span>:</span></span><br><span class="line">   <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">       Node_dic = &#123;&#125;</span><br><span class="line">       pre = pHead</span><br><span class="line">       clone_head = RandomListNode(pre.label)</span><br><span class="line">       p = clone_head</span><br><span class="line">       Node_dic[pre] = p</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           pre = pre.next</span><br><span class="line">           <span class="keyword">if</span> pre :</span><br><span class="line">               temp = RandomListNode(pre.label)</span><br><span class="line">               p.next = temp</span><br><span class="line">               p=p.next</span><br><span class="line">               <span class="comment"># 边复制节点边构造哈希表</span></span><br><span class="line">               Node_dic[pre] = p</span><br><span class="line">       pre = pHead</span><br><span class="line">       p = clone_head</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           <span class="keyword">if</span> pre.random:</span><br><span class="line">               p.random = Node_dic[pre.random]</span><br><span class="line">           pre = pre.next</span><br><span class="line">           p = p.next</span><br><span class="line">       <span class="keyword">return</span> clone_head</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>省去了空间复杂度，复制链表时一一间隔，将新节点插入原链表</p>
<p><strong>注意：</strong>不能用一个while（调整random指针的while）直接将合并的链表拆开</p>
<p>因为如果有random指向前面会出错，因为已经不是一一间隔了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24_2</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="comment"># 将新节点一一间隔插入原链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = RandomListNode(p.label)</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        new_head = pre.next</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            <span class="keyword">if</span> pre.random:</span><br><span class="line">                post.random = pre.random.next</span><br><span class="line">            pre = post.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> pre.next:</span><br><span class="line">                post = pre.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        <span class="comment"># 不能直接在上一个while直接将两链表分开，如果有random指向前面会出错，因为已经不是一一间隔了</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            pre.next = post.next</span><br><span class="line">            <span class="comment"># 考虑到尾节点情况</span></span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post.next = post.next.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">            post = post.next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>Q:</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路：</strong>二叉搜索树中序序列便是升序序列，用中序遍历构造链表</p>
<p><strong>注意：</strong>需要两个全局变量记录起点指针self.head，还有上一节点的指针self.p</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution25</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = <span class="keyword">None</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = pRootOfTree</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#temp保留右指针</span></span><br><span class="line">            temp_left = root.left</span><br><span class="line">            temp_right = root.right</span><br><span class="line">            self.Convert(temp_left)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.p:</span><br><span class="line">                self.p = root</span><br><span class="line">                self.head = root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.p.right = root</span><br><span class="line">                root.left = self.p</span><br><span class="line">                self.p = root</span><br><span class="line">            self.Convert(temp_right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>Q:</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>思路1：</strong>先用递归将所有可能的情况列出来，用sorted（）解决字典排序问题列出所有情况的方法：分成两个列表s1,s2 ，每次s2中的一个元素加入s1当做下一个s1，其余元素当做下一个s2，进行递归自己的解法：非常不优雅，先将str转为list，在转为str添加进去，还用到了py自带的排序解决字典序问题    如果不用自带排序，则可以参考LeetCode31</p>
<p><strong>注意：</strong>因为python中的字符串不可以更改，所以，先将str转为list，在转为str添加进去</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">allkinds</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">1</span>:</span><br><span class="line">                s = <span class="string">''</span>.join(s1+s2)</span><br><span class="line">                self.res.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                <span class="comment"># 将选中元素替换到s2第一位</span></span><br><span class="line">                temp = s2[i]</span><br><span class="line">                s2[i]=s2[<span class="number">0</span>]</span><br><span class="line">                s2[<span class="number">0</span>]=temp</span><br><span class="line">                allkinds(s1+[s2[<span class="number">0</span>]],s2[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = sorted(ss)</span><br><span class="line">        allkinds([],s)</span><br><span class="line">        self.res = list(set(self.res))</span><br><span class="line">        <span class="keyword">return</span> sorted(self.res)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>itertools.permutations用来返回所有排列（元组形式）的list’’.join() 将list、元组内的字符结合成字符串map函数将f应用于右边可迭代的每一个对象</p>
<p>Code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join,itertools.permutations(ss)))))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><strong>Q:</strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>思路1：</strong>python式</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput)[:k]</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>partition函数法（快排）：如果下标刚好是k(k-1)则左边(k-1则包含本身)便是所求，如果下标&gt;k则递归左边，下标&lt;k递归右边</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Partition</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = len(nums) - <span class="number">1</span></span><br><span class="line">            temp = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> nums[j] &gt; temp:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[i] &lt;= temp:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i] = temp</span><br><span class="line">            <span class="keyword">if</span> i == k - <span class="number">1</span> <span class="keyword">or</span> i == k - <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; k - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[:i], k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[i + <span class="number">1</span>:], k - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        Partition(tinput, k)</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput[:k])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p><strong>Q:</strong>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
<p><strong>思路：</strong></p>
<p>两个变量分别记录当前累加值(self.temp)与最大累加值(self.Max)。从头到尾累加数字如果self.temp&lt;0则在每次累加之前将其置0。<em>最关键一点就是用self.temp</em>记录最大值</p>
<p>动态规划思想：用f(i)表示以第i个数字结尾的子数组的最大和则max（f(i)）可由一下迭代公式求f(i)=Data<a href="i=0或f(i-1">i</a>&lt;=0)    f(i)=f(i-1)+Data<a href="i!=0并且f(i-1">i</a>&gt;0)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">-99</span></span><br><span class="line">        self.Max = <span class="number">-99</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> self.temp &lt; <span class="number">0</span>:</span><br><span class="line">                self.temp = <span class="number">0</span></span><br><span class="line">            self.temp += array[i]</span><br><span class="line">            <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">                self.Max = self.temp</span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h2><p><strong>Q:</strong>求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<p><strong>思路：</strong></p>
<p>10个数里面有1个个位1；每100个数里面有10个十位1（10、11、12……19）；每1000个数里面有100个百位1 ……</p>
<p>另外需要判断是否应该考虑剩余部分，剩余部分需要判断如115 里面有 10 + (115-110+1) 个十位1</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution30</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># count代表n的位数</span></span><br><span class="line">        count = len(str(n))</span><br><span class="line">        <span class="comment"># 这里相当于两位到 count-1位 第count 位要单独讨论</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,count+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># count为完整的倍数</span></span><br><span class="line">            times = n//(<span class="number">10</span>**i)</span><br><span class="line">            <span class="comment"># num 为每一份对应的1的个数</span></span><br><span class="line">            num = <span class="number">10</span> ** (i<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># rest 为除掉完整的份数剩下的</span></span><br><span class="line">            rest = n - times*(<span class="number">10</span>**i)</span><br><span class="line">            result += times * num</span><br><span class="line">            <span class="keyword">if</span> rest &gt;= <span class="number">2</span> * (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> rest &lt; (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += rest - (<span class="number">10</span>**(i<span class="number">-1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="将数组排成最小的数"><a href="#将数组排成最小的数" class="headerlink" title="将数组排成最小的数"></a>将数组排成最小的数</h2><p><strong>Q:</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>思路：</strong>全部转化为字符串，用itertools.permutations列出全组合，直接用min 找全组合中最小的</p>
<p><strong>注意：</strong>对itertools.permutations、map()、’ ‘.join的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            numbers[i] = str(numbers[i])</span><br><span class="line">        List = map(<span class="string">''</span>.join,list(itertools.permutations(numbers,len(numbers))))</span><br><span class="line">        <span class="keyword">return</span> int(min(List))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p><strong>Q:</strong>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p><strong>思路1：</strong>非递归，用栈</p>
<p>序列化：先序遍历得到字符串    </p>
<p> 反序列化：用栈记录字符串的节点，非#时入栈，flag指向添加方式1为左0为右，flag= =0时出栈，新元素入栈时flag = =1        遇到#号时flag= =0</p>
<p>注意：链接节点时候一定要注意指针。要用原节点去链接，而不是构造与原节点相同的节点链接（见注释）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_7_mine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        root = TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        stack = [root]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        flag = <span class="number">1</span> <span class="comment"># flag==1指示left添加且不用退栈，flag==0指示右边添加且要退栈</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].left = TreeNode(s[i])</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(stack[<span class="number">-1</span>].left)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].right = TreeNode(s[i])</span><br><span class="line">                    pop_node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(pop_node.right)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].left = None</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].right = None</span></span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>精简的递归思路</p>
<p>①通过 def <strong>init</strong>(self):构造flag全局变量指示遍历位置</p>
<p>②通过self.flag指示list位置建树，建树过程类似遍历过程，只不过遇到#return</p>
<p>③注意l元素本身为字符，给节点赋值时注意int化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.flag = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code her</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        l = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= len(l):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> l[self.flag] == <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(int(l[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的第K个节点"><a href="#二叉树的第K个节点" class="headerlink" title="二叉树的第K个节点"></a>二叉树的第K个节点</h2><p><strong>Q:</strong>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<p><strong>思路：</strong>二叉搜索树中序遍历就是升序</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_5</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,res=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left,res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            dfs(root.right,res)</span><br><span class="line">        dfs(pRoot,res)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>] <span class="keyword">if</span> k&lt;=len(res) <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p><strong>Q:</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>思路：</strong>先用嵌套for循环找出所有起始位置，对每个位置依次用递归函数搜寻</p>
<p><strong>注意：</strong>每次开始要用新的空list记录路径</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ok = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            ok.append([])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            ok[_//cols].append(matrix[_])</span><br><span class="line">        init = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                    init.append([i,j])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,ok,path,List=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=rows <span class="keyword">or</span> j&gt;=cols <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                List.append([i,j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (search(i+<span class="number">1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j+<span class="number">1</span>,rows,cols,ok,path[<span class="number">1</span>:],List)</span><br><span class="line">                                <span class="keyword">or</span> search(i<span class="number">-1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j<span class="number">-1</span>,rows,cols,ok,path[<span class="number">1</span>:],List))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(init)):</span><br><span class="line">            <span class="keyword">if</span> search(init[x][<span class="number">0</span>],init[x][<span class="number">1</span>],rows, cols, ok, path,[]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="机器人运动范围"><a href="#机器人运动范围" class="headerlink" title="机器人运动范围"></a>机器人运动范围</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>递归模拟机器人走路，用个列表记录机器人走过的路就行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(x)</span>:</span></span><br><span class="line">           res = <span class="number">0</span></span><br><span class="line">           <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">               res += x % <span class="number">10</span></span><br><span class="line">               x = x//<span class="number">10</span></span><br><span class="line">           <span class="keyword">return</span> res</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,threshold,List=[])</span>:</span></span><br><span class="line">           <span class="keyword">if</span> threshold&lt;<span class="number">0</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">if</span> i&gt;=cols <span class="keyword">or</span> j&gt;=rows <span class="keyword">or</span> Sum(i)+Sum(j)&gt;threshold <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               List.append([i,j])</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>+search(i+<span class="number">1</span>,j,rows,cols,threshold,List)+search(i,j+<span class="number">1</span>,rows,cols,threshold,List)</span><br><span class="line">       <span class="keyword">return</span> search(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><p><strong>Q:</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>思路：</strong>有right就沿着right的left一直找下去找到尽头没有right就沿着父节点一直向上找，直到导找到该节点是父节点的left</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        p = pNode</span><br><span class="line">        <span class="keyword">if</span> p.right:</span><br><span class="line">            post = p.right</span><br><span class="line">            <span class="keyword">while</span> post.left:</span><br><span class="line">                post = post.left</span><br><span class="line">            <span class="keyword">return</span> post</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            <span class="keyword">if</span> p.next.left == p:</span><br><span class="line">                <span class="keyword">return</span> p.next</span><br><span class="line">            p = p.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>Q:</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p><strong>思路1：</strong>用self.temp记录当前深度，self.Max记录最大深度。先序self.temp+1，后序self.temp-1注意：不要思维定式先中后序只用一个</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">0</span></span><br><span class="line">        self.Max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.temp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">            self.Max = self.temp</span><br><span class="line">        self.TreeDepth(pRoot.left)</span><br><span class="line">        self.TreeDepth(pRoot.right)</span><br><span class="line">        self.temp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<p>**思路2：更棒的方法</p>
<p>通过 <strong><em>左子树或右子树最大深度+1为当前子树深度</em></strong> 进行递归</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>Q:</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p><strong>思路1：</strong>写一个递归函数判断深度，注意对max(left,right)的运用，即<strong><em>左子树或右子树最大深度+1为当前子树的深度（写出递归的关键所在）</em></strong>然后从根节点开始递归判断每个节点</p>
<p>缺点：根节点开始递归判断每个节点缺点：重复遍历节点，时间复杂度高</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> abs( self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right) ) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>同样写一个递归函数判断深度，但是一旦出现不满足返回值便为 -1 ，同时在后序中  left &lt; 0 or right &lt; 0 的运用保证了一旦出现非平衡子树，-1就一直会传递到最后，最后只需在主函数中判断深度是否 &gt;=0 。</p>
<p><strong><em>对 -1 的传递真是太赞，好好体会</em></strong></p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.TreeDepth(pRoot) &gt;= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> abs(left - right) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p><strong>Q:</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>思路：</strong>写递归函数（输入为两个节点）递归比较，递归方式为haha(left.left,right.right) and haha(left.right,right.left)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(pRoot.left,pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> left.val != right.val :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(left.left,right.right) <span class="keyword">and</span> self.haha(left.right,right.left)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h2><p><strong>Q:</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        NodeList = [pRoot]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> NodeList:</span><br><span class="line">            NextLayer = []</span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> NodeList:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            NodeList = NextLayer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。最后按照奇偶顺序修改val列表即可。</p>
<p><strong>注意：</strong>将节点加入NextLayer时要判断存在与否，否则空类型也会被添加</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># Nodeque为循环遍历的node list</span></span><br><span class="line">        Nodeque = [pRoot]</span><br><span class="line">        <span class="comment"># res为嵌套list,每个元素list为每层的val</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</span></span><br><span class="line">        <span class="comment"># 即每一圈while为每层的处理</span></span><br><span class="line">        <span class="keyword">while</span> Nodeque:</span><br><span class="line">            <span class="comment"># NextLayer为本层节点的所有孩子节点</span></span><br><span class="line">            NextLayer = []</span><br><span class="line">            <span class="comment"># ValList存取本层所有节点的val</span></span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> Nodeque:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            Nodeque = NextLayer</span><br><span class="line">        transres = []</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(res):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                transres.append(v[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                transres.append(v)</span><br><span class="line">        <span class="keyword">return</span> transres</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p><strong>Q:</strong>输入两个链表，找出它们的第一个公共结点。这里的是指两个链表在某个节点之后会汇入同一个链表。</p>
<p><strong>思路：</strong>最后两个链表汇入一个链表，即最后公共长度是一样的。因此可以先遍历两个链表，得出长度差在较长链表上提前多走长度差的步数，再一一比较</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        length1 = <span class="number">0</span></span><br><span class="line">        length2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            length1 += <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            length2 += <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        differ = abs(length1 - length2)</span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val == p2.val:</span><br><span class="line">                <span class="keyword">return</span> p1</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组中出现次数超过一半的元素"><a href="#数组中出现次数超过一半的元素" class="headerlink" title="数组中出现次数超过一半的元素"></a>数组中出现次数超过一半的元素</h2><p><strong>Q:</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p><strong>思路1：</strong>用哈希记录每个元素出现的次数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[numbers[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[numbers[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dic[numbers[i]]&gt;len(numbers)/<span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> numbers[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>如果有个元素出现超过一半，那么这个元素比其他元素都多（废话）。据此，count记录所存储元素的计数，temp记录所存取元素。count == 0时，temp变为当前元素，count置1；count != 0时， 当前元素与temp相等，count+1否则-1;结束遍历一遍temp元素，看看是否次数超过一半。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        temp = <span class="number">-99</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                temp = i</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i != temp:</span><br><span class="line">                    count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        kan = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == temp:</span><br><span class="line">                kan += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> kan &gt; len(numbers) // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p><strong>Q:</strong>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>思路：</strong>考虑o(N)的用丑数生成丑数，不再遍历多余的非丑数。建立uglynums列表按顺序保存丑数。除了1以外，丑数肯定是排在之前的丑数乘以2、3、5的结果。问题在于怎样确保列表里面的丑数是排好顺序的。假设最大丑数为M，计算下一个丑数时小于M的肯定已经在列表当中。对于乘以2而言，肯定存在某一个丑数，排在它之前的每个丑数乘以2都小于M，排在它之后的每个丑数乘以2都远大于M，我们只需要记录下这个丑数的位置m2，对于乘以3和5，同样存下m3、m5.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">    <span class="number">1.</span>更新标记只需要 +<span class="number">1</span> 即可，+<span class="number">1</span>之后再用到肯定大于M</span><br><span class="line">    <span class="number">2.</span>此代码精彩的地方在于省略了对新丑数是否=M的判断，见下一条</span><br><span class="line">    <span class="number">3.</span>有可能有几个数同时得到要添加的数值，如<span class="number">6</span>（<span class="number">2</span>*<span class="number">3</span>，<span class="number">3</span>*<span class="number">2</span>）则m2,m3需要同时更新，这里的三个并列的if相当于省略了对更新的数</span><br><span class="line">是否=M的判断</span><br></pre></td></tr></table></figure>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        uglynums = [<span class="number">1</span>]</span><br><span class="line">        m2 = m3 = m5 =<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,index+<span class="number">1</span>):</span><br><span class="line">            uglynums.append(min(uglynums[m2]*<span class="number">2</span>, uglynums[m3]*<span class="number">3</span>, uglynums[m5]*<span class="number">5</span>))</span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m2]*<span class="number">2</span>:</span><br><span class="line">                m2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m3]*<span class="number">3</span>:</span><br><span class="line">                m3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m5]*<span class="number">5</span>:</span><br><span class="line">                m5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> uglynums[index<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><p><strong>Q:</strong>统计一个数字在排序数组中出现的次数。</p>
<p><strong>思路：</strong>二分查找找到一个target，返回index，然后往两边扩展</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Getindex</span><span class="params">(self, data, left, right, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] == k:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> data[mid] &lt; k:</span><br><span class="line">            <span class="keyword">return</span> self.Getindex(data, mid+<span class="number">1</span>, right,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.Getindex(data,left,mid<span class="number">-1</span>,k)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(data) - <span class="number">1</span></span><br><span class="line">        flag = self.Getindex(data, left, right, k)</span><br><span class="line">        <span class="keyword">if</span> flag &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = r = flag</span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">1</span> <span class="keyword">and</span> data[l<span class="number">-1</span>] == k:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[<span class="number">0</span>] == k:</span><br><span class="line">                l =<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> r &lt;= len(data) - <span class="number">2</span> <span class="keyword">and</span> data[r+<span class="number">1</span>] == k:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[right] == k:</span><br><span class="line">                r = right</span><br><span class="line">            <span class="keyword">return</span> r - l + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p><strong>Q：</strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p>
<p><strong>思路：</strong>根据归并排序改编，每次合并两个数组排序时，查找两个数组中的逆序对，因为单个数组已经排好序，所以只需考虑两个数组之间的逆序对。具体方法是，见代码注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution34</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.guibing(data)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guibing</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        mid = len(data) // <span class="number">2</span></span><br><span class="line">        left = self.guibing(data[:mid])</span><br><span class="line">        right = self.guibing(data[mid:])</span><br><span class="line">        <span class="comment"># left_len 用于left、right合并最后right剩余时候计算剩余right的逆序对</span></span><br><span class="line">        left_len = len(left)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="comment"># 比较left、right最后一位，将大的从头插入res</span></span><br><span class="line">            <span class="comment"># 如果left[-1]大，此时right的长度就是left[-1]对应的逆序对数</span></span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">-1</span>] &gt; right[<span class="number">-1</span>]:</span><br><span class="line">                self.count += len(right)</span><br><span class="line">                res.insert(<span class="number">0</span>, left.pop(<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>, right.pop(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left + res</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right + res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="孩子们的游戏"><a href="#孩子们的游戏" class="headerlink" title="孩子们的游戏"></a>孩子们的游戏</h2><p><strong>Q：</strong>让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p><strong>思路：</strong>用取余数操作表示循环队列，kid存储每轮剩余孩子编号。每次的（余数$-1$）相当于下次多走的步数，同时每次过后 $hc$(除数)$-1$，并在kid中pop掉。</p>
<p><strong>注意：</strong>余数是$0$相当于下次多走（除数$-1$）步！而不是多走$-1$步！<br>            每次更新$M$要用$m$！不能用$M$！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        kid = list(range(n))</span><br><span class="line">        hc = n <span class="comment">#当前圈里还剩的孩子个数</span></span><br><span class="line">        M = m <span class="comment">#M表示每次要走的步数</span></span><br><span class="line">        <span class="keyword">while</span> hc &gt; <span class="number">1</span>:</span><br><span class="line">            temp = M % hc</span><br><span class="line">            kid.pop(temp<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                M = temp + m <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                M = m</span><br><span class="line">            hc -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> kid[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[剑指offer刷题记录]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <link href="http://yoursite.com/2017/10/26/LeetCode/"/>
    <id>http://yoursite.com/2017/10/26/LeetCode/</id>
    <published>2017-10-26T01:13:07.000Z</published>
    <updated>2018-03-25T04:30:14.699Z</updated>
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.Two Sum</h2><p><strong>Q:</strong>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典，key为值，val为值所对应位置</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tag = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> tag:</span><br><span class="line">                <span class="keyword">return</span>[tag[nums[i]],i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tag[target-nums[i]]=i</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h2><p><strong>Q:</strong>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        takeover = <span class="number">0</span></span><br><span class="line">        root = n = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> takeover:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                takeover += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                takeover += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            takeover, val = divmod(takeover, <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># 以下两行可以写成</span></span><br><span class="line">            <span class="comment"># n.next = n = ListNode(val)</span></span><br><span class="line">            n.next = ListNode(val)</span><br><span class="line">            n = n.next</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.Longest Substring Without Repeating Characters</h2><p><strong>Q:</strong>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="string">"abcabcbb"</span>, the answer <span class="keyword">is</span> <span class="string">"abc"</span>, which the length <span class="keyword">is</span> <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"bbbbb"</span>, the answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> the length of <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"pwwkew"</span>, the answer <span class="keyword">is</span> <span class="string">"wke"</span>, <span class="keyword">with</span> the length of <span class="number">3.</span> Note that the answer must be a substring, <span class="string">"pwke"</span> <span class="keyword">is</span> a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典key为值，val为该值最后一次出现的位置，用指针pre指向每次寻找的子串的开头位置</p>
<p><strong>注意：</strong>自己思路是对的，但是错在没考虑嵌套重复如 abcddoua 遍历到第二个d时候重复pre指向第二个d 而遍历到第二个a时pre指向第一个a后的b，显然错的（即pre应该始终在字典回溯值之前，pre只能向后移动）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringonglen</span><span class="params">(s)</span>:</span></span><br><span class="line">    usedchar = &#123;&#125;</span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedchar <span class="keyword">and</span> pre &lt;= usedchar[s[i]]:</span><br><span class="line">            pre = usedchar[s[i]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxlen = max(maxlen, i-pre+<span class="number">1</span>)</span><br><span class="line">        usedchar[s[i]] = i</span><br><span class="line">    <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p><strong>Q:</strong>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"babad"</span></span><br><span class="line"></span><br><span class="line">Output: <span class="string">"bab"</span></span><br><span class="line"></span><br><span class="line">Note: <span class="string">"aba"</span> <span class="keyword">is</span> also a valid answer.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①for遍历选中心元素，找齐所有中心元素（第一个while 向后 找出所有与所选中心元素重复的元素）  </p>
<p> ② l r 指示回文边界，向两遍扩展</p>
<p><strong>注意：</strong></p>
<p>①l r 始终指向有效边界（闭区间，考虑边界值仍然是回文区域） </p>
<p> ②注意边界情况判断，如第一个while循环判定条件有两个，应该把边界判断放在前面，要不会出现index越界</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    maxlen = real_l = real_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">        l, r, pos = i, i, i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ( pos &lt;= len(s) - <span class="number">1</span>) <span class="keyword">and</span> s[r] == s[pos]:</span><br><span class="line">            r = pos</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">1</span> <span class="keyword">and</span> r &lt; (len(s) - <span class="number">1</span>)) <span class="keyword">and</span> s[l - <span class="number">1</span>] == s[r + <span class="number">1</span>]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; maxlen:</span><br><span class="line">            maxlen = r - l + <span class="number">1</span></span><br><span class="line">            real_l = l</span><br><span class="line">            real_r = r</span><br><span class="line">    <span class="keyword">return</span> s[real_l:real_r+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h2><p><strong>Q:</strong>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output: <span class="number">-321</span></span><br><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output: <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①flag表示符号判断正数1负数-1</p>
<p> ②将int转为字符串形式，[::-1]表示字符串反转</p>
<p> ③bit_length表示位数的判断</p>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span>:</span></span><br><span class="line">    flag = (x&gt;<span class="number">0</span>)-(x&lt;<span class="number">0</span>)</span><br><span class="line">    val = flag*int(str(abs(x))[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> val*(val.bit_length()&lt;<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h2><p><strong>Q:</strong>Implement <code>atoi</code> to convert a string to an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>此题太乱没做，总结答案</p>
<ol>
<li><p>str.strip（）用于移除首位指定字符串</p>
</li>
<li><p>str.isdigit()判断字符是否是数值</p>
</li>
<li><p>ord()将字符转换为ASCII码 chr()将ASCII码转为字符如ord(‘a’)</p>
<p> -&gt;  97    chr(97)  -&gt;  ‘a’4. 字符串跟数值问题注意overflow问题，这里是有符号函数所以max=2<strong>31-1 min=-2</strong>31</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type str: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">###better to do strip before sanity check (although 8ms slower):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ls = list(s.strip())</span><br><span class="line"></span><br><span class="line">    sign = <span class="number">-1</span> <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ls[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'-'</span>, <span class="string">'+'</span>]: <span class="keyword">del</span> ls[<span class="number">0</span>]</span><br><span class="line">    ret, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(ls) <span class="keyword">and</span> ls[i].isdigit():</span><br><span class="line">        ret = ret * <span class="number">10</span> + ord(ls[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">-2</span> ** <span class="number">31</span>, min(sign * ret, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h2><p><strong>Q:</strong>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.负数不是回文数、非零且末位为零不是回文数</p>
<p>2.用数字一半部分来比较避免了翻转数字overflow问题（赞）</p>
<p><strong>注意：</strong></p>
<p>注意对大数的处理（用数字一半部分作比较）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; res:</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x = x // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> (x == res <span class="keyword">or</span> x == res // <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11.Container With Most Water"></a>11.Container With Most Water</h2><p><strong>Q:</strong>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>分析此题可以得到一个解题基础：最终得到的两块挡板左挡板L和右挡板R，L左边的所有挡板一定短于L，R右边的所有挡板一定短于R。据此，可以从轴两遍开始向内遍历，每次记录最值，并且下次从较短的挡板继续向内遍历。</p>
<p><strong>注意：</strong></p>
<p>注意对python 中用while True:    if XX:     break  来代替do while</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">( height)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type height: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(height) - <span class="number">1</span></span><br><span class="line">    l_h = height[l]</span><br><span class="line">    r_h = height[r]</span><br><span class="line">    val = maxval = min(l_h, r_h) * (r - l)</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r):</span><br><span class="line">        <span class="keyword">if</span> l_h &lt;= r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[l] &gt; l_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        l_h = height[l]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> l_h &gt; r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[r] &gt; r_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        r_h = height[r]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val = min(l_h, r_h) * (r - l)</span><br><span class="line">        <span class="keyword">if</span> val &gt; maxval:</span><br><span class="line">            maxval = val</span><br><span class="line">    <span class="keyword">return</span> maxval</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14.Longest Common Prefix"></a>14.Longest Common Prefix</h2><p><strong>Q:</strong>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到字符串们的最长前缀</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>关于zip()以及zip(* )的用法</p>
<p>前者相当于压缩到一个list中，后者相当于分开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">c=[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line"></span><br><span class="line">x,y,z=zip(*zz)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>)]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type strs: List[str]</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, group <span class="keyword">in</span> enumerate(zip(*strs)):</span><br><span class="line">        <span class="keyword">if</span> len(set(group)) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">    <span class="keyword">return</span> min(strs)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="15-3-Sum"><a href="#15-3-Sum" class="headerlink" title="15.3 Sum"></a>15.3 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>开头 排序 为了跳过重复元素（用dup记录上一元素）遍历一次用twosum函数返回（twosum函数也要去重）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        result = []</span><br><span class="line">        dup = <span class="number">-999</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != dup:</span><br><span class="line">                result.extend(self.twosum(nums[i],nums[i+<span class="number">1</span>:],nums[i]*<span class="number">-1</span>))</span><br><span class="line">            dup = nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twosum</span><span class="params">(self,p,arr,val)</span>:</span></span><br><span class="line">        box = set()</span><br><span class="line">        threesum = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> (val-arr[i] <span class="keyword">in</span> box):</span><br><span class="line">                temp = sorted([p,arr[i],val-arr[i]])</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> threesum:</span><br><span class="line">                    threesum.append(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                box.add(arr[i])</span><br><span class="line">        <span class="keyword">return</span> threesum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="16-3-Sum-Closest"><a href="#16-3-Sum-Closest" class="headerlink" title="16.3 Sum Closest"></a>16.3 Sum Closest</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = &#123;<span class="number">-1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">-4</span>&#125;, <span class="keyword">and</span> target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">    The sum that <span class="keyword">is</span> closest to the target <span class="keyword">is</span> <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>排序后根据大小查找</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    close = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        k = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;k:</span><br><span class="line">            sum = nums[i]+nums[j]+nums[k]</span><br><span class="line">            <span class="keyword">if</span> sum == target:</span><br><span class="line">                <span class="keyword">return</span> sum</span><br><span class="line">            <span class="keyword">if</span> abs(target-sum) &lt; abs(target-close):</span><br><span class="line">                close = sum</span><br><span class="line">            <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> close</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17-Letter-Combinations-of-a-Phone-Numbert"><a href="#17-Letter-Combinations-of-a-Phone-Numbert" class="headerlink" title="17.Letter Combinations of a Phone Numbert"></a>17.Letter Combinations of a Phone Numbert</h2><p><strong>Q:</strong>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>递归思想 字符串拼接用 +</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type digits: str</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mapping = &#123;<span class="string">'0'</span>: <span class="string">' '</span>, <span class="string">'1'</span>: <span class="string">''</span>, <span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span></span><br><span class="line">        , <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list(mapping[digits[<span class="number">0</span>]])</span><br><span class="line">    pre_comb = self.letterCombinations(digits[:<span class="number">-1</span>])</span><br><span class="line">    last = mapping[digits[<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> [s + v <span class="keyword">for</span> s <span class="keyword">in</span> pre_comb <span class="keyword">for</span> v <span class="keyword">in</span> last]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="18-4-Sum"><a href="#18-4-Sum" class="headerlink" title="18.4 Sum"></a>18.4 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>列表之间的拼接用 ‘+’先两层嵌套for循环将所有两两组合之和求出来，再用twosum思想</p>
<p>去重</p>
<p>保证每个元素只添加一次(通过变量保存下标而不是值)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            twosum = nums[i] + nums[j]</span><br><span class="line">            <span class="keyword">if</span> target - twosum <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">for</span> two <span class="keyword">in</span> range(len(dic[target - twosum])):</span><br><span class="line">                    thisfour = sorted([nums[i], nums[j]] +</span><br><span class="line">                                      [nums[dic[target - twosum][two][<span class="number">0</span>]], nums[dic[target - twosum][two][<span class="number">1</span>]]])</span><br><span class="line">                    <span class="comment"># and前条件用于去重；and后条件用于去除元素是否重复利用</span></span><br><span class="line">                    <span class="keyword">if</span> thisfour <span class="keyword">not</span> <span class="keyword">in</span> result <span class="keyword">and</span> len(set([i, j]) | set(dic[target - twosum][two])) == <span class="number">4</span>:</span><br><span class="line">                        result.append(thisfour)</span><br><span class="line">            <span class="keyword">if</span> twosum <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[twosum] = [[i, j]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[twosum].append([i, j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a>19.Remove Nth Node From End of List</h2><p><strong>Q:</strong>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p>
<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>构造一个长度为n的滑窗，滑到最后注意判断如果删除了第一个元素（此时post.next = null）应返回head.next</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pre = head</span><br><span class="line">    post = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        post = post.next</span><br><span class="line">    <span class="comment"># 注意这一步，如果删除的是head，直接返回head.next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> post:</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    <span class="keyword">while</span> post.next:</span><br><span class="line">        pre = pre.next</span><br><span class="line">        post = post.next</span><br><span class="line">    pre.next = pre.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><p><strong>Q:</strong>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not..</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>not valid 只有三种情况，找准这三种情况的特点注意一手对ord()的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">'('</span>,<span class="string">'&#123;'</span>,<span class="string">'['</span>]:</span><br><span class="line">            stack = stack + [s[i]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(stack)==<span class="number">0</span>:       <span class="comment"># 右括号比左括号多的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">1</span> <span class="keyword">and</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">2</span>:       <span class="comment">#左右括号不对称的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:                           <span class="comment"># 左括号比右括号多的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p><strong>Q:</strong>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.正常思路，用and终止while，l1 或 l2 的尾巴可以一并加上</p>
<p>2.递归思想找准结束条件，链表一个一个拼接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">( l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            p.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        p = p.next</span><br><span class="line">    p.next = l1 <span class="keyword">or</span> l2       <span class="comment">#加上小尾巴</span></span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line"><span class="comment"># 递归做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22.Generate Parentheses"></a>22.Generate Parentheses</h2><p><strong>Q:</strong>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>不带返回值的递归（用于添加或者修改），递归生成每个str</p>
<p>Left right 分别为左右括号的计数器</p>
<p>Init_str为目前生成的字符串</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left, right, init_str = n, n, <span class="string">''</span></span><br><span class="line">        result = []</span><br><span class="line">        self.generate(left,right,init_str,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self,left,right,init_str,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            result.append(init_str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            self.generate(left<span class="number">-1</span>,right,init_str+<span class="string">'('</span>,result)</span><br><span class="line">        <span class="comment">#left &lt; right 为添加右括号条件</span></span><br><span class="line">        <span class="keyword">if</span> right <span class="keyword">and</span> left &lt; right:</span><br><span class="line">            self.generate(left,right<span class="number">-1</span>,init_str+<span class="string">')'</span>,result)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs"><a href="#24-wap-Nodes-in-Pairs" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs-1"><a href="#24-wap-Nodes-in-Pairs-1" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26.Remove Duplicates from Sorted Array"></a>26.Remove Duplicates from Sorted Array</h2><p><strong>Q:</strong>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line">It doesn<span class="string">'t matter what you leave beyond the new length.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单题，在数组内删除重复元素，两个指针write、read,修改时候</p>
<p>A[write + 1] = A[read]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        write = <span class="number">0</span></span><br><span class="line">        read = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(A):</span><br><span class="line">            <span class="keyword">if</span> A[write] != A[read]:</span><br><span class="line">                <span class="comment"># 修改重复元素的方法</span></span><br><span class="line">                A[write + <span class="number">1</span>] = A[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">        A = A[:write + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(A)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27.Remove Element"></a>27.Remove Element</h2><p><strong>Q:</strong>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单的双指针</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        read = write =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[read] != val:</span><br><span class="line">                nums[write] = nums[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">            read += <span class="number">1</span></span><br><span class="line">        nums = nums[:write]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29.Divide Two Integers"></a>29.Divide Two Integers</h2><p><strong>Q:</strong>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>不会位运算，看了discussion此题两个while循环，第一个为结束条件，第二个循环每次减去除数的1、2、4、8……倍，结束第二个循环继续从一倍开始。减完回到第一个循环的判定条件判断是否需要再进行第二个while，相当于指数高效的记录倍数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">                temp, i = divisor, <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> dividend &gt;= temp:</span><br><span class="line">                    dividend -= temp</span><br><span class="line">                    res += i</span><br><span class="line">                    temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    i &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:</span><br><span class="line">            res = -res</span><br><span class="line">        <span class="keyword">return</span> min(max(<span class="number">-2</span> ** <span class="number">31</span>,res), <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31.Next Permutation"></a>31.Next Permutation</h2><p><strong>Q:</strong>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>从这几个数组合中找到下一个比他大的数</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>较简单，尽可能更改最后几位，并且从后往前如果一直是递增则就是这几个数的最大排列如4321，从后找到第一个非递增的数字p（如1245763中的5），然后将此数字与之后数字中 大于它且最接近于它 的数字（6）交换，交换后将该位置之后的数字升序排列（1246357）该题要求在原数组中修改，因此我把之后按升序拍了的数组建立一个临时数组temp_list，用for循环写入原数组</p>
<p><strong><em>list.sort() 和 sorted(list)的区别</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">list.sort()就地修改无返回值 sorted(list)返回新列表，对所有可迭代对象均有效</span><br><span class="line">print(a.sort())         -&gt; None</span><br><span class="line">print(sorted(a))        -&gt; [1,2,3]</span><br><span class="line">a.sort()    print(a)    -&gt; [1,2,3]</span><br><span class="line"><span class="comment">#对于切片列表：</span></span><br><span class="line">a[1:].sort()    print(a)    -&gt;[3,2,1] 无效</span><br><span class="line">print(sorted(a[1:]))        -&gt;[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p> ①找与p交换的数字时从后往前找可以避免index越界问题   </p>
<p> ②考虑有重复数字问题    </p>
<p> ③while遍历时候考虑左右边界问题（如while p and 条件  -&gt;此为不超过左边界）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># while p用以阻止左边界越界</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> nums[p<span class="number">-1</span>] &gt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = p - <span class="number">1</span></span><br><span class="line">            post = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># while post用以阻止左边界越界，同时从后往前找防止右边界越界</span></span><br><span class="line">            <span class="keyword">while</span> post <span class="keyword">and</span> nums[post]&lt;=nums[p]:</span><br><span class="line">                post -= <span class="number">1</span></span><br><span class="line">            temp = nums[p]</span><br><span class="line">            nums[p] = nums[post]</span><br><span class="line">            nums[post] = temp</span><br><span class="line">            temp_list = sorted(nums[p+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(p+<span class="number">1</span>,len(nums)):</span><br><span class="line">                nums[i] = temp_list[i-p<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33.Search in Rotated Sorted Array"></a>33.Search in Rotated Sorted Array</h2><p><strong>Q:</strong>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>在排序或类排序数组中查找首先想到二分法此题因为不需要考虑重复元素，较为简单，列出所有情况来即可，我的代码比较繁琐，边界值判定条件应该可以统一一下，懒得改了因为最后的6种判定条件互斥，所以用 抑或^ 或者 or 都行分情况讨论如图（类似高中数学题）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution33</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left +right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target <span class="keyword">and</span> target &gt; nums[right])^(nums[right]&gt;nums[mid] <span class="keyword">and</span> nums[mid]&gt;target</span><br><span class="line">                        )^(target&gt;nums[right] <span class="keyword">and</span> nums[right]&gt;nums[mid]):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34.Search for a Range"></a>34.Search for a Range</h2><p><strong>Q:</strong>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given [<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>] <span class="keyword">and</span> target value <span class="number">8</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单，因为是排序数组，所以先用二分法查找target,在从这个位置往两边扩展</p>
<p><strong>注意：</strong></p>
<p>①类似while pre&gt;0 and nums[pre] == target: 中判断while结束后的pre是否指向target(有可能因为边界条件跳出循环，并且边界仍满足target)来判断pre是否 -1    </p>
<p> ②第一个while l&lt;=r: 中‘=’存在不构成死循环的原因如果l=r且指向target接下来会return，如果l=r不指向target之后对于mid与target判定仍会跳出循环</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution34</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target):</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == r <span class="keyword">and</span> nums[<span class="number">0</span>]==target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                pre = post = mid</span><br><span class="line">                <span class="keyword">while</span> pre&gt;<span class="number">0</span> <span class="keyword">and</span> nums[pre] == target:</span><br><span class="line">                    pre -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> post&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[post] == target:</span><br><span class="line">                    post += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[pre] != target:</span><br><span class="line">                    pre += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[post] != target:</span><br><span class="line">                    post -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [pre, post]</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35.Search Insert Position"></a>35.Search Insert Position</h2><p><strong>Q:</strong>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>没什么好说的，排序数列二分查找，注意边界值问题及while中的等号问题while 中 加’=’保证在无target的情况，mid在连续两位中的右边一位</p>
<p><strong>注意：</strong>target&gt;max情况</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution35</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&gt;=target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r: <span class="comment"># 加‘=’保证在无target的情况，mid在连续两位中的右边一位</span></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># target&gt;max情况</span></span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>**</p>
]]></content>
    <summary type="html">
    <![CDATA[LeetCode刷题记录]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
