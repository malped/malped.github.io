<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Malped]]></title>
  <subtitle><![CDATA[Make a little progress every day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2018-03-04T07:41:43.925Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Malped]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[KTT条件]]></title>
    <link href="http://yoursite.com/2018/03/04/KTT%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/04/KTT条件的理解/</id>
    <published>2018-03-04T07:31:31.000Z</published>
    <updated>2018-03-04T07:41:43.925Z</updated>
    <content type="html"></content>
    <summary type="html">
    <![CDATA[<center>对拉格朗日对偶中KKT条件的理解</center>]]>
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="KKT" scheme="http://yoursite.com/tags/KKT/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拉格朗日对偶性]]></title>
    <link href="http://yoursite.com/2018/03/03/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    <id>http://yoursite.com/2018/03/03/拉格朗日对偶性/</id>
    <published>2018-03-03T14:49:03.000Z</published>
    <updated>2018-03-04T07:40:06.829Z</updated>
    <content type="html"><![CDATA[<h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><p>​    假设$f(x), c_i(x), h_j(x)$是定义在<strong>$R^n$</strong>上面的连续可微函数，考虑约束最优化问题</p>
<script type="math/tex; mode=display">\min_{x\in R^n}f(x)</script><script type="math/tex; mode=display">s.t.\ c_i(x)\le0,\ i=1,2,…,k</script><p>​<script type="math/tex">h_j(x)=0,\ j=1,2,…,l ​</script></p>
<p>​    称此约束最优化问题为原始最优化问题或原始问题。</p>
<p>​    首先，引进广义拉格朗日函数</p>
<p>​<script type="math/tex">L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)</script></p>
<p>​    这里，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i\ge0$.</p>
<p>​    考虑函数(<strong><em>注意：此时$L(x,\alpha,\beta)$的变量是$\alpha_i\beta_j$</em></strong>)：</p>
<p>​<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script></p>
<p>​    这里下标$P(Primal)$表示原始问题.对于此函数（关于$\alpha,\beta$的函数，$x$是常量），经过我们优化（不管什么方法），确定$\alpha,\beta$的值，就可以得到$L(x,\alpha,\beta)$的最大值，因为此时$\alpha,\beta$已经确定，显然最大值<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script>就是<strong><em>只和$x$有关的函数</em></strong></p>
<p>​    下面通过$x$是否绵竹约束条件两方面来分析这个函数：</p>
<p>​        1.考虑某个$x$违反了原始的约束，即$c_i\gt0$或者$h_j\neq0$，那么：</p>
<p>​<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=\infty</script></p>
<p>​        2.考虑$x$满足原始的约束，则：</p>
<p>​<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)]=f(x)</script>    ,</p>
<p>​            注意最大化确定$\alpha,\beta$的过程，$f(x)$就是个常量，敞亮的最大值显然是本身</p>
<p>​    通过上面两条分析可以得出：</p>
<p>​<script type="math/tex">\Theta_P(x)=\begin{cases}f(x),\ {x满足原始问题约束}\\+\infty,\ {其他}\\\end{cases}</script> </p>
<p>​    那么<strong>在满足约束的条件下：</strong></p>
<p>​<script type="math/tex">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script></p>
<p>​    即$\min_x\Theta_P(x)$与原始优化问题等价，所以常用$\min_x\Theta_P(x)$来代表原始问题，定义原始问题的最优值：</p>
<p>​<script type="math/tex">p^*=\min_x\Theta_P(x)</script><br>​    原始问题讨论到这里，总结：重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题。</p>
<h2 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h2><p>​    定义<strong>关于$\alpha,\beta$的函数</strong>：</p>
<p>​<script type="math/tex">\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)</script></p>
<p>​    注意上面等式<strong>右边是关于$x$的函数最小化,$x$确定之后，最小值就只与$\alpha,\beta$有关，所以此时是一个关于$\alpha,\beta$的函数</strong></p>
<p>​    再考虑极大化$\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$，即：</p>
<p>​<script type="math/tex">\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)</script></p>
<p>​    这就是原始问题的对偶问题，再将原始问题写出来：</p>
<p>​<script type="math/tex">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script></p>
<p>​    从形式上可以看出堆成，只不过<strong>原始问题先固定$L(x,\alpha,\beta)$中的$x$,优化参数$\alpha,\beta$，再优化$x$；而对偶问题是先固定$\alpha,\beta$，再优化$x$，然后再确定参数$\alpha,\beta$</strong></p>
<p>​    定义对偶问题的最优值：</p>
<p>​<script type="math/tex">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)</script></p>
<h2 id="原始问题与对偶问题之间的关系"><a href="#原始问题与对偶问题之间的关系" class="headerlink" title="原始问题与对偶问题之间的关系"></a>原始问题与对偶问题之间的关系</h2><p>​    若原始问题和对偶问题都有最优值，则有$Min-Max$不等式：</p>
<p>​<script type="math/tex">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)\le\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=p^*</script></p>
<p>​    当$L(x,\alpha,\beta)$对$x$为凸函数，对$\alpha,\beta$为凹函数，以上等号成立。而$L(x,\alpha,\beta)$对$\alpha,\beta$为天然凹函数，因此只要$L(x,\alpha,\beta)$对$x$为凸函数，等号便成立</p>
<p>​    证明：一个式子的最大值永远大于等于这个式子的最小值，哪怕是这个式子最小的最大值与最大的最小值相比（瘦死的骆驼比马大）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<center>对拉格朗日对偶性的理解</center>]]>
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="拉格朗日对偶" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <link href="http://yoursite.com/2018/02/27/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2018/02/27/剑指offer/</id>
    <published>2018-02-27T00:32:16.000Z</published>
    <updated>2018-03-04T07:39:21.444Z</updated>
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>Q:</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>思路：</strong>思路从右上开始，右上为一行最大，一列最小。target&lt;右上，删一列;  target&gt;右上,删一行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(array) <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>python式。。</p>
<p>其他语言思路：从头到尾遍历数空格数量，然后从后往前遍历，碰到空格后根据之前数好的数量移位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s= s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>Q:</strong>输入一个链表，从尾到头打印链表每个节点的值</p>
<p><strong>思路：</strong>遍历链表每次遍历的val从头插入list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        list = []</span><br><span class="line">        p = listNode</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            list = [p.val] + list</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>Q:</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>思路：</strong>先序第一个为根节点，中序中根节点左边全在左子树，右边全在右子树。据此用递归建树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的解法</span></span><br><span class="line"><span class="comment"># 对len==1的list判定，繁琐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution32</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span> <span class="keyword">and</span> len(tin) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root_index = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="number">0</span>:</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:root_index+<span class="number">1</span>],tin[:root_index])</span><br><span class="line">        <span class="keyword">if</span> root_index != len(tin)<span class="number">-1</span>:</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精简解法</span></span><br><span class="line"><span class="comment"># 对空list的判定，鲁棒性更强，更精简</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">    index = tin.index(root.val)</span><br><span class="line">    root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:index+<span class="number">1</span>], tin[<span class="number">0</span>:index])</span><br><span class="line">    root.right = self.reConstructBinaryTree(pre[index+<span class="number">1</span>:], tin[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>Q:</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>思路：</strong>太简单，不说了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        nums = rotateArray</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> p &gt; <span class="number">0</span> <span class="keyword">and</span> nums[p<span class="number">-1</span>]&lt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[p] &lt; min:</span><br><span class="line">                min = nums[p]</span><br><span class="line">        <span class="keyword">return</span> min</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><strong>Q:</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
<p><strong>思路：</strong>分别用while 与 递归实现</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不用递归，避免重复运算，运行时间短</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution6</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= n:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br><span class="line"><span class="comment"># 递归，代码简单，运行超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution62</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n<span class="number">-1</span>) + self.Fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>思路：</strong>斐波那契数列问题，斐波那契数列前移一位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution7</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<p><strong>思路：</strong></p>
<p>F(n) = F(n-1)+F(n-2)+F(n-3)+….+F(1)</p>
<p>第n项是前n-1项的和，所以第n+1项是第n项的两倍，都是二的指数次方</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution8</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> ** (number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><strong>Q:</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>思路：</strong>还是个斐波那契问题 n*2 矩形覆盖时候最后一步要不覆盖田，要不覆盖日，因此是斐波那契问题F(n) = F(n-1)+F(n-2)只不过题目规定F(0)=0</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution9</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>Q:</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>思路1：</strong>一个整数减去1，再和原整数做 与 运算，会把该整数最右边的1变成0（用补码表示的负数也是）。所以一个整数中有多少个1就可以进行多少次这种运算该法用python写超时</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution10</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>因为右移数字n会造成死循环（负数第一位是1），可以先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算……反复左移就能判断n的其中一位是不是1</p>
<p><strong>注意：</strong>1要是无符号整数(unsigned int)</p>
<p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count ++</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>Q:</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>思路：</strong>Life is short, you need python</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution11</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> pow(base, exponent)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"><a href="#调整数组是奇数位于偶数前并保证奇数偶数各自相对位置" class="headerlink" title="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"></a>调整数组是奇数位于偶数前并保证奇数偶数各自相对位置</h2><p><strong>Q:</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>思路：</strong>一个list存奇数一个list存偶数，两个合起来</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution12</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res1 = []</span><br><span class="line">        res2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">                res2.append(array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res1.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> res1+res2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>构造长度为K的滑窗（构造时考虑K过大问题），将滑窗滑至最后即可</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution13</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        post = pre = head</span><br><span class="line">        count = k</span><br><span class="line">        <span class="keyword">while</span> k<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post = post.next</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post.next:</span><br><span class="line">            post = post.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong>Q:</strong>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p><strong>思路：</strong>比较简单临近双指针遍历至最后，注意最后对边界值的处理</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution14</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        post = pHead.next</span><br><span class="line">        pHead.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                temp = post.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                post.next = pHead</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            post.next = pHead</span><br><span class="line">            pHead = post</span><br><span class="line">            post = temp</span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p><strong>Q:</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>思路：</strong>每次选出两个链表较小的头结点，然后用剩下的递归链接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution15</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="keyword">or</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>Q:</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p><strong>思路1：</strong>递归的查找子结构</p>
<p><strong>注意：</strong></p>
<p>①要全面遍历所有所可能（类似机器人路径中的找出所有起始位置），不能找到一对根节点相等的点，后面不等就return False；    这里体现在相等时候也留一手 or 类似与不等继续进行判断    </p>
<p> ②因为题中给出空节点不是子结构，而我迭代又要用到对pRoot2是否为空的判断，因此，先对pRoot2判断，再单独写了个函数     </p>
<p>③本题求的是子结构而非子树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution16</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">(pRoot1,pRoot2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1.val ==pRoot2.val:</span><br><span class="line">                <span class="comment"># 注意or的运用，遍历所有可能的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (  (Search(pRoot1.left,pRoot2.left) <span class="keyword">and</span> Search(pRoot1.right,pRoot2.right))</span><br><span class="line">                                 <span class="keyword">or</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2) )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2)</span><br><span class="line">        <span class="keyword">return</span> Search(pRoot1,pRoot2)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>更精简的分治递归</p>
<p>写一个函数判断两树是同一根节点的情况下pRoot2是否是pRoot1的子结构</p>
<p>在主函数里递归调用这个函数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(pRoot1,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.left,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.right,pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsSub</span><span class="params">(self,p1,p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> p1.val != p2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(p1.left,p2.left) <span class="keyword">and</span> self.IsSub(p1.right,p2.right)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>Q:</strong>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><strong>思路：</strong>递归实现没什么难度</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution17</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            temp = root.left</span><br><span class="line">            root.left = root.right</span><br><span class="line">            root.right = temp</span><br><span class="line">            Trans(root.left)</span><br><span class="line">            Trans(root.right)</span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><strong>Q:</strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><strong>思路：</strong>通过递归函数实现，每次添加最外一圈</p>
<p><strong>注意：</strong>对行列为2的判断（里面的if判断），过程中一个不满足就代表添加完毕</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution18</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.List = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        row_u = <span class="number">0</span></span><br><span class="line">        row_d = len(matrix) - <span class="number">1</span></span><br><span class="line">        col_l = <span class="number">0</span></span><br><span class="line">        col_r = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Printnum</span><span class="params">(matrix,row_u,row_d,col_l,col_r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> row_u &gt; row_d <span class="keyword">or</span> col_l &gt; col_r:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_l,col_r+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[row_u][j])</span><br><span class="line">                row_u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_u,row_d+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_r])</span><br><span class="line">                col_r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_r,col_l<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[row_d][j])</span><br><span class="line">                row_d -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_d,row_u<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_l])</span><br><span class="line">                col_l += <span class="number">1</span></span><br><span class="line">            Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        <span class="keyword">return</span> self.List</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="包含Min函数的栈"><a href="#包含Min函数的栈" class="headerlink" title="包含Min函数的栈"></a>包含Min函数的栈</h2><p><strong>Q:</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p><strong>思路：</strong>python式。。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution19</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack = self.stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> min(self.stack)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>Q:</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>思路：</strong>弹出一个便从压入list中记录index为p，并删除 这个元素。下一个弹出的元素的index只能是p的前一个位置(pre)或者后面位置，弹出后便继续更新p</p>
<p><strong>注意：</strong>压入list中删除元素后要更新index。list.remove(val)删除后会更新index，正好符合这道题。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution20</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pre = p = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(popV)):</span><br><span class="line">            <span class="comment"># 判断pushV popV是否一致</span></span><br><span class="line">            <span class="keyword">if</span> popV[i] <span class="keyword">not</span> <span class="keyword">in</span> pushV:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pushV.index(popV[i]) &lt; pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p = pushV.index(popV[i])</span><br><span class="line">            pushV.remove(popV[i])</span><br><span class="line">            <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">                pre = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = p - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p><strong>Q:</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>思路：</strong>简单的层序遍历</p>
<p><strong>注意：</strong>node=[] res=[] 跟 node=res=[]的区别，前面两个是两个[]，后面两个是同一个[]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution21</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = []</span><br><span class="line">        res = []</span><br><span class="line">        node.append(root)</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            res.append(node[<span class="number">0</span>].val)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].left:</span><br><span class="line">                node.append(node[<span class="number">0</span>].left)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].right:</span><br><span class="line">                node.append(node[<span class="number">0</span>].right)</span><br><span class="line">            node = node[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的后序遍历序列"><a href="#二叉树的后序遍历序列" class="headerlink" title="二叉树的后序遍历序列"></a>二叉树的后序遍历序列</h2><p><strong>Q:</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>二叉搜索树的中序遍历序列便相当于升序序列，因此将原序列排序便得到中序序列。然后判断能否成树判断能否成树的方法：后序最末位为根节点，通过此节点在中序中的位置（mid_index）分割左右子树节点。</p>
<p><strong><em>递归判断不能成树的条件是：递归中一旦出现两序列节点组成不一致的情况（最重要的思想！！！想死我了）</em></strong></p>
<p><strong>注意：</strong>其实此题不需要用到二叉搜索树left&lt;root&lt;right，或者说这个条件的全部信息都转化为升序序列为中序序列刚看此题想到中序序列以为此题得到解决，但是拘泥于二叉搜索树的性质写不出递归，其实可完全转化为一个中序一个后序能否成树问题。能否成树又可通过递归过程序列组成是否全程一致来判断。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mid = sorted(sequence)</span><br><span class="line">        post = sequence</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Define</span><span class="params">(mid, post)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mid <span class="keyword">and</span> <span class="keyword">not</span> post:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 不能成树的判定</span></span><br><span class="line">            <span class="keyword">if</span> set(mid)!= set(post):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            mid_index = mid.index(post[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> Define(mid[:mid_index],post[:mid_index]) <span class="keyword">and</span> Define(mid[mid_index+<span class="number">1</span>:],post[mid_index:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> Define(mid,post)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p><strong>Q:</strong>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p><strong>思路：</strong>定义全局list：self.res，用rest记录剩下路径所需拟合值，PathList记录当前路径。递归遍历节点如果root.val拟合完毕，将PathList并入全局res，并且rest重置为expectNumber，重置PathList=[]，从孩子节点从头递归；如果root.val不拟合rest，则将这个节点加入当前PathList，左右孩子传承此PathList继续递归寻找接下来的Path，左右孩子也要不继承PathList把rest重置为expectNumber从头递归</p>
<p><strong>注意：</strong></p>
<p>①root.val拟合或者不拟合都要在左右孩子加一个递归重置rest为expectNumber，重置PathList=[]继续寻找     </p>
<p>②左右节点继承当前PathList递归时，PathList要分开指代，要不右节点会继承左节点的PathList     </p>
<p>③PathList2=PathList这种方法指代，这俩指针还是指向同一list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution23</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Path</span><span class="params">(root, expectNumber, rest, PathList=[] )</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.val == rest:</span><br><span class="line">                PathList=PathList+[root.val]</span><br><span class="line">                <span class="comment"># 不加以下这个if结构是任意子路径，加了代表路径结尾必须是叶子节点。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    self.res.append(PathList)</span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                PathList.append(root.val)</span><br><span class="line">                rest -= root.val</span><br><span class="line">                <span class="comment"># 将此节点填入路径继续递归</span></span><br><span class="line">                <span class="comment"># 接下来两个递归会操作同一个PathList，这两个不应该操作统一list</span></span><br><span class="line">                <span class="comment"># 直接令PathList2=PathList这俩还是指向同一个</span></span><br><span class="line">                PathList2 = []</span><br><span class="line">                PathList2 += PathList</span><br><span class="line">                Path(root.left,expectNumber,rest,PathList)</span><br><span class="line">                Path(root.right,expectNumber,rest,PathList2)</span><br><span class="line">                <span class="comment"># 从此节点的子节点开始从头寻找路径</span></span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        Path(root,expectNumber,expectNumber,[])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>Q:</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p><strong>思路1：</strong>难点在给随机指针赋值时候怎样指向已存在的节点，这里的思路是通过next复制节点时，构造原节点与新节点一一对应的字典此方法因为用到哈希，空间复杂度较大</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24</span>:</span></span><br><span class="line">   <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">       Node_dic = &#123;&#125;</span><br><span class="line">       pre = pHead</span><br><span class="line">       clone_head = RandomListNode(pre.label)</span><br><span class="line">       p = clone_head</span><br><span class="line">       Node_dic[pre] = p</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           pre = pre.next</span><br><span class="line">           <span class="keyword">if</span> pre :</span><br><span class="line">               temp = RandomListNode(pre.label)</span><br><span class="line">               p.next = temp</span><br><span class="line">               p=p.next</span><br><span class="line">               <span class="comment"># 边复制节点边构造哈希表</span></span><br><span class="line">               Node_dic[pre] = p</span><br><span class="line">       pre = pHead</span><br><span class="line">       p = clone_head</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           <span class="keyword">if</span> pre.random:</span><br><span class="line">               p.random = Node_dic[pre.random]</span><br><span class="line">           pre = pre.next</span><br><span class="line">           p = p.next</span><br><span class="line">       <span class="keyword">return</span> clone_head</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>省去了空间复杂度，复制链表时一一间隔，将新节点插入原链表</p>
<p><strong>注意：</strong>不能用一个while（调整random指针的while）直接将合并的链表拆开</p>
<p>因为如果有random指向前面会出错，因为已经不是一一间隔了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24_2</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="comment"># 将新节点一一间隔插入原链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = RandomListNode(p.label)</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        new_head = pre.next</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            <span class="keyword">if</span> pre.random:</span><br><span class="line">                post.random = pre.random.next</span><br><span class="line">            pre = post.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> pre.next:</span><br><span class="line">                post = pre.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        <span class="comment"># 不能直接在上一个while直接将两链表分开，如果有random指向前面会出错，因为已经不是一一间隔了</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            pre.next = post.next</span><br><span class="line">            <span class="comment"># 考虑到尾节点情况</span></span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post.next = post.next.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">            post = post.next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>Q:</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路：</strong>二叉搜索树中序序列便是升序序列，用中序遍历构造链表</p>
<p><strong>注意：</strong>需要两个全局变量记录起点指针self.head，还有上一节点的指针self.p</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution25</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = <span class="keyword">None</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = pRootOfTree</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#temp保留右指针</span></span><br><span class="line">            temp_left = root.left</span><br><span class="line">            temp_right = root.right</span><br><span class="line">            self.Convert(temp_left)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.p:</span><br><span class="line">                self.p = root</span><br><span class="line">                self.head = root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.p.right = root</span><br><span class="line">                root.left = self.p</span><br><span class="line">                self.p = root</span><br><span class="line">            self.Convert(temp_right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>Q:</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>思路1：</strong>先用递归将所有可能的情况列出来，用sorted（）解决字典排序问题列出所有情况的方法：分成两个列表s1,s2 ，每次s2中的一个元素加入s1当做下一个s1，其余元素当做下一个s2，进行递归自己的解法：非常不优雅，先将str转为list，在转为str添加进去，还用到了py自带的排序解决字典序问题    如果不用自带排序，则可以参考LeetCode31</p>
<p><strong>注意：</strong>因为python中的字符串不可以更改，所以，先将str转为list，在转为str添加进去</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">allkinds</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">1</span>:</span><br><span class="line">                s = <span class="string">''</span>.join(s1+s2)</span><br><span class="line">                self.res.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                <span class="comment"># 将选中元素替换到s2第一位</span></span><br><span class="line">                temp = s2[i]</span><br><span class="line">                s2[i]=s2[<span class="number">0</span>]</span><br><span class="line">                s2[<span class="number">0</span>]=temp</span><br><span class="line">                allkinds(s1+[s2[<span class="number">0</span>]],s2[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = sorted(ss)</span><br><span class="line">        allkinds([],s)</span><br><span class="line">        self.res = list(set(self.res))</span><br><span class="line">        <span class="keyword">return</span> sorted(self.res)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>itertools.permutations用来返回所有排列（元组形式）的list’’.join() 将list、元组内的字符结合成字符串map函数将f应用于右边可迭代的每一个对象</p>
<p>Code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join,itertools.permutations(ss)))))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><strong>Q:</strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>思路1：</strong>python式</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput)[:k]</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>partition函数法（快排）：如果下标刚好是k(k-1)则左边(k-1则包含本身)便是所求，如果下标&gt;k则递归左边，下标&lt;k递归右边</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Partition</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = len(nums) - <span class="number">1</span></span><br><span class="line">            temp = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> nums[j] &gt; temp:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[i] &lt;= temp:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i] = temp</span><br><span class="line">            <span class="keyword">if</span> i == k - <span class="number">1</span> <span class="keyword">or</span> i == k - <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; k - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[:i], k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[i + <span class="number">1</span>:], k - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        Partition(tinput, k)</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput[:k])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p><strong>Q:</strong>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
<p><strong>思路：</strong></p>
<p>两个变量分别记录当前累加值(self.temp)与最大累加值(self.Max)。从头到尾累加数字如果self.temp&lt;0则在每次累加之前将其置0。<em>最关键一点就是用self.temp</em>记录最大值</p>
<p>动态规划思想：用f(i)表示以第i个数字结尾的子数组的最大和则max（f(i)）可由一下迭代公式求f(i)=Data<a href="i=0或f(i-1">i</a>&lt;=0)    f(i)=f(i-1)+Data<a href="i!=0并且f(i-1">i</a>&gt;0)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">-99</span></span><br><span class="line">        self.Max = <span class="number">-99</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> self.temp &lt; <span class="number">0</span>:</span><br><span class="line">                self.temp = <span class="number">0</span></span><br><span class="line">            self.temp += array[i]</span><br><span class="line">            <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">                self.Max = self.temp</span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h2><p><strong>Q:</strong>求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<p><strong>思路：</strong></p>
<p>10个数里面有1个个位1；每100个数里面有10个十位1（10、11、12……19）；每1000个数里面有100个百位1 ……</p>
<p>另外需要判断是否应该考虑剩余部分，剩余部分需要判断如115 里面有 10 + (115-110+1) 个十位1</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution30</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># count代表n的位数</span></span><br><span class="line">        count = len(str(n))</span><br><span class="line">        <span class="comment"># 这里相当于两位到 count-1位 第count 位要单独讨论</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,count+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># count为完整的倍数</span></span><br><span class="line">            times = n//(<span class="number">10</span>**i)</span><br><span class="line">            <span class="comment"># num 为每一份对应的1的个数</span></span><br><span class="line">            num = <span class="number">10</span> ** (i<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># rest 为除掉完整的份数剩下的</span></span><br><span class="line">            rest = n - times*(<span class="number">10</span>**i)</span><br><span class="line">            result += times * num</span><br><span class="line">            <span class="keyword">if</span> rest &gt;= <span class="number">2</span> * (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> rest &lt; (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += rest - (<span class="number">10</span>**(i<span class="number">-1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="将数组排成最小的数"><a href="#将数组排成最小的数" class="headerlink" title="将数组排成最小的数"></a>将数组排成最小的数</h2><p><strong>Q:</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>思路：</strong>全部转化为字符串，用itertools.permutations列出全组合，直接用min 找全组合中最小的</p>
<p><strong>注意：</strong>对itertools.permutations、map()、’ ‘.join的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            numbers[i] = str(numbers[i])</span><br><span class="line">        List = map(<span class="string">''</span>.join,list(itertools.permutations(numbers,len(numbers))))</span><br><span class="line">        <span class="keyword">return</span> int(min(List))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p><strong>Q:</strong>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p><strong>思路1：</strong>非递归，用栈</p>
<p>序列化：先序遍历得到字符串    </p>
<p> 反序列化：用栈记录字符串的节点，非#时入栈，flag指向添加方式1为左0为右，flag= =0时出栈，新元素入栈时flag = =1        遇到#号时flag= =0</p>
<p>注意：链接节点时候一定要注意指针。要用原节点去链接，而不是构造与原节点相同的节点链接（见注释）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_7_mine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        root = TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        stack = [root]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        flag = <span class="number">1</span> <span class="comment"># flag==1指示left添加且不用退栈，flag==0指示右边添加且要退栈</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].left = TreeNode(s[i])</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(stack[<span class="number">-1</span>].left)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].right = TreeNode(s[i])</span><br><span class="line">                    pop_node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(pop_node.right)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].left = None</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].right = None</span></span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>精简的递归思路</p>
<p>①通过 def <strong>init</strong>(self):构造flag全局变量指示遍历位置</p>
<p>②通过self.flag指示list位置建树，建树过程类似遍历过程，只不过遇到#return</p>
<p>③注意l元素本身为字符，给节点赋值时注意int化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.flag = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code her</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        l = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= len(l):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> l[self.flag] == <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(int(l[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的第K个节点"><a href="#二叉树的第K个节点" class="headerlink" title="二叉树的第K个节点"></a>二叉树的第K个节点</h2><p><strong>Q:</strong>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<p><strong>思路：</strong>二叉搜索树中序遍历就是升序</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_5</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,res=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left,res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            dfs(root.right,res)</span><br><span class="line">        dfs(pRoot,res)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>] <span class="keyword">if</span> k&lt;=len(res) <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p><strong>Q:</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>思路：</strong>先用嵌套for循环找出所有起始位置，对每个位置依次用递归函数搜寻</p>
<p><strong>注意：</strong>每次开始要用新的空list记录路径</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ok = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            ok.append([])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            ok[_//cols].append(matrix[_])</span><br><span class="line">        init = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                    init.append([i,j])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,ok,path,List=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=rows <span class="keyword">or</span> j&gt;=cols <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                List.append([i,j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (search(i+<span class="number">1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j+<span class="number">1</span>,rows,cols,ok,path[<span class="number">1</span>:],List)</span><br><span class="line">                                <span class="keyword">or</span> search(i<span class="number">-1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j<span class="number">-1</span>,rows,cols,ok,path[<span class="number">1</span>:],List))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(init)):</span><br><span class="line">            <span class="keyword">if</span> search(init[x][<span class="number">0</span>],init[x][<span class="number">1</span>],rows, cols, ok, path,[]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="机器人运动范围"><a href="#机器人运动范围" class="headerlink" title="机器人运动范围"></a>机器人运动范围</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>递归模拟机器人走路，用个列表记录机器人走过的路就行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(x)</span>:</span></span><br><span class="line">           res = <span class="number">0</span></span><br><span class="line">           <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">               res += x % <span class="number">10</span></span><br><span class="line">               x = x//<span class="number">10</span></span><br><span class="line">           <span class="keyword">return</span> res</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,threshold,List=[])</span>:</span></span><br><span class="line">           <span class="keyword">if</span> threshold&lt;<span class="number">0</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">if</span> i&gt;=cols <span class="keyword">or</span> j&gt;=rows <span class="keyword">or</span> Sum(i)+Sum(j)&gt;threshold <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               List.append([i,j])</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>+search(i+<span class="number">1</span>,j,rows,cols,threshold,List)+search(i,j+<span class="number">1</span>,rows,cols,threshold,List)</span><br><span class="line">       <span class="keyword">return</span> search(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><p><strong>Q:</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>思路：</strong>有right就沿着right的left一直找下去找到尽头没有right就沿着父节点一直向上找，直到导找到该节点是父节点的left</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        p = pNode</span><br><span class="line">        <span class="keyword">if</span> p.right:</span><br><span class="line">            post = p.right</span><br><span class="line">            <span class="keyword">while</span> post.left:</span><br><span class="line">                post = post.left</span><br><span class="line">            <span class="keyword">return</span> post</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            <span class="keyword">if</span> p.next.left == p:</span><br><span class="line">                <span class="keyword">return</span> p.next</span><br><span class="line">            p = p.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>Q:</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p><strong>思路1：</strong>用self.temp记录当前深度，self.Max记录最大深度。先序self.temp+1，后序self.temp-1注意：不要思维定式先中后序只用一个</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">0</span></span><br><span class="line">        self.Max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.temp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">            self.Max = self.temp</span><br><span class="line">        self.TreeDepth(pRoot.left)</span><br><span class="line">        self.TreeDepth(pRoot.right)</span><br><span class="line">        self.temp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<p>**思路2：更棒的方法</p>
<p>通过 <strong><em>左子树或右子树最大深度+1为当前子树深度</em></strong> 进行递归</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>Q:</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p><strong>思路1：</strong>写一个递归函数判断深度，注意对max(left,right)的运用，即<strong><em>左子树或右子树最大深度+1为当前子树的深度（写出递归的关键所在）</em></strong>然后从根节点开始递归判断每个节点</p>
<p>缺点：根节点开始递归判断每个节点缺点：重复遍历节点，时间复杂度高</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> abs( self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right) ) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>同样写一个递归函数判断深度，但是一旦出现不满足返回值便为 -1 ，同时在后序中  left &lt; 0 or right &lt; 0 的运用保证了一旦出现非平衡子树，-1就一直会传递到最后，最后只需在主函数中判断深度是否 &gt;=0 。</p>
<p><strong><em>对 -1 的传递真是太赞，好好体会</em></strong></p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.TreeDepth(pRoot) &gt;= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> abs(left - right) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p><strong>Q:</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>思路：</strong>写递归函数（输入为两个节点）递归比较，递归方式为haha(left.left,right.right) and haha(left.right,right.left)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(pRoot.left,pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> left.val != right.val :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(left.left,right.right) <span class="keyword">and</span> self.haha(left.right,right.left)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h2><p><strong>Q:</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        NodeList = [pRoot]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> NodeList:</span><br><span class="line">            NextLayer = []</span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> NodeList:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            NodeList = NextLayer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。最后按照奇偶顺序修改val列表即可。</p>
<p><strong>注意：</strong>将节点加入NextLayer时要判断存在与否，否则空类型也会被添加</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># Nodeque为循环遍历的node list</span></span><br><span class="line">        Nodeque = [pRoot]</span><br><span class="line">        <span class="comment"># res为嵌套list,每个元素list为每层的val</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</span></span><br><span class="line">        <span class="comment"># 即每一圈while为每层的处理</span></span><br><span class="line">        <span class="keyword">while</span> Nodeque:</span><br><span class="line">            <span class="comment"># NextLayer为本层节点的所有孩子节点</span></span><br><span class="line">            NextLayer = []</span><br><span class="line">            <span class="comment"># ValList存取本层所有节点的val</span></span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> Nodeque:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            Nodeque = NextLayer</span><br><span class="line">        transres = []</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(res):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                transres.append(v[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                transres.append(v)</span><br><span class="line">        <span class="keyword">return</span> transres</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p><strong>Q:</strong>输入两个链表，找出它们的第一个公共结点。这里的是指两个链表在某个节点之后会汇入同一个链表。</p>
<p><strong>思路：</strong>最后两个链表汇入一个链表，即最后公共长度是一样的。因此可以先遍历两个链表，得出长度差在较长链表上提前多走长度差的步数，再一一比较</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        length1 = <span class="number">0</span></span><br><span class="line">        length2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            length1 += <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            length2 += <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        differ = abs(length1 - length2)</span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val == p2.val:</span><br><span class="line">                <span class="keyword">return</span> p1</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<center>剑指offer刷题记录</center>]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <link href="http://yoursite.com/2018/02/26/LeetCode/"/>
    <id>http://yoursite.com/2018/02/26/LeetCode/</id>
    <published>2018-02-26T01:13:07.000Z</published>
    <updated>2018-03-04T07:38:45.617Z</updated>
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.Two Sum</h2><p><strong>Q:</strong>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典，key为值，val为值所对应位置</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tag = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> tag:</span><br><span class="line">                <span class="keyword">return</span>[tag[nums[i]],i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tag[target-nums[i]]=i</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h2><p><strong>Q:</strong>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        takeover = <span class="number">0</span></span><br><span class="line">        root = n = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> takeover:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                takeover += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                takeover += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            takeover, val = divmod(takeover, <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># 以下两行可以写成</span></span><br><span class="line">            <span class="comment"># n.next = n = ListNode(val)</span></span><br><span class="line">            n.next = ListNode(val)</span><br><span class="line">            n = n.next</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.Longest Substring Without Repeating Characters</h2><p><strong>Q:</strong>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="string">"abcabcbb"</span>, the answer <span class="keyword">is</span> <span class="string">"abc"</span>, which the length <span class="keyword">is</span> <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"bbbbb"</span>, the answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> the length of <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"pwwkew"</span>, the answer <span class="keyword">is</span> <span class="string">"wke"</span>, <span class="keyword">with</span> the length of <span class="number">3.</span> Note that the answer must be a substring, <span class="string">"pwke"</span> <span class="keyword">is</span> a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典key为值，val为该值最后一次出现的位置，用指针pre指向每次寻找的子串的开头位置</p>
<p><strong>注意：</strong>自己思路是对的，但是错在没考虑嵌套重复如 abcddoua 遍历到第二个d时候重复pre指向第二个d 而遍历到第二个a时pre指向第一个a后的b，显然错的（即pre应该始终在字典回溯值之前，pre只能向后移动）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringonglen</span><span class="params">(s)</span>:</span></span><br><span class="line">    usedchar = &#123;&#125;</span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedchar <span class="keyword">and</span> pre &lt;= usedchar[s[i]]:</span><br><span class="line">            pre = usedchar[s[i]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxlen = max(maxlen, i-pre+<span class="number">1</span>)</span><br><span class="line">        usedchar[s[i]] = i</span><br><span class="line">    <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p><strong>Q:</strong>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"babad"</span></span><br><span class="line"></span><br><span class="line">Output: <span class="string">"bab"</span></span><br><span class="line"></span><br><span class="line">Note: <span class="string">"aba"</span> <span class="keyword">is</span> also a valid answer.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①for遍历选中心元素，找齐所有中心元素（第一个while 向后 找出所有与所选中心元素重复的元素）  </p>
<p> ② l r 指示回文边界，向两遍扩展</p>
<p><strong>注意：</strong></p>
<p>①l r 始终指向有效边界（闭区间，考虑边界值仍然是回文区域） </p>
<p> ②注意边界情况判断，如第一个while循环判定条件有两个，应该把边界判断放在前面，要不会出现index越界</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    maxlen = real_l = real_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">        l, r, pos = i, i, i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ( pos &lt;= len(s) - <span class="number">1</span>) <span class="keyword">and</span> s[r] == s[pos]:</span><br><span class="line">            r = pos</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">1</span> <span class="keyword">and</span> r &lt; (len(s) - <span class="number">1</span>)) <span class="keyword">and</span> s[l - <span class="number">1</span>] == s[r + <span class="number">1</span>]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; maxlen:</span><br><span class="line">            maxlen = r - l + <span class="number">1</span></span><br><span class="line">            real_l = l</span><br><span class="line">            real_r = r</span><br><span class="line">    <span class="keyword">return</span> s[real_l:real_r+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h2><p><strong>Q:</strong>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output: <span class="number">-321</span></span><br><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output: <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①flag表示符号判断正数1负数-1</p>
<p> ②将int转为字符串形式，[::-1]表示字符串反转</p>
<p> ③bit_length表示位数的判断</p>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span>:</span></span><br><span class="line">    flag = (x&gt;<span class="number">0</span>)-(x&lt;<span class="number">0</span>)</span><br><span class="line">    val = flag*int(str(abs(x))[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> val*(val.bit_length()&lt;<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h2><p><strong>Q:</strong>Implement <code>atoi</code> to convert a string to an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>此题太乱没做，总结答案</p>
<ol>
<li><p>str.strip（）用于移除首位指定字符串</p>
</li>
<li><p>str.isdigit()判断字符是否是数值</p>
</li>
<li><p>ord()将字符转换为ASCII码 chr()将ASCII码转为字符如ord(‘a’)</p>
<p> -&gt;  97    chr(97)  -&gt;  ‘a’4. 字符串跟数值问题注意overflow问题，这里是有符号函数所以max=2<strong>31-1 min=-2</strong>31</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type str: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">###better to do strip before sanity check (although 8ms slower):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ls = list(s.strip())</span><br><span class="line"></span><br><span class="line">    sign = <span class="number">-1</span> <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ls[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'-'</span>, <span class="string">'+'</span>]: <span class="keyword">del</span> ls[<span class="number">0</span>]</span><br><span class="line">    ret, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(ls) <span class="keyword">and</span> ls[i].isdigit():</span><br><span class="line">        ret = ret * <span class="number">10</span> + ord(ls[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">-2</span> ** <span class="number">31</span>, min(sign * ret, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h2><p><strong>Q:</strong>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.负数不是回文数、非零且末位为零不是回文数</p>
<p>2.用数字一半部分来比较避免了翻转数字overflow问题（赞）</p>
<p><strong>注意：</strong></p>
<p>注意对大数的处理（用数字一半部分作比较）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; res:</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x = x // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> (x == res <span class="keyword">or</span> x == res // <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11.Container With Most Water"></a>11.Container With Most Water</h2><p><strong>Q:</strong>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>分析此题可以得到一个解题基础：最终得到的两块挡板左挡板L和右挡板R，L左边的所有挡板一定短于L，R右边的所有挡板一定短于R。据此，可以从轴两遍开始向内遍历，每次记录最值，并且下次从较短的挡板继续向内遍历。</p>
<p><strong>注意：</strong></p>
<p>注意对python 中用while True:    if XX:     break  来代替do while</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">( height)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type height: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(height) - <span class="number">1</span></span><br><span class="line">    l_h = height[l]</span><br><span class="line">    r_h = height[r]</span><br><span class="line">    val = maxval = min(l_h, r_h) * (r - l)</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r):</span><br><span class="line">        <span class="keyword">if</span> l_h &lt;= r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[l] &gt; l_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        l_h = height[l]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> l_h &gt; r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[r] &gt; r_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        r_h = height[r]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val = min(l_h, r_h) * (r - l)</span><br><span class="line">        <span class="keyword">if</span> val &gt; maxval:</span><br><span class="line">            maxval = val</span><br><span class="line">    <span class="keyword">return</span> maxval</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14.Longest Common Prefix"></a>14.Longest Common Prefix</h2><p><strong>Q:</strong>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到字符串们的最长前缀</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>关于zip()以及zip(* )的用法</p>
<p>前者相当于压缩到一个list中，后者相当于分开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">c=[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line"></span><br><span class="line">x,y,z=zip(*zz)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>)]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type strs: List[str]</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, group <span class="keyword">in</span> enumerate(zip(*strs)):</span><br><span class="line">        <span class="keyword">if</span> len(set(group)) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">    <span class="keyword">return</span> min(strs)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="15-3-Sum"><a href="#15-3-Sum" class="headerlink" title="15.3 Sum"></a>15.3 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>开头 排序 为了跳过重复元素（用dup记录上一元素）遍历一次用twosum函数返回（twosum函数也要去重）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        result = []</span><br><span class="line">        dup = <span class="number">-999</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != dup:</span><br><span class="line">                result.extend(self.twosum(nums[i],nums[i+<span class="number">1</span>:],nums[i]*<span class="number">-1</span>))</span><br><span class="line">            dup = nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twosum</span><span class="params">(self,p,arr,val)</span>:</span></span><br><span class="line">        box = set()</span><br><span class="line">        threesum = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> (val-arr[i] <span class="keyword">in</span> box):</span><br><span class="line">                temp = sorted([p,arr[i],val-arr[i]])</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> threesum:</span><br><span class="line">                    threesum.append(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                box.add(arr[i])</span><br><span class="line">        <span class="keyword">return</span> threesum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="16-3-Sum-Closest"><a href="#16-3-Sum-Closest" class="headerlink" title="16.3 Sum Closest"></a>16.3 Sum Closest</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = &#123;<span class="number">-1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">-4</span>&#125;, <span class="keyword">and</span> target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">    The sum that <span class="keyword">is</span> closest to the target <span class="keyword">is</span> <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>排序后根据大小查找</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    close = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        k = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;k:</span><br><span class="line">            sum = nums[i]+nums[j]+nums[k]</span><br><span class="line">            <span class="keyword">if</span> sum == target:</span><br><span class="line">                <span class="keyword">return</span> sum</span><br><span class="line">            <span class="keyword">if</span> abs(target-sum) &lt; abs(target-close):</span><br><span class="line">                close = sum</span><br><span class="line">            <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> close</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17-Letter-Combinations-of-a-Phone-Numbert"><a href="#17-Letter-Combinations-of-a-Phone-Numbert" class="headerlink" title="17.Letter Combinations of a Phone Numbert"></a>17.Letter Combinations of a Phone Numbert</h2><p><strong>Q:</strong>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>递归思想 字符串拼接用 +</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type digits: str</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mapping = &#123;<span class="string">'0'</span>: <span class="string">' '</span>, <span class="string">'1'</span>: <span class="string">''</span>, <span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span></span><br><span class="line">        , <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list(mapping[digits[<span class="number">0</span>]])</span><br><span class="line">    pre_comb = self.letterCombinations(digits[:<span class="number">-1</span>])</span><br><span class="line">    last = mapping[digits[<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> [s + v <span class="keyword">for</span> s <span class="keyword">in</span> pre_comb <span class="keyword">for</span> v <span class="keyword">in</span> last]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="18-4-Sum"><a href="#18-4-Sum" class="headerlink" title="18.4 Sum"></a>18.4 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>列表之间的拼接用 ‘+’先两层嵌套for循环将所有两两组合之和求出来，再用twosum思想</p>
<p>去重</p>
<p>保证每个元素只添加一次(通过变量保存下标而不是值)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            twosum = nums[i] + nums[j]</span><br><span class="line">            <span class="keyword">if</span> target - twosum <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">for</span> two <span class="keyword">in</span> range(len(dic[target - twosum])):</span><br><span class="line">                    thisfour = sorted([nums[i], nums[j]] +</span><br><span class="line">                                      [nums[dic[target - twosum][two][<span class="number">0</span>]], nums[dic[target - twosum][two][<span class="number">1</span>]]])</span><br><span class="line">                    <span class="comment"># and前条件用于去重；and后条件用于去除元素是否重复利用</span></span><br><span class="line">                    <span class="keyword">if</span> thisfour <span class="keyword">not</span> <span class="keyword">in</span> result <span class="keyword">and</span> len(set([i, j]) | set(dic[target - twosum][two])) == <span class="number">4</span>:</span><br><span class="line">                        result.append(thisfour)</span><br><span class="line">            <span class="keyword">if</span> twosum <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[twosum] = [[i, j]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[twosum].append([i, j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a>19.Remove Nth Node From End of List</h2><p><strong>Q:</strong>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p>
<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>构造一个长度为n的滑窗，滑到最后注意判断如果删除了第一个元素（此时post.next = null）应返回head.next</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pre = head</span><br><span class="line">    post = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        post = post.next</span><br><span class="line">    <span class="comment"># 注意这一步，如果删除的是head，直接返回head.next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> post:</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    <span class="keyword">while</span> post.next:</span><br><span class="line">        pre = pre.next</span><br><span class="line">        post = post.next</span><br><span class="line">    pre.next = pre.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><p><strong>Q:</strong>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not..</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>not valid 只有三种情况，找准这三种情况的特点注意一手对ord()的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">'('</span>,<span class="string">'&#123;'</span>,<span class="string">'['</span>]:</span><br><span class="line">            stack = stack + [s[i]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(stack)==<span class="number">0</span>:       <span class="comment"># 右括号比左括号多的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">1</span> <span class="keyword">and</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">2</span>:       <span class="comment">#左右括号不对称的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:                           <span class="comment"># 左括号比右括号多的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p><strong>Q:</strong>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.正常思路，用and终止while，l1 或 l2 的尾巴可以一并加上</p>
<p>2.递归思想找准结束条件，链表一个一个拼接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">( l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            p.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        p = p.next</span><br><span class="line">    p.next = l1 <span class="keyword">or</span> l2       <span class="comment">#加上小尾巴</span></span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line"><span class="comment"># 递归做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22.Generate Parentheses"></a>22.Generate Parentheses</h2><p><strong>Q:</strong>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>不带返回值的递归（用于添加或者修改），递归生成每个str</p>
<p>Left right 分别为左右括号的计数器</p>
<p>Init_str为目前生成的字符串</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left, right, init_str = n, n, <span class="string">''</span></span><br><span class="line">        result = []</span><br><span class="line">        self.generate(left,right,init_str,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self,left,right,init_str,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            result.append(init_str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            self.generate(left<span class="number">-1</span>,right,init_str+<span class="string">'('</span>,result)</span><br><span class="line">        <span class="comment">#left &lt; right 为添加右括号条件</span></span><br><span class="line">        <span class="keyword">if</span> right <span class="keyword">and</span> left &lt; right:</span><br><span class="line">            self.generate(left,right<span class="number">-1</span>,init_str+<span class="string">')'</span>,result)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs"><a href="#24-wap-Nodes-in-Pairs" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs-1"><a href="#24-wap-Nodes-in-Pairs-1" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26.Remove Duplicates from Sorted Array"></a>26.Remove Duplicates from Sorted Array</h2><p><strong>Q:</strong>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line">It doesn<span class="string">'t matter what you leave beyond the new length.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单题，在数组内删除重复元素，两个指针write、read,修改时候</p>
<p>A[write + 1] = A[read]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        write = <span class="number">0</span></span><br><span class="line">        read = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(A):</span><br><span class="line">            <span class="keyword">if</span> A[write] != A[read]:</span><br><span class="line">                <span class="comment"># 修改重复元素的方法</span></span><br><span class="line">                A[write + <span class="number">1</span>] = A[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">        A = A[:write + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(A)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27.Remove Element"></a>27.Remove Element</h2><p><strong>Q:</strong>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单的双指针</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        read = write =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[read] != val:</span><br><span class="line">                nums[write] = nums[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">            read += <span class="number">1</span></span><br><span class="line">        nums = nums[:write]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29.Divide Two Integers"></a>29.Divide Two Integers</h2><p><strong>Q:</strong>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>不会位运算，看了discussion此题两个while循环，第一个为结束条件，第二个循环每次减去除数的1、2、4、8……倍，结束第二个循环继续从一倍开始。减完回到第一个循环的判定条件判断是否需要再进行第二个while，相当于指数高效的记录倍数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">                temp, i = divisor, <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> dividend &gt;= temp:</span><br><span class="line">                    dividend -= temp</span><br><span class="line">                    res += i</span><br><span class="line">                    temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    i &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:</span><br><span class="line">            res = -res</span><br><span class="line">        <span class="keyword">return</span> min(max(<span class="number">-2</span> ** <span class="number">31</span>,res), <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31.Next Permutation"></a>31.Next Permutation</h2><p><strong>Q:</strong>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>从这几个数组合中找到下一个比他大的数</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>较简单，尽可能更改最后几位，并且从后往前如果一直是递增则就是这几个数的最大排列如4321，从后找到第一个非递增的数字p（如1245763中的5），然后将此数字与之后数字中 大于它且最接近于它 的数字（6）交换，交换后将该位置之后的数字升序排列（1246357）该题要求在原数组中修改，因此我把之后按升序拍了的数组建立一个临时数组temp_list，用for循环写入原数组</p>
<p><strong><em>list.sort() 和 sorted(list)的区别</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">list.sort()就地修改无返回值 sorted(list)返回新列表，对所有可迭代对象均有效</span><br><span class="line">print(a.sort())         -&gt; None</span><br><span class="line">print(sorted(a))        -&gt; [1,2,3]</span><br><span class="line">a.sort()    print(a)    -&gt; [1,2,3]</span><br><span class="line"><span class="comment">#对于切片列表：</span></span><br><span class="line">a[1:].sort()    print(a)    -&gt;[3,2,1] 无效</span><br><span class="line">print(sorted(a[1:]))        -&gt;[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p> ①找与p交换的数字时从后往前找可以避免index越界问题   </p>
<p> ②考虑有重复数字问题    </p>
<p> ③while遍历时候考虑左右边界问题（如while p and 条件  -&gt;此为不超过左边界）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># while p用以阻止左边界越界</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> nums[p<span class="number">-1</span>] &gt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = p - <span class="number">1</span></span><br><span class="line">            post = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># while post用以阻止左边界越界，同时从后往前找防止右边界越界</span></span><br><span class="line">            <span class="keyword">while</span> post <span class="keyword">and</span> nums[post]&lt;=nums[p]:</span><br><span class="line">                post -= <span class="number">1</span></span><br><span class="line">            temp = nums[p]</span><br><span class="line">            nums[p] = nums[post]</span><br><span class="line">            nums[post] = temp</span><br><span class="line">            temp_list = sorted(nums[p+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(p+<span class="number">1</span>,len(nums)):</span><br><span class="line">                nums[i] = temp_list[i-p<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33.Search in Rotated Sorted Array"></a>33.Search in Rotated Sorted Array</h2><p><strong>Q:</strong>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>在排序或类排序数组中查找首先想到二分法此题因为不需要考虑重复元素，较为简单，列出所有情况来即可，我的代码比较繁琐，边界值判定条件应该可以统一一下，懒得改了因为最后的6种判定条件互斥，所以用 抑或^ 或者 or 都行分情况讨论如图（类似高中数学题）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution33</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left +right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target <span class="keyword">and</span> target &gt; nums[right])^(nums[right]&gt;nums[mid] <span class="keyword">and</span> nums[mid]&gt;target</span><br><span class="line">                        )^(target&gt;nums[right] <span class="keyword">and</span> nums[right]&gt;nums[mid]):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34.Search for a Range"></a>34.Search for a Range</h2><p><strong>Q:</strong>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given [<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>] <span class="keyword">and</span> target value <span class="number">8</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单，因为是排序数组，所以先用二分法查找target,在从这个位置往两边扩展</p>
<p><strong>注意：</strong></p>
<p>①类似while pre&gt;0 and nums[pre] == target: 中判断while结束后的pre是否指向target(有可能因为边界条件跳出循环，并且边界仍满足target)来判断pre是否 -1    </p>
<p> ②第一个while l&lt;=r: 中‘=’存在不构成死循环的原因如果l=r且指向target接下来会return，如果l=r不指向target之后对于mid与target判定仍会跳出循环</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution34</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target):</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == r <span class="keyword">and</span> nums[<span class="number">0</span>]==target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                pre = post = mid</span><br><span class="line">                <span class="keyword">while</span> pre&gt;<span class="number">0</span> <span class="keyword">and</span> nums[pre] == target:</span><br><span class="line">                    pre -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> post&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[post] == target:</span><br><span class="line">                    post += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[pre] != target:</span><br><span class="line">                    pre += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[post] != target:</span><br><span class="line">                    post -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [pre, post]</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35.Search Insert Position"></a>35.Search Insert Position</h2><p><strong>Q:</strong>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>没什么好说的，排序数列二分查找，注意边界值问题及while中的等号问题while 中 加’=’保证在无target的情况，mid在连续两位中的右边一位</p>
<p><strong>注意：</strong>target&gt;max情况</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution35</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&gt;=target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r: <span class="comment"># 加‘=’保证在无target的情况，mid在连续两位中的右边一位</span></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># target&gt;max情况</span></span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>**</p>
]]></content>
    <summary type="html">
    <![CDATA[<center>LeetCode刷题记录</center>]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
