<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Malped]]></title>
  <subtitle><![CDATA[Make a little progress every day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2018-03-09T05:07:30.757Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Malped]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[广义线性模型]]></title>
    <link href="http://yoursite.com/2018/03/09/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/09/广义线性模型/</id>
    <published>2018-03-09T05:02:21.000Z</published>
    <updated>2018-03-09T05:07:30.757Z</updated>
    <content type="html"><![CDATA[<h1 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h1><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>本文将会说明线性回归和$LR$都是广义线性模型的一种特殊形式，介绍广义线性模型的一般求解步骤。</p>
<p>线性回归中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta) 服从N(\mu,\sigma^2)分布</script><p>$LR$中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta)服从Bernoulli(\phi)分布</script><p>其实他们只是广义线性模型($GlMs$)的特例。</p>
<h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p><strong>广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。</strong></p>
<p>注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$</p>
<h2 id="指数分布族（-The-exponential-family-）"><a href="#指数分布族（-The-exponential-family-）" class="headerlink" title="指数分布族（$The exponential family$）"></a>指数分布族（$The exponential family$）</h2><p>首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)：</p>
<script type="math/tex; mode=display">p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))</script><p>简单介绍一下其中的参数：</p>
<p>1.$\eta $是自然参数</p>
<p>2.$T(y)$是充分统计量(一般情况下$T(y)=y$)</p>
<p>3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $)</p>
<p>也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。</p>
<p>选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布</p>
<h2 id="高斯分布的另一种看法"><a href="#高斯分布的另一种看法" class="headerlink" title="高斯分布的另一种看法"></a>高斯分布的另一种看法</h2><p><img src="/2018/03/09/广义线性模型/高斯1.jpg" alt=""></p>
<p><img src="/2018/03/09/广义线性模型/高斯2.jpg" alt=""></p>
<p><img src="/2018/03/09/广义线性模型/高斯3.jpg" alt=""></p>
<h2 id="伯努利分布-LR回归的含义"><a href="#伯努利分布-LR回归的含义" class="headerlink" title="伯努利分布-LR回归的含义"></a>伯努利分布-LR回归的含义</h2><p><img src="/2018/03/09/广义线性模型/伯努利1.jpg" alt=""></p>
<p><img src="/2018/03/09/广义线性模型/伯努利2.jpg" alt=""></p>
<p><img src="/2018/03/09/广义线性模型/伯努利3.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[广义线性模型简析以及与LR的联系]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="理论" scheme="http://yoursite.com/tags/%E7%90%86%E8%AE%BA/"/>
    
      <category term="广义线性模型" scheme="http://yoursite.com/tags/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GLM" scheme="http://yoursite.com/tags/GLM/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大熵模型]]></title>
    <link href="http://yoursite.com/2018/03/07/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/07/最大熵模型/</id>
    <published>2018-03-07T07:41:18.000Z</published>
    <updated>2018-03-08T15:34:18.630Z</updated>
    <content type="html"><![CDATA[<p>最大熵模型($The  Maximum Entropy$，从信息论的角度来讲，就是保留了最大的不确定性，也就是让熵达到最大。当我们需要对一个时间的概率分布进行预测是，最大熵原理告诉我们所有的预测应当满足全部已知的条件，而<strong>对未知的情况不要做任何主观假设（不做主观假设这点很重要）</strong>。也就是让概率分布最均匀，预测风险最小。</p>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>熵（$Entropy$）是热力学中的概念，由香农引入到信息论中。在信息论和概率统计中，熵用来表示随机变量不确定性的度量。</p>
<p><strong>定义：</strong>设$X\in\{x_1,x_2,x_3…,x_n\}$为一个离散随机变量，其概率分布为$p(X=x_i)=p_i, i=1,2,…,n$，则$X$的熵为</p>
<script type="math/tex; mode=display">H(X)=-\sum^n_{i=1}p_i\log p_i</script><p>其中，当$p_i=0$时，定义$0\log 0=0.$</p>
<p>注意：$H(x)$依赖于$X$的分布，而与$X$的具体值无关。$H(x)$越大，表示$X$的不确定性越大。</p>
<h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p><strong>定义：</strong>设$X\in\{x_1,x_2,x_3…,x_n\}, Y\in \{y_1,y_2,…,y_m\}$为离散随机变量，在已知$X$的条件下，$Y$的条件熵$(Conditional Entropy)$可定义为</p>
<script type="math/tex; mode=display">H(Y|X)=\sum^n_{i=1}H(Y|X=x_i)=-\sum^n_{i=1}p(x_i)\sum^m_{j=1}p(y_j|x_i)\log p(y_j|x_i)</script><p>它表示已知$X$的条件下，$Y$的条件概率分布的熵对$X$的数学期望。</p>
<h2 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h2><p>最大熵原理是概率模型学习的一个准则，最大熵原理认为，学习概率模型时在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型集合，所以，<strong>最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型</strong>。</p>
<p>假设离散随机变量$X$的概率分布是$P(X)$，则其熵是</p>
<script type="math/tex; mode=display">H(P)=-\sum_xP(x)\log P(x)</script><p>熵满足下列不等式：</p>
<script type="math/tex; mode=display">0\le H(P)\le \log |X|</script><p><strong>式中，$|X|$是$X$的取值个数，当且仅当$X$的分布式均匀分布时右边的等号成立。这就是说，当$X$服从均匀分布时候，熵最大</strong>。</p>
<p>最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息条件下，那些不确定的成分是<strong>‘等可能的’</strong>。最大熵原理通过熵最大化来表示等可能性。‘等可能性’不易操作，而<strong>熵则是可优化的数值指标</strong>。</p>
<h2 id="最大熵模型定义"><a href="#最大熵模型定义" class="headerlink" title="最大熵模型定义"></a>最大熵模型定义</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>1.最大熵原理是统计学习的一般原理，将它应用到分类就得到了最大熵模型</p>
<p>2.假设分类模型是一个条件概率分布$P(Y|X),$$X$表示输入，$Y$表示输出。这个模型表示的是对于给定的输入$X$，一条件概率$P(Y|X)$输出$Y$。</p>
<p>3.给定一个训练数据集$T$，我们的目标就是利用最大熵原理选择最好的分类模型。</p>
<script type="math/tex; mode=display">T=\{(x_1,y_1),(x_2,y_2),…(x_N,y_N)\}</script><p>4.<strong>按照最大熵原理，我们应该优先保证模型满足一致的所有约束。那么如何得到这些约束的？</strong></p>
<p>$     $<strong>思路：从训练数据$T$中抽取若干特征（<em>依靠特征函数</em>），然后<em>要求这些特征在$T$上关于经验分布的期望与他们在模型中关于$p(x,y)$的数学期望相等，这样，一个特征就对应一个约束</em>。</strong></p>
<h3 id="特征函数"><a href="#特征函数" class="headerlink" title="特征函数"></a>特征函数</h3><h4 id="特征函数的作用"><a href="#特征函数的作用" class="headerlink" title="特征函数的作用"></a>特征函数的作用</h4><p>1.用特征函数$f(x)$描述输入$x$和输出$y$之间的某一个事实。</p>
<p>2.按照最大熵原理，应该优先保证模型满足一致的所有约束。<strong>通过特征函数来定义、量化以及得到这些约束</strong>。</p>
<p>3.特征函数的出现，可以让模型有更好的<strong>泛化能力</strong>（特征函数的选取、定义特别随意）。</p>
<p>特征函数可以类比决策树对于输入$x$的处理，假设输入$x$是一个有着多个属性值的实例，决策树在一个决策点并不是对所有属性都进行考虑，这就有点提取出了特征中更有信息量的属性。</p>
<p>如何让一个线性模型（例如$LR:h_{\theta}(x)=\sigma (\theta^Tx)$  ）也有类似的功能？答案就是特征函数，让输入$X$先经过一些列特征函数的处理，变成$g(x)$再送给模型分类（如：$h_{\theta}(x)=\sigma (\theta^Tg(x))$）.</p>
<p>此外，当输入的样本可能不是数值的向量，比如文本或图片时，特征函数的功能更像是特征向量的制作。对于给定输入$X$，使用<strong>一系列定义好的特征函数$\{g(x)\}$</strong>将其转换成需要的向量形式。</p>
<h4 id="对于特征函数中‘特征’的理解"><a href="#对于特征函数中‘特征’的理解" class="headerlink" title="对于特征函数中‘特征’的理解"></a>对于特征函数中‘特征’的理解</h4><p>一般说的“特征”都是指输入的特征，而最大熵模型中的“特征”指的是输入和输出共同的特征。最大熵模型中的每个特征会有一个权重，你可以把它理解成这个特征所描述的输入和输出有多么倾向于同时出现。</p>
<p>可以以多类logistic regression为例，来感受一下两种视角的不同。在一般的视角下，每条输入数据会被表示成一个n维向量，可以看成n个特征。而模型中每一类都有n个权重，与n个特征相乘后求和再经过softmax的结果，代表这条输入数据被分到这一类的概率。在最大熵模型的视角下，<strong><em>每条输入</em>的n个“特征”与k个类别共同组成了nk个特征，模型中有nk个权重，与特征一一对应。每个类别会触发nk个特征中的n个，这n个特征中的每个特征都会触发特征函数</strong>。</p>
<h3 id="经验分布"><a href="#经验分布" class="headerlink" title="经验分布"></a>经验分布</h3><p>经验分布是指通过训练数据$T$进行统计得到的分布。我们需要考察两个经验分布，分别是$x,y$的联合经验分布，以及$x$的经验分布。其定义如下：</p>
<script type="math/tex; mode=display">\hat p(x,y)={count(x,y)\over N},\ \hat p(x)={count(x)\over N}</script><p>对于任意特征函数$f$,记$E_{\hat p}(f)$表示$f$在训练数据$T$上关于$\hat p(x,y)$的数学期望。$E_p(f)$表示$f$在模型上关于$p(x,y)$的数学期望，由于<strong>模型中$p(x,y)$是未知的，并且我们建模的目标是$p(y|x)$，因此我们利用$Bayes$定理得到$p(x,y)=p(x)p(y|x)$，<em>此时，$p(x)$还是未知的</em>，我们可以使用经验分布$\hat p(x)$对$p(x)$进行近似</strong>。按照期望的定义有：</p>
<script type="math/tex; mode=display">E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)</script><script type="math/tex; mode=display">E_p(f)=\sum_{x,y}p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>对于概率分布$p(y|x)$我们希望特征$f$的期望应该和从训练数据中的到的一样的。（<strong>我的理解：特征函数是约束的提取量化，特征函数关于经验分布的期望与关于模型的期望相等就代表一个约束</strong>）因此我们可以提出约束：</p>
<script type="math/tex; mode=display">E_{\hat p}(f)=E_p(f)</script><script type="math/tex; mode=display">\sum_{x,y}\hat p(x,y)f(x,y)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>假设从训练数据中抽取了n个特征，相应的便有n个特征函数以及n各约束条件。</p>
<script type="math/tex; mode=display">C_i:E_p(f_i)=E_{\hat p}(f_i):=\tau_i,i=1,2,…,n</script><h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><p>给定数据集$T$，我们的目标就是根据最大上原理选择一个最优分类器，假设满足所有约束条件的模型集合为：</p>
<script type="math/tex; mode=display">C=\{P\in\pi|E_p(f_i)=E_{\hat p}(f_i),i=1,2,…,n \}</script><p>定义在条件概率分布$P(Y|X)$上的条件熵为：</p>
<script type="math/tex; mode=display">H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><p>则模型集合$C$中条件熵$H(P)$最大的模型成为最大熵模型。式中的对数为<strong>自然对数</strong>。</p>
<h2 id="最大熵模型的学习"><a href="#最大熵模型的学习" class="headerlink" title="最大熵模型的学习"></a>最大熵模型的学习</h2><p>最大熵模型的学习可以形式化为约束最优化问题。对于给定训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_n,y_n)\}$以及特征函数$f_i(x,y), i=1,2,3,…,n$，最大熵模型的学习等价于约束最优化问题(<strong>注意自变量为$P$</strong>)：</p>
<script type="math/tex; mode=display">\max_{P\in C}\ \ \ H(P)=-\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">\ \ \ s.t.\ \ \ E_P(f_i)=E_{\hat P}(f_i),\ i=1,2,….,n</script><script type="math/tex; mode=display">\sum_y P(y|x)=1\ \ \ \ \ \ \ \ \ \ \ \</script><p>按照最优化习惯，将求最大值问题改写为等价的求最小值问题：</p>
<script type="math/tex; mode=display">\min_{P\in C}\ \ \ -H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">\ \ \ s.t.\ \ \ E_P(f_i)-E_{\hat P}(f_i)=0,\ i=1,2,….,n</script><script type="math/tex; mode=display">1-\sum_y P(y|x)=0\ \ \ \ \ \ \ \ \ \ \ \</script><p>引入拉格朗日乘子$w_0,w_1,w_2,…,w_n$,定义拉格朗日函数$L(P,w)$(<strong>这里注意两自变量</strong>)：</p>
<script type="math/tex; mode=display">L(P,w)=-H(p)+w_0(1-\sum_yP(y|x))+\sum^n_{i=1}w_i(E_{\hat P}(f_i)-E_P(f_i))</script><p>又：</p>
<script type="math/tex; mode=display">-H(P)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)</script><script type="math/tex; mode=display">E_{\hat p}(f)=\sum_{x,y}\hat p(x,y)f(x,y)</script><script type="math/tex; mode=display">E_p(f)=\sum_{x,y}\hat p(x)p(y|x)f(x,y)</script><p>带入得到$L(P,w)$:</p>
<script type="math/tex; mode=display">L(P,w)=\sum_{x,y}\hat P(x)P(y|x)\log P(y|x)+w_0(1-\sum_yP(y|x)\ )+\sum ^n_{i=1}w_i(\sum_{x,y}\hat p(x,y)f(x,y)-\sum_{x,y}\hat p(x,y)f(x,y)\ )</script><p>对偶最优化的原始问题是（<strong>再次注意$min,max$的自变量是什么</strong>）：</p>
<script type="math/tex; mode=display">\min_{p\in C}\max_wL(P,w)</script><p>对偶问题是</p>
<script type="math/tex; mode=display">\max_w\min_{p\in C}L(P,w)</script><p>由于拉格朗日函数$L(P,w)$是$P$的凸函数，原始问题的解与对偶问题的解是等价的。这样，可以通过求解对偶问题来求解原始问题</p>
<p><em>注：以上的推理解释可在另一篇拉格朗日文章中找到</em></p>
<p>首先，求解对偶问题内部的极小化问题$\min_{p\in C}L(P,w)$。$\min_{p\in C}L(P,w)$是关于$w$的函数（<em>因为$\min_{p\in C}L(P,w)$代表$P$已经确定了</em>），将其记作：</p>
<script type="math/tex; mode=display">\Psi(w)=\min_{P\in C}L(P,w)=L(P_w,w),</script><p>注：上式的最后一项$L(P_w,w)$是归于$w$的函数，因为此时$P_w=\arg min_{P\in C}L(P,w)=P_w(y|x)$</p>
<p>$\Psi(x)$成为对偶函数，其解为$P_w$。</p>
<p>具体地，求$L(P,w)$对$P(y|x)$的偏导数（这里直接插入图片了手写这一段$mathjax$太累，将图片中$\lambda$换成$w$就行）<strong>注意蓝色字部分</strong></p>
<p><img src="/2018/03/07/最大熵模型/求偏导.jpg" alt=""></p>
<p>另偏导数等于0，在$\hat P(x)&gt;0$的情况下，解得：</p>
<script type="math/tex; mode=display">P(y|x)=exp(\ \sum^n_{i=1}w_if_i(x,y)+w_0-1\ )={exp(\sum^n_{i=1}w_if_i(x,y))\over \exp(1-w_0)}</script><p>由于$\sum_y P(y|x)=1$，得(关于$w$的函数)：</p>
<script type="math/tex; mode=display">P_w(y|x)={1\over Z_w(x)}exp(\ \sum^n_{i=1}w_if_i(x,y)\ )</script><p>其中，</p>
<script type="math/tex; mode=display">Z_w(x)=\sum_yexp(\ \sum^n_{i=1}w_if_i(x,y)\ )</script><p>$Z_w(x)$成为规范化因子；$f_i(x,y)$是特征函数；$w_i$是特征的权值。表示的模型$P_w=P_w(y|x)$就是最大熵模型。这里$w$是最大熵模型中的参数向量。</p>
<p>得到对偶问题内部的极小问题的解$P_w(y|x)$后，需要进一步求解外层的极大值问题。</p>
<script type="math/tex; mode=display">\max_w\Psi(w)</script><p>将其解记为$w^￥$,即：</p>
<script type="math/tex; mode=display">w^￥=\arg\ max_w\Psi(w)</script><p>令$\sum_{x,y}\hat P(x,y)f_i(x,y) = \tau_i$</p>
<p>$    \Psi (x)$</p>
<p>$=L(P_w,w)       注意这里P_w为定量是之前内部极小问题的解$</p>
<p>$=\sum_{x,y}\hat P(x)P_w(y|x)\log P_w(y|x)+\sum^n_{i=1}w_i( \tau_i-\sum_{x,y}\hat P(x)P_w(y|x)f_i(x,y) )$</p>
<p>$=\sum^n_{i=1}w_i\tau_i+\sum_{x,y}\hat P(x)P_w(y|x)( \log p_w(y|x)-\sum^n_{i=1}w_if_i(s,y) )$</p>
<p>又:$\log P_w(y|x)=\sum^n_{i=1}w_if_i(x,y)-\log Z_w(x)$</p>
<p>将上式带入到$\Psi$中，可以得到</p>
<p>$\Psi(w)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x,y}\hat P(x)P_w(y|x)\log Z_w(x)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x)\sum_y P_w(y|x)$</p>
<p>$=\sum^n_{i=1}w_i\tau_i-\sum_{x}\hat P(x)\log Z_w(x)          (这里利用了\sum_yP_w(y|x)=1 )$</p>
<h3 id="极大似然模型"><a href="#极大似然模型" class="headerlink" title="极大似然模型"></a>极大似然模型</h3><p>下面证明对偶函数的极大化等价于最大熵模型的极大似然估计。</p>
<p>注：极大似然估计$MLE$的一般形式表示为（<strong>推导下一小节给出</strong>）：</p>
<script type="math/tex; mode=display">L_{\hat P}=\Pi_xP(x)^{\hat P(x)}</script><p>一直训练数据的经验概率分布$\hat P(x,y)$，条件概率分布$P(Y|X)$的对数似然表示为：</p>
<script type="math/tex; mode=display">L_{\hat P}(P_w)=\log \Pi_{x,y}P(y|x)^{\hat P(x,y)}=\sum_{x,y}\hat P(x,y)\log P(y|x)</script><p>当条件概率分布$P(y|x)$是最大熵模型的内部极小函数的解释，对数似然函数$L_{\hat P}(P_w)$</p>
<p>为：</p>
<p><img src="/2018/03/07/最大熵模型/极大似然.png" alt=""></p>
<p>注：最后一步由$\sum_{x,y}\hat p(x,y)=\sum_x\hat p(x)\sum_yp(y|x)$且$\sum_yp(y|x)=1$得来</p>
<h3 id="最大熵模型中对数似然的解释"><a href="#最大熵模型中对数似然的解释" class="headerlink" title="最大熵模型中对数似然的解释"></a>最大熵模型中对数似然的解释</h3><p>转载自<a href="http://blog.csdn.net/wkebj/article/details/77965714" target="_blank" rel="noopener">CSDN</a></p>
<p>最近在学习最大熵模型，看到极大似然估计这部分，没有看明白条件概率分布$p(y|x)$的对数似然函数。上网查了很多资料都没有一个合理的解释。基本直接给出对数似然函数的一般形式 ($\hat p(x)$为jing’yan’gai’lv): </p>
<script type="math/tex; mode=display">L\hat p=\Pi_xp(x)^{\hat p(x)}</script><p>其实第一眼之所以不理解，因为这是最大似然函数的另外一种形式。一般书上描述的最大似然函数的一般形式是各个样本集XX中各个样本的联合概率: </p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)=\Pi^n_{i=1}p(x_i;\theta)</script><p>其实这个公式和上式是等价的。$x_1,x_2,…,x_n$是样本具体观测值。随机变量$X$是离散的，所以它的取值范围是一个集合，假设样本集的大小为$n$，$X$的取值有$k$个，分别是$v_1,v_2,…,v_k$。用$C(X=v_i)$表示在观测值中样本$v_i$出现的频率。所以$L(x_1,x_2,…,x_n;θ)$可以表示为： </p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)=\Pi^k_{i=1}p(v_i;\theta)^{C(X=v_i)}</script><p>对等式两边同时开$n$次方得：</p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)^{1\over n}=\Pi^k_{i=1}p(v_i;\theta)^{C(X=v_i)\over n}</script><p>因为经验概率$\hat p(x)={C(X=v_i)\over n}$，所以简写可以得到</p>
<script type="math/tex; mode=display">L(x_1,x_2,…,x_n)^{1\over n}=\Pi_xp(x;\theta)^{\hat p(x)}</script><p>很明显对$L(x_1,x_2,…,x_n;θ)$求最大值和对$L(x_1,x_2,…,x_n;θ)^{1\over n}$求最大值的优化的结果是一样的。整理上式所以最终的最大似然函数可以表示为：</p>
<script type="math/tex; mode=display">L(x;\theta)=\Pi_xp(x;\theta)^{\hat p(x)}</script><h2 id="从最大熵模型角度理解LR"><a href="#从最大熵模型角度理解LR" class="headerlink" title="从最大熵模型角度理解LR"></a>从最大熵模型角度理解LR</h2><p>LR是最大熵模型在类别为2时候的特例</p>
<p>假设<strong>每条输入</strong>第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。</p>
<script type="math/tex; mode=display">f(x,y) =\begin{cases}x_i,  & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}</script><p>根据最大熵模型：</p>
<script type="math/tex; mode=display">P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}</script><p>现在回到两类的情况$\{0,1\}$，此时分母上有两项：</p>
<script type="math/tex; mode=display">P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}</script><p>分子、分母同时除以分子，则有：</p>
<script type="math/tex; mode=display">P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}</script><p>这就变成了$logistic$函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[最大熵模型的理解、推导以及与LR的联系]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="最大熵模型" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="特征函数" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Logistic Regression的理解]]></title>
    <link href="http://yoursite.com/2018/03/06/Logistic-Regression%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/06/Logistic-Regression的理解/</id>
    <published>2018-03-06T12:52:28.000Z</published>
    <updated>2018-03-09T04:13:54.837Z</updated>
    <content type="html"><![CDATA[<h2 id="逻辑斯地回归模型"><a href="#逻辑斯地回归模型" class="headerlink" title="逻辑斯地回归模型"></a>逻辑斯地回归模型</h2><h3 id="逻辑斯谛分布"><a href="#逻辑斯谛分布" class="headerlink" title="逻辑斯谛分布"></a>逻辑斯谛分布</h3><p>设$X$是连续随机变量，$X$服从逻辑斯谛分布是指$X$具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">F(x)=P(X\le x)= {1 \over 1+e^{-(x-\mu )/\gamma}}</script><script type="math/tex; mode=display">f(x)=F'(x)={e^{-(x-\mu)/y} \over \gamma(1+e^{-(x-\mu)}/\gamma)^2}</script><p>式中，$\mu$为位置参数，$\gamma\gt0$为形状参数。密度函数与分布函数如下图所示。</p>
<p><img src="/2018/03/06/Logistic-Regression的理解/分布.jpg" alt=""></p>
<p><strong>注：逻辑斯谛分布的回归会在从广义线性模型角度理解LR时给出</strong></p>
<h3 id="二项逻辑斯谛回归模型"><a href="#二项逻辑斯谛回归模型" class="headerlink" title="二项逻辑斯谛回归模型"></a>二项逻辑斯谛回归模型</h3><p>二项逻辑斯谛回归模型是一种<strong>分类模型</strong>，由条件概率分布$P(Y|X)$表示，形式为参数化的逻辑斯谛分布。这里，随机变量取值为实数，随机变量Y，取值为1或0，即Y满足二项分布。</p>
<p><strong>定义：</strong>二项逻辑斯谛回归模型是如下的条件概率分布：</p>
<script type="math/tex; mode=display">P(Y=1|x)={exp(wx) \over 1+exp(wx) }={1\over 1+exp(-wx)}</script><script type="math/tex; mode=display">P(Y=0|x)={1 \over 1+exp(wx)}={exp(-wx) \over 1+exp(-wx)}</script><p>一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率是$p$,那么该事件的几率是${p\over 1-p}$，该事件的对数几率或者logit函数是：</p>
<script type="math/tex; mode=display">logit(p)=\log {p \over 1-p}</script><p>这里$logit(p)$就是广义线性模型中的$\eta$。</p>
<p>对于逻辑斯谛回归而言</p>
<script type="math/tex; mode=display">\log {P(Y=1|x) \over 1-P(Y=1|x)}=wx\ \ \ 其实就是广义线性模型第三条假设</script><p>从广义线性模型角度，二项分布指数族解出的$\eta = \log{p\over 1-p}=logit(p)$,又由第三条假设，$\eta=wx$即可得到$\log {p\over 1-p}=wx$,求解出$p$来就是$P(Y=1|X)$的概率，又因为二项分布期望为$P$,所以收敛的结果就是$P$.</p>
<h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p>逻辑斯谛回归模型学习中，对于给定的训练数据集$T=\{(x_1,y_1),(x_2,y_2),…,(x_N,y_n)\}$ ，其中，$x_I\in R^n,y_i\in\{0,1\}$,可以应用<strong>极大似然估计法</strong>估计模型参数，从而得到逻辑斯谛回归模型。设：</p>
<script type="math/tex; mode=display">P(Y=1|x)=\pi(x),\ \ \ P(Y=0|x)=1-\pi(x)</script><p>似然函数为</p>
<script type="math/tex; mode=display">\Pi^N_{i=1}[\pi(x_i)^{y_i}][1-\pi(x)]^{1-y_i}</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">L(w)=\sum^N_{i=1}[y_i\log \pi(x_i)+(1-y_i)\log (1-\pi(x_i))]</script><script type="math/tex; mode=display">\ \ \ =\sum^N_{i=1}[y_i\log{\pi(x) \over 1-\pi(x_i)}+\log(1-\pi(x_i))]</script><script type="math/tex; mode=display">\ \ =\sum^N_{i=1}[y_i(wx)-\log(1+exp(wx))]\ \ \ \ \</script><h2 id="从最大熵模型角度理解LR"><a href="#从最大熵模型角度理解LR" class="headerlink" title="从最大熵模型角度理解LR"></a>从最大熵模型角度理解LR</h2><p>LR是最大熵模型在类别为2时候的特例</p>
<p>假设<strong>每条输入</strong>第$i$个特征对第$k$类的贡献是$w_{ki}$，则数据点$(x_1,x_2,…,x_n)$属于第$k$类的概率正比于$exp(w_{k1}x_1+w_{k2}x_2+…+w_{kn}x_n)$。</p>
<script type="math/tex; mode=display">f(x,y) =\begin{cases}x_i,  & \text{y=1}\ \ \ \ i=1,2,…,n \\0, & \text{y=0}\end{cases}</script><p>根据最大熵模型：</p>
<script type="math/tex; mode=display">P(y=k)={\exp (\sum^n_{i=1}w_{ki}x_i)\over \sum_y\exp (\sum^n_{i=1}w_{yi}x_i)}</script><p>现在回到两类的情况$\{0,1\}$，此时分母上有两项：</p>
<script type="math/tex; mode=display">P(y=1)={\exp (\sum^n_{i=1}w_{1i}x_i)\over \exp (\sum^n_{i=1}w_{1i}x_i)+\exp (\sum^n_{i=1}w_{0i}x_i)}</script><p>分子、分母同时除以分子，则有：</p>
<script type="math/tex; mode=display">P(y=1)={1\over 1+\exp(-\sum^n_{i=1}w_ix_i)}</script><p>这就变成了$logistic$函数。</p>
<h2 id="从广义线性模型角度理解LR"><a href="#从广义线性模型角度理解LR" class="headerlink" title="从广义线性模型角度理解LR"></a>从广义线性模型角度理解LR</h2><p>线性回归中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta) 服从N(\mu,\sigma^2)分布</script><p>$LR$中我们假设：</p>
<script type="math/tex; mode=display">y(x;\theta)服从Bernoulli(\phi)分布</script><p>其实他们只是广义线性模型($GlMs$)的特例。</p>
<h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p><strong>广义线性模型是通过链接函数（$LR$中为$logit$函数），把自变量的线性组合（$\eta$ 自然参数/标准参数）与因变量（$T(y)$)的期望联系起来。</strong></p>
<p>注：$LR$也可以说与因变量的概率分布结合起来，因为二项伯努利分布$E=P$</p>
<h3 id="指数分布族（-The-exponential-family-）"><a href="#指数分布族（-The-exponential-family-）" class="headerlink" title="指数分布族（$The exponential family$）"></a>指数分布族（$The exponential family$）</h3><p>首先我们定义一下什么是指数分布族，它有如下形式($\eta$自变量，$y$因变量)：</p>
<script type="math/tex; mode=display">p(y;\eta)=b(y)\exp(\eta^TT(y)-a(\eta))</script><p>简单介绍一下其中的参数：</p>
<p>1.$\eta $是自然参数</p>
<p>2.$T(y)$是充分统计量(一般情况下$T(y)=y$)</p>
<p>3.$a(\eta)$是$\log partition function$( $ exp(-a(\eta))$充当正规化常量的角色，保证$\sum p(y;\eta)=1 $)</p>
<p>也就是说$T,a,b$确定了一种分布，$\eta$是该分布的参数。</p>
<p>选择合适的$T,a,b$我们可以得到高斯分布和$Bernouli$分布</p>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p><img src="/2018/03/06/Logistic-Regression的理解/伯努利1.jpg" alt=""></p>
<p><img src="/2018/03/06/Logistic-Regression的理解/伯努利2.jpg" alt=""></p>
<p><img src="/2018/03/06/Logistic-Regression的理解/伯努利3.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[LR的推导以及从广义线性模型、最大熵模型角度的理解]]>
    
    </summary>
    
      <category term="LR" scheme="http://yoursite.com/tags/LR/"/>
    
      <category term="最大熵模型" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="广义线性回归" scheme="http://yoursite.com/tags/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="逻辑斯谛回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E6%96%AF%E8%B0%9B%E5%9B%9E%E5%BD%92/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最优化问题及KKT条件的几何理解]]></title>
    <link href="http://yoursite.com/2018/03/04/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%8F%8AKKT%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%87%A0%E4%BD%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/04/最优化问题及KKT条件的几何理解/</id>
    <published>2018-03-04T07:31:31.000Z</published>
    <updated>2018-03-08T02:40:53.234Z</updated>
    <content type="html"><![CDATA[<p>以二维空间$R^2$举例，从简单的无约束优化（0梯度条件），到等式约束优化（拉格朗日条件），再到不等式约束优化（KKT条件）解析优化问题解法的几何意义。</p>
<h2 id="无约束优化问题"><a href="#无约束优化问题" class="headerlink" title="无约束优化问题"></a>无约束优化问题</h2><p>$\min f(x)$，其中，<strong>$x=(x_1,x_2)$</strong></p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/无约束优化.jpg" alt=""></p>
<p>此时，对于$f(x)$的局部极小值点（红点）处梯度必然为0.因此优化问题可以转化为求解梯度为0的点。</p>
<h2 id="带等式约束的优化问题"><a href="#带等式约束的优化问题" class="headerlink" title="带等式约束的优化问题"></a>带等式约束的优化问题</h2><p>$\min f(x)$，其中，<strong>$x=(x_1,x_2)$</strong></p>
<p>$s.t. h(x)=0$</p>
<p>与无约束问题不同，此时极小值点被限制在曲线$h(x)=0$上，我们因此将$\{x|h(x)=0\}$成为<strong>可行域</strong>，解只能在这个可行域里面取。如下图所示，曲线$h(x)=0$（黑色实线）便是可行域，现在要求在可行域上面的极小点。可以想象从无约束问题的极小点（黑点）靠等高线向外扩展，当扩展等高线第一次接触可行域时候（相切，<strong>梯度方向相反</strong>）的交点便是可行域的极小点。所以，相切，梯度方向相反，是取得极小值点的必要条件。</p>
<p>补充：能够碰到极大极小值点的必要条件是：梯度场与切空间垂直，也就是梯度场不能够有任何流形切空间上的分量，否则在切空间方向有分量，在流形上沿分量方向走，函数值会增加，沿反方向走，函数值会减少，不可能为局部极小或者极大值点。</p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/等式约束优化.jpg" alt=""></p>
<p>两条曲线相切，梯度方向相反，即梯度差一个任意的常数乘子（取为$-\lambda$）：$\nabla f(x)=-\lambda \nabla h(x)$，调整后即可得到拉格朗日条件$\nabla (f(x)+\lambda h(x))=0$.</p>
<p>如此，带等式约束的优化问题转化为了无约束的优化问题，只需要对拉格朗日条件解方程组即可。这里$\lambda$便是拉格朗日乘子，有多少个等式约束就有多少个拉格朗日乘子。</p>
<h2 id="带不等式约束的优化问题"><a href="#带不等式约束的优化问题" class="headerlink" title="带不等式约束的优化问题"></a>带不等式约束的优化问题</h2><h3 id="只有一个不等式起作用时"><a href="#只有一个不等式起作用时" class="headerlink" title="只有一个不等式起作用时"></a>只有一个不等式起作用时</h3><p>$\min f(x)$</p>
<p>$s.t.  h(x)\le0$</p>
<p>当只有一个不等式起作用时，如下图所示，可行域变成了阴影部分，最小值点还是切点，跟等式约束条件完全一样，只需要把不等号当做等号去求解即可。</p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/不等式约束优化1.jpg" alt=""></p>
<h3 id="两个及以上不等式起作用时"><a href="#两个及以上不等式起作用时" class="headerlink" title="两个及以上不等式起作用时"></a>两个及以上不等式起作用时</h3><p>$\min f(x)$</p>
<p>$s.t.$</p>
<p>$g_1(x)\le0$</p>
<p>$g_2(x)\le0$</p>
<p>如下图，当$f(x)$等高线慢慢扩大时，等高线与可行域（阴影部分）第一次相遇的点是个顶点，2个不等式同时起作用。满足最小值点从原来黑点的位置（切点）移动到了红点的位置，现在跟哪条约束函数都不相切了。这时候就需要用到KKt条件了。这里的条件是指：某一个点它如果是最小值点的话，就必须满足这个条件（在含不等式约束的优化问题里）。这是个<strong>必要条件</strong>，前面说的也全部是<strong>必要条件</strong>。</p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/不等式约束优化2.jpg" alt=""></p>
<p>这个问题的解$x^*$应满足的KKT（卡罗需-库恩-塔克）条件为：</p>
<p>$1. \mu_1\ge0, \mu_2\ge0;$</p>
<p>$2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)=0;$</p>
<p>$3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)=0$</p>
<p>其中，$\mu$叫做KKT乘子，有多少个不等式约束就有多少个KKT乘子。加上本问题中的约束不封，就是完整版的KKT条件。<strong>对于有等式的情况：把其中一个不等式约束换成等式，可行域变成了半条曲线，最小值还是小红点，情况是一样的。</strong></p>
<p>接下来看看KKT条件的几何意义。上图中<strong>绿色箭头</strong>为两条曲线的<strong>负梯度</strong>方向，<strong>红色箭头</strong>为等高线的<strong>梯度</strong>方向。如果这个顶点为满足约束的最小值点，那么该点处等高线梯度（红色箭头）一定在两个绿色箭头之间（$-\nabla g(x)$方向（绿色箭头）一定指向$g(x)$减小方向，即$g(x)\lt0$一边）</p>
<p>$\mu_1\ge0,\mu_2\ge0$(红色箭头一定在绿色箭头之间)的解释：若三个向量的位置如下图所示，即$-\nabla f(x)$落在$\nabla g_1,\nabla g_2$所形成的锥形区域外侧。此时，作等高线（等值线）在点$x^k$处的切平面，可以发现：<strong>沿着与扶梯度$-\nabla f(x)$成锐角方向移动</strong>，只要能在红色阴影（阴影左界为当前等高线）取值，$f(x)$总能减小，而红色阴影区域为可行域，因此既可以建系哦啊目标函数值，又不破坏约束条件，所以当前$x^k$不是最优点。</p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/箭头中间.jpg" alt=""></p>
<h2 id="有些不等式约束不起作用时"><a href="#有些不等式约束不起作用时" class="headerlink" title="有些不等式约束不起作用时"></a>有些不等式约束不起作用时</h2><p>如下面这个优化问题：</p>
<p>$\min f(x)$</p>
<p>$s.t.$</p>
<p>$g_1(x)\le0$</p>
<p>$g_2(x)\le0$</p>
<p>$g_3(x)\le0$</p>
<p>如下图$g_3(x)\le0$是不起作用的</p>
<p><img src="/2018/03/04/最优化问题及KKT条件的几何理解/不等式约束优化3.jpg" alt=""></p>
<p>对于最小值点$x^*$，三个不等式约束的不同在于：</p>
<p>$g_1(x^￥)=0$（起作用）</p>
<p>$g_2(x^￥)=0$（起作用）</p>
<p>$g_3(x^￥)\lt0$（不起作用，最小值点不在$g_3(x)=0$上）</p>
<p>此时KKT条件1，2变为：</p>
<p>$1. \mu_1\ge0, \mu_2\ge0, \mu_3\ge0, $</p>
<p>$2. \nabla f(x^￥)+\mu_1\nabla g_1(x^￥)+\mu_2\nabla g_2(x^￥)+\mu_3\nabla g_3(x^￥)=0$</p>
<p>条件2中的$\mu_3\nabla g_3(x^￥)$让我们很苦恼，$g_3(x￥)$约束根本不起作用，要是能令$\mu_3=0$就好了。加上条件3：</p>
<p>$3. \mu_1g_1(x^￥)+\mu_2g_2(x^￥)+\mu_3g_3(x^￥)=0$</p>
<p>恰好能使$\mu_3=0​$。由于$g_1(x^￥)=0, g_2(x^￥)=0​$，所以前两项等于0，第三项$g_3(x^￥)\lt0​$,在条件3的作用下使得$\mu_3=0​$。正好满足哟啊求。如果再多几项不起作用的不等式约束，条件2都能在条件3的作用下实现：目标函数$f(x)​$的梯度$\nabla f(x)​$被起作用的不等式约束函数$g(x)​$的负梯度$-\nabla g(x)​$线性标出且系数$\mu​$全部非负（红色箭头被绿色箭头夹在中间）。这样，优化问题的求解就变成了对所有KKT条件解方程组。</p>
<p>如果再定义一个拉格朗日函数：</p>
<p>$L(x,\mu)=f(x)+\mu_1g_1(x)+\mu_2g_2(x)+…$</p>
<p>令它对<strong>$x$</strong>的偏导为0，就是KKT条件中的条件2了。</p>
<p>注意：以上所有都是局部极小值的点<strong>必要条件</strong>。据此求得的解不一定是局部极小值点（更别提全局），原因是上图中所画的等高线也许根本就不闭合，也急速实说我们一直想靠近的等高线和中间的黑点可能压根就是个鞍点或者近似鞍点。</p>
]]></content>
    <summary type="html">
    <![CDATA[从无约束最优化到等式约束优化，再到不等式优化，以及对拉格朗日对偶中KKT条件的几何理解]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="KKT" scheme="http://yoursite.com/tags/KKT/"/>
    
      <category term="最优化" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拉格朗日对偶性]]></title>
    <link href="http://yoursite.com/2018/03/03/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    <id>http://yoursite.com/2018/03/03/拉格朗日对偶性/</id>
    <published>2018-03-03T14:49:03.000Z</published>
    <updated>2018-03-04T08:04:05.776Z</updated>
    <content type="html"><![CDATA[<h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><p>​    假设$f(x), c_i(x), h_j(x)$是定义在<strong>$R^n$</strong>上面的连续可微函数，考虑约束最优化问题</p>
<script type="math/tex; mode=display">\min_{x\in R^n}f(x)</script><script type="math/tex; mode=display">s.t.\ c_i(x)\le0,\ i=1,2,…,k</script><script type="math/tex; mode=display">h_j(x)=0,\ j=1,2,…,l ​</script><p>​    称此约束最优化问题为原始最优化问题或原始问题。</p>
<p>​    首先，引进广义拉格朗日函数</p>
<script type="math/tex; mode=display">L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)</script><p>​    这里，$\alpha_i,\beta_j$是拉格朗日乘子，$\alpha_i\ge0$.</p>
<p>​    考虑函数(<strong><em>注意：此时$L(x,\alpha,\beta)$的变量是$\alpha_i\beta_j$</em></strong>)：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script><p>​    这里下标$P(Primal)$表示原始问题.对于此函数（关于$\alpha,\beta$的函数，$x$是常量），经过我们优化（不管什么方法），确定$\alpha,\beta$的值，就可以得到$L(x,\alpha,\beta)$的最大值，因为此时$\alpha,\beta$已经确定，显然最大值<script type="math/tex">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)</script>就是<strong><em>只和$x$有关的函数</em></strong></p>
<p>​    下面通过$x$是否绵竹约束条件两方面来分析这个函数：</p>
<p>​        1.考虑某个$x$违反了原始的约束，即$c_i\gt0$或者$h_j\neq0$，那么：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)]=\infty</script><p>​        2.考虑$x$满足原始的约束，则：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\max_{\alpha,\beta:\alpha_i\ge0}[f(x)]=f(x)</script><p>​    注意最大化确定$\alpha,\beta$的过程，$f(x)$就是个常量，常量的最大值显然是本身</p>
<p>​    通过上面两条分析可以得出：</p>
<script type="math/tex; mode=display">\Theta_P(x)=\begin{cases}f(x),\ {x满足原始问题约束}\\+\infty,\ {其他}\\\end{cases}</script><p>​    那么<strong>在满足约束的条件下：</strong></p>
<script type="math/tex; mode=display">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script><p>​    即$\min_x\Theta_P(x)$与原始优化问题等价，所以常用$\min_x\Theta_P(x)$来代表原始问题，定义原始问题的最优值：</p>
<script type="math/tex; mode=display">p^*=\min_x\Theta_P(x)</script><p>​    原始问题讨论到这里，总结：重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题。</p>
<h2 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h2><p>​    定义<strong>关于$\alpha,\beta$的函数</strong>：</p>
<script type="math/tex; mode=display">\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)</script><p>​    注意上面等式<strong>右边是关于$x$的函数最小化,$x$确定之后，最小值就只与$\alpha,\beta$有关，所以此时是一个关于$\alpha,\beta$的函数</strong></p>
<p>​    再考虑极大化$\Theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$，即：</p>
<script type="math/tex; mode=display">\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)</script><p>​    这就是原始问题的对偶问题，再将原始问题写出来：</p>
<script type="math/tex; mode=display">\min_x\Theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=min_xf(x)</script><p>​    从形式上可以看出堆成，只不过<strong>原始问题先固定$L(x,\alpha,\beta)$中的$x$,优化参数$\alpha,\beta$，再优化$x$；而对偶问题是先固定$\alpha,\beta$，再优化$x$，然后再确定参数$\alpha,\beta$</strong></p>
<p>​    定义对偶问题的最优值：</p>
<script type="math/tex; mode=display">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\Theta_D(\alpha,\beta)</script><h2 id="原始问题与对偶问题之间的关系"><a href="#原始问题与对偶问题之间的关系" class="headerlink" title="原始问题与对偶问题之间的关系"></a>原始问题与对偶问题之间的关系</h2><p>​    若原始问题和对偶问题都有最优值，则有$Min-Max$不等式：</p>
<script type="math/tex; mode=display">d^*=\max_{\alpha,\beta:\alpha_i\ge0}\min_xL(x,\alpha,\beta)\le\min_x\max_{\alpha,\beta:\alpha_i\ge0}L(x,\alpha,\beta)=p^*</script><p>​    当$L(x,\alpha,\beta)$对$x$为凸函数，对$\alpha,\beta$为凹函数，以上等号成立。而$L(x,\alpha,\beta)$对$\alpha,\beta$为天然凹函数，因此只要$L(x,\alpha,\beta)$对$x$为凸函数，等号便成立</p>
<p>​    证明：一个式子的最大值永远大于等于这个式子的最小值，哪怕是这个式子最小的最大值与最大的最小值相比（瘦死的骆驼比马大）。</p>
]]></content>
    <summary type="html">
    <![CDATA[对拉格朗日对偶性的理解]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="拉格朗日对偶" scheme="http://yoursite.com/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <link href="http://yoursite.com/2018/02/27/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2018/02/27/剑指offer/</id>
    <published>2018-02-27T00:32:16.000Z</published>
    <updated>2018-03-06T11:14:21.327Z</updated>
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>Q:</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>思路：</strong>思路从右上开始，右上为一行最大，一列最小。target&lt;右上，删一列;  target&gt;右上,删一行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(array) <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>python式。。</p>
<p>其他语言思路：从头到尾遍历数空格数量，然后从后往前遍历，碰到空格后根据之前数好的数量移位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s= s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>Q:</strong>输入一个链表，从尾到头打印链表每个节点的值</p>
<p><strong>思路：</strong>遍历链表每次遍历的val从头插入list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        list = []</span><br><span class="line">        p = listNode</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            list = [p.val] + list</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>Q:</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>思路：</strong>先序第一个为根节点，中序中根节点左边全在左子树，右边全在右子树。据此用递归建树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的解法</span></span><br><span class="line"><span class="comment"># 对len==1的list判定，繁琐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution32</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span> <span class="keyword">and</span> len(tin) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root_index = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="number">0</span>:</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:root_index+<span class="number">1</span>],tin[:root_index])</span><br><span class="line">        <span class="keyword">if</span> root_index != len(tin)<span class="number">-1</span>:</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[root_index+<span class="number">1</span>:],tin[root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精简解法</span></span><br><span class="line"><span class="comment"># 对空list的判定，鲁棒性更强，更精简</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">    index = tin.index(root.val)</span><br><span class="line">    root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:index+<span class="number">1</span>], tin[<span class="number">0</span>:index])</span><br><span class="line">    root.right = self.reConstructBinaryTree(pre[index+<span class="number">1</span>:], tin[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>Q:</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>思路：</strong>太简单，不说了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution5</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        nums = rotateArray</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> p &gt; <span class="number">0</span> <span class="keyword">and</span> nums[p<span class="number">-1</span>]&lt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[p] &lt; min:</span><br><span class="line">                min = nums[p]</span><br><span class="line">        <span class="keyword">return</span> min</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><strong>Q:</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>
<p><strong>思路：</strong>分别用while 与 递归实现</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不用递归，避免重复运算，运行时间短</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution6</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= n:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br><span class="line"><span class="comment"># 递归，代码简单，运行超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution62</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n<span class="number">-1</span>) + self.Fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>思路：</strong>斐波那契数列问题，斐波那契数列前移一位</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution7</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p><strong>Q:</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<p><strong>思路：</strong></p>
<p>F(n) = F(n-1)+F(n-2)+F(n-3)+….+F(1)</p>
<p>第n项是前n-1项的和，所以第n+1项是第n项的两倍，都是二的指数次方</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution8</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> ** (number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><strong>Q:</strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>思路：</strong>还是个斐波那契问题 n*2 矩形覆盖时候最后一步要不覆盖田，要不覆盖日，因此是斐波那契问题F(n) = F(n-1)+F(n-2)只不过题目规定F(0)=0</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution9</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> number:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        post = <span class="number">1</span></span><br><span class="line">        count = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= number:</span><br><span class="line">            temp = post</span><br><span class="line">            post = pre + post</span><br><span class="line">            pre = temp</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>Q:</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>思路1：</strong>一个整数减去1，再和原整数做 与 运算，会把该整数最右边的1变成0（用补码表示的负数也是）。所以一个整数中有多少个1就可以进行多少次这种运算该法用python写超时</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution10</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>因为右移数字n会造成死循环（负数第一位是1），可以先把n和1做与运算，判断n的最低位是不是1，接着把1左移一位得到2，再和n做与运算……反复左移就能判断n的其中一位是不是1</p>
<p><strong>注意：</strong>1要是无符号整数(unsigned int)</p>
<p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count ++</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>Q:</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>思路：</strong>Life is short, you need python</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution11</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> pow(base, exponent)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"><a href="#调整数组是奇数位于偶数前并保证奇数偶数各自相对位置" class="headerlink" title="调整数组是奇数位于偶数前并保证奇数偶数各自相对位置"></a>调整数组是奇数位于偶数前并保证奇数偶数各自相对位置</h2><p><strong>Q:</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>思路：</strong>一个list存奇数一个list存偶数，两个合起来</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution12</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res1 = []</span><br><span class="line">        res2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">                res2.append(array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res1.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> res1+res2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p><strong>Q:</strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>思路：</strong>构造长度为K的滑窗（构造时考虑K过大问题），将滑窗滑至最后即可</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution13</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        post = pre = head</span><br><span class="line">        count = k</span><br><span class="line">        <span class="keyword">while</span> k<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post = post.next</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post.next:</span><br><span class="line">            post = post.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong>Q:</strong>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p><strong>思路：</strong>比较简单临近双指针遍历至最后，注意最后对边界值的处理</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution14</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        post = pHead.next</span><br><span class="line">        pHead.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> post:</span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                temp = post.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                post.next = pHead</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            post.next = pHead</span><br><span class="line">            pHead = post</span><br><span class="line">            post = temp</span><br><span class="line">        <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p><strong>Q:</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>思路：</strong>每次选出两个链表较小的头结点，然后用剩下的递归链接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution15</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1 <span class="keyword">or</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pHead1.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pHead2.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>Q:</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p><strong>思路1：</strong>递归的查找子结构</p>
<p><strong>注意：</strong></p>
<p>①要全面遍历所有所可能（类似机器人路径中的找出所有起始位置），不能找到一对根节点相等的点，后面不等就return False；    这里体现在相等时候也留一手 or 类似与不等继续进行判断    </p>
<p> ②因为题中给出空节点不是子结构，而我迭代又要用到对pRoot2是否为空的判断，因此，先对pRoot2判断，再单独写了个函数     </p>
<p>③本题求的是子结构而非子树</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution16</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">(pRoot1,pRoot2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1.val ==pRoot2.val:</span><br><span class="line">                <span class="comment"># 注意or的运用，遍历所有可能的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (  (Search(pRoot1.left,pRoot2.left) <span class="keyword">and</span> Search(pRoot1.right,pRoot2.right))</span><br><span class="line">                                 <span class="keyword">or</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2) )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Search(pRoot1.left,pRoot2) <span class="keyword">or</span> Search(pRoot1.right,pRoot2)</span><br><span class="line">        <span class="keyword">return</span> Search(pRoot1,pRoot2)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>更精简的分治递归</p>
<p>写一个函数判断两树是同一根节点的情况下pRoot2是否是pRoot1的子结构</p>
<p>在主函数里递归调用这个函数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(pRoot1,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.left,pRoot2) <span class="keyword">or</span> self.IsSub(pRoot1.right,pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsSub</span><span class="params">(self,p1,p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> p1.val != p2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsSub(p1.left,p2.left) <span class="keyword">and</span> self.IsSub(p1.right,p2.right)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>Q:</strong>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><strong>思路：</strong>递归实现没什么难度</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution17</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            temp = root.left</span><br><span class="line">            root.left = root.right</span><br><span class="line">            root.right = temp</span><br><span class="line">            Trans(root.left)</span><br><span class="line">            Trans(root.right)</span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><strong>Q:</strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><strong>思路：</strong>通过递归函数实现，每次添加最外一圈</p>
<p><strong>注意：</strong>对行列为2的判断（里面的if判断），过程中一个不满足就代表添加完毕</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution18</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.List = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        row_u = <span class="number">0</span></span><br><span class="line">        row_d = len(matrix) - <span class="number">1</span></span><br><span class="line">        col_l = <span class="number">0</span></span><br><span class="line">        col_r = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Printnum</span><span class="params">(matrix,row_u,row_d,col_l,col_r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> row_u &gt; row_d <span class="keyword">or</span> col_l &gt; col_r:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_l,col_r+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[row_u][j])</span><br><span class="line">                row_u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_u,row_d+<span class="number">1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_r])</span><br><span class="line">                col_r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col_r,col_l<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[row_d][j])</span><br><span class="line">                row_d -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row_u &lt;= row_d <span class="keyword">and</span> col_l &lt;= col_r:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row_d,row_u<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    self.List.append(matrix[i][col_l])</span><br><span class="line">                col_l += <span class="number">1</span></span><br><span class="line">            Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        Printnum(matrix,row_u,row_d,col_l,col_r)</span><br><span class="line">        <span class="keyword">return</span> self.List</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="包含Min函数的栈"><a href="#包含Min函数的栈" class="headerlink" title="包含Min函数的栈"></a>包含Min函数的栈</h2><p><strong>Q:</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p><strong>思路：</strong>python式。。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution19</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack = self.stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> min(self.stack)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>Q:</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>思路：</strong>弹出一个便从压入list中记录index为p，并删除 这个元素。下一个弹出的元素的index只能是p的前一个位置(pre)或者后面位置，弹出后便继续更新p</p>
<p><strong>注意：</strong>压入list中删除元素后要更新index。list.remove(val)删除后会更新index，正好符合这道题。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution20</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pre = p = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(popV)):</span><br><span class="line">            <span class="comment"># 判断pushV popV是否一致</span></span><br><span class="line">            <span class="keyword">if</span> popV[i] <span class="keyword">not</span> <span class="keyword">in</span> pushV:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> pushV.index(popV[i]) &lt; pre:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p = pushV.index(popV[i])</span><br><span class="line">            pushV.remove(popV[i])</span><br><span class="line">            <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">                pre = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = p - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p><strong>Q:</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>思路：</strong>简单的层序遍历</p>
<p><strong>注意：</strong>node=[] res=[] 跟 node=res=[]的区别，前面两个是两个[]，后面两个是同一个[]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution21</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        node = []</span><br><span class="line">        res = []</span><br><span class="line">        node.append(root)</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            res.append(node[<span class="number">0</span>].val)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].left:</span><br><span class="line">                node.append(node[<span class="number">0</span>].left)</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].right:</span><br><span class="line">                node.append(node[<span class="number">0</span>].right)</span><br><span class="line">            node = node[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的后序遍历序列"><a href="#二叉树的后序遍历序列" class="headerlink" title="二叉树的后序遍历序列"></a>二叉树的后序遍历序列</h2><p><strong>Q:</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>二叉搜索树的中序遍历序列便相当于升序序列，因此将原序列排序便得到中序序列。然后判断能否成树判断能否成树的方法：后序最末位为根节点，通过此节点在中序中的位置（mid_index）分割左右子树节点。</p>
<p><strong><em>递归判断不能成树的条件是：递归中一旦出现两序列节点组成不一致的情况（最重要的思想！！！想死我了）</em></strong></p>
<p><strong>注意：</strong>其实此题不需要用到二叉搜索树left&lt;root&lt;right，或者说这个条件的全部信息都转化为升序序列为中序序列刚看此题想到中序序列以为此题得到解决，但是拘泥于二叉搜索树的性质写不出递归，其实可完全转化为一个中序一个后序能否成树问题。能否成树又可通过递归过程序列组成是否全程一致来判断。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mid = sorted(sequence)</span><br><span class="line">        post = sequence</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Define</span><span class="params">(mid, post)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mid <span class="keyword">and</span> <span class="keyword">not</span> post:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 不能成树的判定</span></span><br><span class="line">            <span class="keyword">if</span> set(mid)!= set(post):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            mid_index = mid.index(post[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> Define(mid[:mid_index],post[:mid_index]) <span class="keyword">and</span> Define(mid[mid_index+<span class="number">1</span>:],post[mid_index:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> Define(mid,post)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p><strong>Q:</strong>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p><strong>思路：</strong>定义全局list：self.res，用rest记录剩下路径所需拟合值，PathList记录当前路径。递归遍历节点如果root.val拟合完毕，将PathList并入全局res，并且rest重置为expectNumber，重置PathList=[]，从孩子节点从头递归；如果root.val不拟合rest，则将这个节点加入当前PathList，左右孩子传承此PathList继续递归寻找接下来的Path，左右孩子也要不继承PathList把rest重置为expectNumber从头递归</p>
<p><strong>注意：</strong></p>
<p>①root.val拟合或者不拟合都要在左右孩子加一个递归重置rest为expectNumber，重置PathList=[]继续寻找     </p>
<p>②左右节点继承当前PathList递归时，PathList要分开指代，要不右节点会继承左节点的PathList     </p>
<p>③PathList2=PathList这种方法指代，这俩指针还是指向同一list</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution23</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Path</span><span class="params">(root, expectNumber, rest, PathList=[] )</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.val == rest:</span><br><span class="line">                PathList=PathList+[root.val]</span><br><span class="line">                <span class="comment"># 不加以下这个if结构是任意子路径，加了代表路径结尾必须是叶子节点。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    self.res.append(PathList)</span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                PathList.append(root.val)</span><br><span class="line">                rest -= root.val</span><br><span class="line">                <span class="comment"># 将此节点填入路径继续递归</span></span><br><span class="line">                <span class="comment"># 接下来两个递归会操作同一个PathList，这两个不应该操作统一list</span></span><br><span class="line">                <span class="comment"># 直接令PathList2=PathList这俩还是指向同一个</span></span><br><span class="line">                PathList2 = []</span><br><span class="line">                PathList2 += PathList</span><br><span class="line">                Path(root.left,expectNumber,rest,PathList)</span><br><span class="line">                Path(root.right,expectNumber,rest,PathList2)</span><br><span class="line">                <span class="comment"># 从此节点的子节点开始从头寻找路径</span></span><br><span class="line">                Path(root.left,expectNumber,expectNumber,[])</span><br><span class="line">                Path(root.right,expectNumber,expectNumber,[])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        Path(root,expectNumber,expectNumber,[])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>Q:</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p><strong>思路1：</strong>难点在给随机指针赋值时候怎样指向已存在的节点，这里的思路是通过next复制节点时，构造原节点与新节点一一对应的字典此方法因为用到哈希，空间复杂度较大</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24</span>:</span></span><br><span class="line">   <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">       Node_dic = &#123;&#125;</span><br><span class="line">       pre = pHead</span><br><span class="line">       clone_head = RandomListNode(pre.label)</span><br><span class="line">       p = clone_head</span><br><span class="line">       Node_dic[pre] = p</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           pre = pre.next</span><br><span class="line">           <span class="keyword">if</span> pre :</span><br><span class="line">               temp = RandomListNode(pre.label)</span><br><span class="line">               p.next = temp</span><br><span class="line">               p=p.next</span><br><span class="line">               <span class="comment"># 边复制节点边构造哈希表</span></span><br><span class="line">               Node_dic[pre] = p</span><br><span class="line">       pre = pHead</span><br><span class="line">       p = clone_head</span><br><span class="line">       <span class="keyword">while</span> pre:</span><br><span class="line">           <span class="keyword">if</span> pre.random:</span><br><span class="line">               p.random = Node_dic[pre.random]</span><br><span class="line">           pre = pre.next</span><br><span class="line">           p = p.next</span><br><span class="line">       <span class="keyword">return</span> clone_head</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>省去了空间复杂度，复制链表时一一间隔，将新节点插入原链表</p>
<p><strong>注意：</strong>不能用一个while（调整random指针的while）直接将合并的链表拆开</p>
<p>因为如果有random指向前面会出错，因为已经不是一一间隔了</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution24_2</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="comment"># 将新节点一一间隔插入原链表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            temp = RandomListNode(p.label)</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        new_head = pre.next</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            <span class="keyword">if</span> pre.random:</span><br><span class="line">                post.random = pre.random.next</span><br><span class="line">            pre = post.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> pre.next:</span><br><span class="line">                post = pre.next</span><br><span class="line">        pre = pHead</span><br><span class="line">        post = pre.next</span><br><span class="line">        <span class="comment"># 不能直接在上一个while直接将两链表分开，如果有random指向前面会出错，因为已经不是一一间隔了</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            pre.next = post.next</span><br><span class="line">            <span class="comment"># 考虑到尾节点情况</span></span><br><span class="line">            <span class="keyword">if</span> post.next:</span><br><span class="line">                post.next = post.next.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">            post = post.next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>Q:</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路：</strong>二叉搜索树中序序列便是升序序列，用中序遍历构造链表</p>
<p><strong>注意：</strong>需要两个全局变量记录起点指针self.head，还有上一节点的指针self.p</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution25</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = <span class="keyword">None</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        root = pRootOfTree</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Trans</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#temp保留右指针</span></span><br><span class="line">            temp_left = root.left</span><br><span class="line">            temp_right = root.right</span><br><span class="line">            self.Convert(temp_left)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.p:</span><br><span class="line">                self.p = root</span><br><span class="line">                self.head = root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.p.right = root</span><br><span class="line">                root.left = self.p</span><br><span class="line">                self.p = root</span><br><span class="line">            self.Convert(temp_right)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        Trans(root)</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>Q:</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>思路1：</strong>先用递归将所有可能的情况列出来，用sorted（）解决字典排序问题列出所有情况的方法：分成两个列表s1,s2 ，每次s2中的一个元素加入s1当做下一个s1，其余元素当做下一个s2，进行递归自己的解法：非常不优雅，先将str转为list，在转为str添加进去，还用到了py自带的排序解决字典序问题    如果不用自带排序，则可以参考LeetCode31</p>
<p><strong>注意：</strong>因为python中的字符串不可以更改，所以，先将str转为list，在转为str添加进去</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">allkinds</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">1</span>:</span><br><span class="line">                s = <span class="string">''</span>.join(s1+s2)</span><br><span class="line">                self.res.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">                <span class="comment"># 将选中元素替换到s2第一位</span></span><br><span class="line">                temp = s2[i]</span><br><span class="line">                s2[i]=s2[<span class="number">0</span>]</span><br><span class="line">                s2[<span class="number">0</span>]=temp</span><br><span class="line">                allkinds(s1+[s2[<span class="number">0</span>]],s2[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = sorted(ss)</span><br><span class="line">        allkinds([],s)</span><br><span class="line">        self.res = list(set(self.res))</span><br><span class="line">        <span class="keyword">return</span> sorted(self.res)</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>itertools.permutations用来返回所有排列（元组形式）的list’’.join() 将list、元组内的字符结合成字符串map函数将f应用于右边可迭代的每一个对象</p>
<p>Code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join,itertools.permutations(ss)))))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><strong>Q:</strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>思路1：</strong>python式</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput)[:k]</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>partition函数法（快排）：如果下标刚好是k(k-1)则左边(k-1则包含本身)便是所求，如果下标&gt;k则递归左边，下标&lt;k递归右边</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution28_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Partition</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = len(nums) - <span class="number">1</span></span><br><span class="line">            temp = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> nums[j] &gt; temp:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[i] &lt;= temp:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i] = temp</span><br><span class="line">            <span class="keyword">if</span> i == k - <span class="number">1</span> <span class="keyword">or</span> i == k - <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; k - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[:i], k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Partition(nums[i + <span class="number">1</span>:], k - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        Partition(tinput, k)</span><br><span class="line">        <span class="keyword">return</span> sorted(tinput[:k])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p><strong>Q:</strong>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</p>
<p><strong>思路：</strong></p>
<p>两个变量分别记录当前累加值(self.temp)与最大累加值(self.Max)。从头到尾累加数字如果self.temp&lt;0则在每次累加之前将其置0。<em>最关键一点就是用self.temp</em>记录最大值</p>
<p>动态规划思想：用f(i)表示以第i个数字结尾的子数组的最大和则max（f(i)）可由一下迭代公式求f(i)=Data<a href="i=0或f(i-1">i</a>&lt;=0)    f(i)=f(i-1)+Data<a href="i!=0并且f(i-1">i</a>&gt;0)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">-99</span></span><br><span class="line">        self.Max = <span class="number">-99</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> self.temp &lt; <span class="number">0</span>:</span><br><span class="line">                self.temp = <span class="number">0</span></span><br><span class="line">            self.temp += array[i]</span><br><span class="line">            <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">                self.Max = self.temp</span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h2><p><strong>Q:</strong>求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<p><strong>思路：</strong></p>
<p>10个数里面有1个个位1；每100个数里面有10个十位1（10、11、12……19）；每1000个数里面有100个百位1 ……</p>
<p>另外需要判断是否应该考虑剩余部分，剩余部分需要判断如115 里面有 10 + (115-110+1) 个十位1</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution30</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># count代表n的位数</span></span><br><span class="line">        count = len(str(n))</span><br><span class="line">        <span class="comment"># 这里相当于两位到 count-1位 第count 位要单独讨论</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,count+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># count为完整的倍数</span></span><br><span class="line">            times = n//(<span class="number">10</span>**i)</span><br><span class="line">            <span class="comment"># num 为每一份对应的1的个数</span></span><br><span class="line">            num = <span class="number">10</span> ** (i<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># rest 为除掉完整的份数剩下的</span></span><br><span class="line">            rest = n - times*(<span class="number">10</span>**i)</span><br><span class="line">            result += times * num</span><br><span class="line">            <span class="keyword">if</span> rest &gt;= <span class="number">2</span> * (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> rest &lt; (<span class="number">10</span>**(i<span class="number">-1</span>)):</span><br><span class="line">                result += <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += rest - (<span class="number">10</span>**(i<span class="number">-1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="将数组排成最小的数"><a href="#将数组排成最小的数" class="headerlink" title="将数组排成最小的数"></a>将数组排成最小的数</h2><p><strong>Q:</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>思路：</strong>全部转化为字符串，用itertools.permutations列出全组合，直接用min 找全组合中最小的</p>
<p><strong>注意：</strong>对itertools.permutations、map()、’ ‘.join的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            numbers[i] = str(numbers[i])</span><br><span class="line">        List = map(<span class="string">''</span>.join,list(itertools.permutations(numbers,len(numbers))))</span><br><span class="line">        <span class="keyword">return</span> int(min(List))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p><strong>Q:</strong>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p><strong>思路1：</strong>非递归，用栈</p>
<p>序列化：先序遍历得到字符串    </p>
<p> 反序列化：用栈记录字符串的节点，非#时入栈，flag指向添加方式1为左0为右，flag= =0时出栈，新元素入栈时flag = =1        遇到#号时flag= =0</p>
<p>注意：链接节点时候一定要注意指针。要用原节点去链接，而不是构造与原节点相同的节点链接（见注释）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_7_mine</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        root = TreeNode(s[<span class="number">0</span>])</span><br><span class="line">        stack = [root]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        flag = <span class="number">1</span> <span class="comment"># flag==1指示left添加且不用退栈，flag==0指示右边添加且要退栈</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].left = TreeNode(s[i])</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(stack[<span class="number">-1</span>].left)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack[<span class="number">-1</span>].right = TreeNode(s[i])</span><br><span class="line">                    pop_node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    <span class="comment"># stack.append(TreeNode(s[i]))  是错误的！！！这不是链接原节点，而是构造与原节点相同的节点链接</span></span><br><span class="line">                    stack.append(pop_node.right)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].left = None</span></span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#stack[-1].right = None</span></span><br><span class="line">                    stack = stack[:<span class="number">-1</span>]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>精简的递归思路</p>
<p>①通过 def <strong>init</strong>(self):构造flag全局变量指示遍历位置</p>
<p>②通过self.flag指示list位置建树，建树过程类似遍历过程，只不过遇到#return</p>
<p>③注意l元素本身为字符，给节点赋值时注意int化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.flag = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code her</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        l = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= len(l):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> l[self.flag] == <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(int(l[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的第K个节点"><a href="#二叉树的第K个节点" class="headerlink" title="二叉树的第K个节点"></a>二叉树的第K个节点</h2><p><strong>Q:</strong>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 /  3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<p><strong>思路：</strong>二叉搜索树中序遍历就是升序</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_5</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,res=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left,res)</span><br><span class="line">            res.append(root)</span><br><span class="line">            dfs(root.right,res)</span><br><span class="line">        dfs(pRoot,res)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>] <span class="keyword">if</span> k&lt;=len(res) <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p><strong>Q:</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>思路：</strong>先用嵌套for循环找出所有起始位置，对每个位置依次用递归函数搜寻</p>
<p><strong>注意：</strong>每次开始要用新的空list记录路径</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ok = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            ok.append([])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            ok[_//cols].append(matrix[_])</span><br><span class="line">        init = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                    init.append([i,j])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,ok,path,List=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=rows <span class="keyword">or</span> j&gt;=cols <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ok[i][j] == path[<span class="number">0</span>]:</span><br><span class="line">                List.append([i,j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">and</span> (search(i+<span class="number">1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j+<span class="number">1</span>,rows,cols,ok,path[<span class="number">1</span>:],List)</span><br><span class="line">                                <span class="keyword">or</span> search(i<span class="number">-1</span>,j,rows,cols,ok,path[<span class="number">1</span>:],List) <span class="keyword">or</span> search(i,j<span class="number">-1</span>,rows,cols,ok,path[<span class="number">1</span>:],List))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(init)):</span><br><span class="line">            <span class="keyword">if</span> search(init[x][<span class="number">0</span>],init[x][<span class="number">1</span>],rows, cols, ok, path,[]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="机器人运动范围"><a href="#机器人运动范围" class="headerlink" title="机器人运动范围"></a>机器人运动范围</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>递归模拟机器人走路，用个列表记录机器人走过的路就行</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_1</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">       <span class="comment"># write code here</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(x)</span>:</span></span><br><span class="line">           res = <span class="number">0</span></span><br><span class="line">           <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">               res += x % <span class="number">10</span></span><br><span class="line">               x = x//<span class="number">10</span></span><br><span class="line">           <span class="keyword">return</span> res</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i,j,rows,cols,threshold,List=[])</span>:</span></span><br><span class="line">           <span class="keyword">if</span> threshold&lt;<span class="number">0</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">if</span> i&gt;=cols <span class="keyword">or</span> j&gt;=rows <span class="keyword">or</span> Sum(i)+Sum(j)&gt;threshold <span class="keyword">or</span> [i,j] <span class="keyword">in</span> List:</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               List.append([i,j])</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>+search(i+<span class="number">1</span>,j,rows,cols,threshold,List)+search(i,j+<span class="number">1</span>,rows,cols,threshold,List)</span><br><span class="line">       <span class="keyword">return</span> search(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><p><strong>Q:</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>思路：</strong>有right就沿着right的left一直找下去找到尽头没有right就沿着父节点一直向上找，直到导找到该节点是父节点的left</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        p = pNode</span><br><span class="line">        <span class="keyword">if</span> p.right:</span><br><span class="line">            post = p.right</span><br><span class="line">            <span class="keyword">while</span> post.left:</span><br><span class="line">                post = post.left</span><br><span class="line">            <span class="keyword">return</span> post</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            <span class="keyword">if</span> p.next.left == p:</span><br><span class="line">                <span class="keyword">return</span> p.next</span><br><span class="line">            p = p.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>Q:</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p><strong>思路1：</strong>用self.temp记录当前深度，self.Max记录最大深度。先序self.temp+1，后序self.temp-1注意：不要思维定式先中后序只用一个</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">0</span></span><br><span class="line">        self.Max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.temp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.temp &gt; self.Max:</span><br><span class="line">            self.Max = self.temp</span><br><span class="line">        self.TreeDepth(pRoot.left)</span><br><span class="line">        self.TreeDepth(pRoot.right)</span><br><span class="line">        self.temp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Max</span><br></pre></td></tr></table></figure>
<p>**思路2：更棒的方法</p>
<p>通过 <strong><em>左子树或右子树最大深度+1为当前子树深度</em></strong> 进行递归</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>Q:</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p><strong>思路1：</strong>写一个递归函数判断深度，注意对max(left,right)的运用，即<strong><em>左子树或右子树最大深度+1为当前子树的深度（写出递归的关键所在）</em></strong>然后从根节点开始递归判断每个节点</p>
<p>缺点：根节点开始递归判断每个节点缺点：重复遍历节点，时间复杂度高</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> abs( self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right) ) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> max(left,right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>同样写一个递归函数判断深度，但是一旦出现不满足返回值便为 -1 ，同时在后序中  left &lt; 0 or right &lt; 0 的运用保证了一旦出现非平衡子树，-1就一直会传递到最后，最后只需在主函数中判断深度是否 &gt;=0 。</p>
<p><strong><em>对 -1 的传递真是太赞，好好体会</em></strong></p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.TreeDepth(pRoot) &gt;= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> <span class="keyword">or</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> abs(left - right) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p><strong>Q:</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>思路：</strong>写递归函数（输入为两个节点）递归比较，递归方式为haha(left.left,right.right) and haha(left.right,right.left)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(pRoot.left,pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right <span class="keyword">or</span> left.val != right.val :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.haha(left.left,right.right) <span class="keyword">and</span> self.haha(left.right,right.left)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h2><p><strong>Q:</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        NodeList = [pRoot]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> NodeList:</span><br><span class="line">            NextLayer = []</span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> NodeList:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            NodeList = NextLayer</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h2><p><strong>Q:</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p><strong>思路：</strong>据层序遍历修改。将val按照嵌套列表方式存储（即每个元素list为一层的val）。while 每次循环处理一层，<strong><em>NextLayer为贮存下层节点的临时list</em></strong>，遍历处理完本层节点后<strong><em>通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</em></strong>。最后按照奇偶顺序修改val列表即可。</p>
<p><strong>注意：</strong>将节点加入NextLayer时要判断存在与否，否则空类型也会被添加</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># Nodeque为循环遍历的node list</span></span><br><span class="line">        Nodeque = [pRoot]</span><br><span class="line">        <span class="comment"># res为嵌套list,每个元素list为每层的val</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 通过Nodeque = NextLayer一下子将本层节点更换为下层节点来推进循环</span></span><br><span class="line">        <span class="comment"># 即每一圈while为每层的处理</span></span><br><span class="line">        <span class="keyword">while</span> Nodeque:</span><br><span class="line">            <span class="comment"># NextLayer为本层节点的所有孩子节点</span></span><br><span class="line">            NextLayer = []</span><br><span class="line">            <span class="comment"># ValList存取本层所有节点的val</span></span><br><span class="line">            ValList = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> Nodeque:</span><br><span class="line">                ValList.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    NextLayer.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    NextLayer.append(node.right)</span><br><span class="line">            res.append(ValList)</span><br><span class="line">            Nodeque = NextLayer</span><br><span class="line">        transres = []</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(res):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                transres.append(v[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                transres.append(v)</span><br><span class="line">        <span class="keyword">return</span> transres</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p><strong>Q:</strong>输入两个链表，找出它们的第一个公共结点。这里的是指两个链表在某个节点之后会汇入同一个链表。</p>
<p><strong>思路：</strong>最后两个链表汇入一个链表，即最后公共长度是一样的。因此可以先遍历两个链表，得出长度差在较长链表上提前多走长度差的步数，再一一比较</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        length1 = <span class="number">0</span></span><br><span class="line">        length2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            length1 += <span class="number">1</span></span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            length2 += <span class="number">1</span></span><br><span class="line">            p2 = p2.next</span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        differ = abs(length1 - length2)</span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(differ):</span><br><span class="line">                p2 = p2.next</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val == p2.val:</span><br><span class="line">                <span class="keyword">return</span> p1</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组中出现次数超过一半的元素"><a href="#数组中出现次数超过一半的元素" class="headerlink" title="数组中出现次数超过一半的元素"></a>数组中出现次数超过一半的元素</h2><p><strong>Q:</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p><strong>思路1：</strong>用哈希记录每个元素出现的次数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[numbers[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[numbers[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dic[numbers[i]]&gt;len(numbers)/<span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> numbers[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路2：</strong>如果有个元素出现超过一半，那么这个元素比其他元素都多（废话）。据此，count记录所存储元素的计数，temp记录所存取元素。count == 0时，temp变为当前元素，count置1；count != 0时， 当前元素与temp相等，count+1否则-1;结束遍历一遍temp元素，看看是否次数超过一半。</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        temp = <span class="number">-99</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                temp = i</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i != temp:</span><br><span class="line">                    count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        kan = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == temp:</span><br><span class="line">                kan += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> kan &gt; len(numbers) // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p><strong>Q:</strong>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>思路：</strong>考虑o(N)的用丑数生成丑数，不再遍历多余的非丑数。建立uglynums列表按顺序保存丑数。除了1以外，丑数肯定是排在之前的丑数乘以2、3、5的结果。问题在于怎样确保列表里面的丑数是排好顺序的。假设最大丑数为M，计算下一个丑数时小于M的肯定已经在列表当中。对于乘以2而言，肯定存在某一个丑数，排在它之前的每个丑数乘以2都小于M，排在它之后的每个丑数乘以2都远大于M，我们只需要记录下这个丑数的位置m2，对于乘以3和5，同样存下m3、m5.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">    <span class="number">1.</span>更新标记只需要 +<span class="number">1</span> 即可，+<span class="number">1</span>之后再用到肯定大于M</span><br><span class="line">    <span class="number">2.</span>此代码精彩的地方在于省略了对新丑数是否=M的判断，见下一条</span><br><span class="line">    <span class="number">3.</span>有可能有几个数同时得到要添加的数值，如<span class="number">6</span>（<span class="number">2</span>*<span class="number">3</span>，<span class="number">3</span>*<span class="number">2</span>）则m2,m3需要同时更新，这里的三个并列的if相当于省略了对更新的数</span><br><span class="line">是否=M的判断</span><br></pre></td></tr></table></figure>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        uglynums = [<span class="number">1</span>]</span><br><span class="line">        m2 = m3 = m5 =<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,index+<span class="number">1</span>):</span><br><span class="line">            uglynums.append(min(uglynums[m2]*<span class="number">2</span>, uglynums[m3]*<span class="number">3</span>, uglynums[m5]*<span class="number">5</span>))</span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m2]*<span class="number">2</span>:</span><br><span class="line">                m2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m3]*<span class="number">3</span>:</span><br><span class="line">                m3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> uglynums[i] == uglynums[m5]*<span class="number">5</span>:</span><br><span class="line">                m5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> uglynums[index<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><p><strong>Q:</strong>统计一个数字在排序数组中出现的次数。</p>
<p><strong>思路：</strong>二分查找找到一个target，返回index，然后往两边扩展</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Getindex</span><span class="params">(self, data, left, right, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] == k:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> data[mid] &lt; k:</span><br><span class="line">            <span class="keyword">return</span> self.Getindex(data, mid+<span class="number">1</span>, right,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.Getindex(data,left,mid<span class="number">-1</span>,k)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(data) - <span class="number">1</span></span><br><span class="line">        flag = self.Getindex(data, left, right, k)</span><br><span class="line">        <span class="keyword">if</span> flag &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = r = flag</span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">1</span> <span class="keyword">and</span> data[l<span class="number">-1</span>] == k:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[<span class="number">0</span>] == k:</span><br><span class="line">                l =<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> r &lt;= len(data) - <span class="number">2</span> <span class="keyword">and</span> data[r+<span class="number">1</span>] == k:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[right] == k:</span><br><span class="line">                r = right</span><br><span class="line">            <span class="keyword">return</span> r - l + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    <summary type="html">
    <![CDATA[剑指offer刷题记录]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <link href="http://yoursite.com/2018/02/26/LeetCode/"/>
    <id>http://yoursite.com/2018/02/26/LeetCode/</id>
    <published>2018-02-26T01:13:07.000Z</published>
    <updated>2018-03-04T08:00:35.842Z</updated>
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.Two Sum</h2><p><strong>Q:</strong>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典，key为值，val为值所对应位置</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tag = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> tag:</span><br><span class="line">                <span class="keyword">return</span>[tag[nums[i]],i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tag[target-nums[i]]=i</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h2><p><strong>Q:</strong>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        takeover = <span class="number">0</span></span><br><span class="line">        root = n = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> takeover:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                takeover += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                takeover += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            takeover, val = divmod(takeover, <span class="number">10</span>)</span><br><span class="line">            <span class="comment"># 以下两行可以写成</span></span><br><span class="line">            <span class="comment"># n.next = n = ListNode(val)</span></span><br><span class="line">            n.next = ListNode(val)</span><br><span class="line">            n = n.next</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.Longest Substring Without Repeating Characters</h2><p><strong>Q:</strong>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="string">"abcabcbb"</span>, the answer <span class="keyword">is</span> <span class="string">"abc"</span>, which the length <span class="keyword">is</span> <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"bbbbb"</span>, the answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> the length of <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"pwwkew"</span>, the answer <span class="keyword">is</span> <span class="string">"wke"</span>, <span class="keyword">with</span> the length of <span class="number">3.</span> Note that the answer must be a substring, <span class="string">"pwke"</span> <span class="keyword">is</span> a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>建立字典key为值，val为该值最后一次出现的位置，用指针pre指向每次寻找的子串的开头位置</p>
<p><strong>注意：</strong>自己思路是对的，但是错在没考虑嵌套重复如 abcddoua 遍历到第二个d时候重复pre指向第二个d 而遍历到第二个a时pre指向第一个a后的b，显然错的（即pre应该始终在字典回溯值之前，pre只能向后移动）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringonglen</span><span class="params">(s)</span>:</span></span><br><span class="line">    usedchar = &#123;&#125;</span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedchar <span class="keyword">and</span> pre &lt;= usedchar[s[i]]:</span><br><span class="line">            pre = usedchar[s[i]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxlen = max(maxlen, i-pre+<span class="number">1</span>)</span><br><span class="line">        usedchar[s[i]] = i</span><br><span class="line">    <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p><strong>Q:</strong>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"babad"</span></span><br><span class="line"></span><br><span class="line">Output: <span class="string">"bab"</span></span><br><span class="line"></span><br><span class="line">Note: <span class="string">"aba"</span> <span class="keyword">is</span> also a valid answer.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①for遍历选中心元素，找齐所有中心元素（第一个while 向后 找出所有与所选中心元素重复的元素）  </p>
<p> ② l r 指示回文边界，向两遍扩展</p>
<p><strong>注意：</strong></p>
<p>①l r 始终指向有效边界（闭区间，考虑边界值仍然是回文区域） </p>
<p> ②注意边界情况判断，如第一个while循环判定条件有两个，应该把边界判断放在前面，要不会出现index越界</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    maxlen = real_l = real_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">        l, r, pos = i, i, i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ( pos &lt;= len(s) - <span class="number">1</span>) <span class="keyword">and</span> s[r] == s[pos]:</span><br><span class="line">            r = pos</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">1</span> <span class="keyword">and</span> r &lt; (len(s) - <span class="number">1</span>)) <span class="keyword">and</span> s[l - <span class="number">1</span>] == s[r + <span class="number">1</span>]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; maxlen:</span><br><span class="line">            maxlen = r - l + <span class="number">1</span></span><br><span class="line">            real_l = l</span><br><span class="line">            real_r = r</span><br><span class="line">    <span class="keyword">return</span> s[real_l:real_r+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h2><p><strong>Q:</strong>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">123</span></span><br><span class="line">Output:  <span class="number">321</span></span><br><span class="line">Input: <span class="number">-123</span></span><br><span class="line">Output: <span class="number">-321</span></span><br><span class="line">Input: <span class="number">120</span></span><br><span class="line">Output: <span class="number">21</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>①flag表示符号判断正数1负数-1</p>
<p> ②将int转为字符串形式，[::-1]表示字符串反转</p>
<p> ③bit_length表示位数的判断</p>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span>:</span></span><br><span class="line">    flag = (x&gt;<span class="number">0</span>)-(x&lt;<span class="number">0</span>)</span><br><span class="line">    val = flag*int(str(abs(x))[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> val*(val.bit_length()&lt;<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h2><p><strong>Q:</strong>Implement <code>atoi</code> to convert a string to an integer.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>此题太乱没做，总结答案</p>
<ol>
<li><p>str.strip（）用于移除首位指定字符串</p>
</li>
<li><p>str.isdigit()判断字符是否是数值</p>
</li>
<li><p>ord()将字符转换为ASCII码 chr()将ASCII码转为字符如ord(‘a’)</p>
<p> -&gt;  97    chr(97)  -&gt;  ‘a’4. 字符串跟数值问题注意overflow问题，这里是有符号函数所以max=2<strong>31-1 min=-2</strong>31</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>注意对大数的判断</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type str: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">###better to do strip before sanity check (although 8ms slower):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ls = list(s.strip())</span><br><span class="line"></span><br><span class="line">    sign = <span class="number">-1</span> <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ls[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'-'</span>, <span class="string">'+'</span>]: <span class="keyword">del</span> ls[<span class="number">0</span>]</span><br><span class="line">    ret, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(ls) <span class="keyword">and</span> ls[i].isdigit():</span><br><span class="line">        ret = ret * <span class="number">10</span> + ord(ls[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">-2</span> ** <span class="number">31</span>, min(sign * ret, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h2><p><strong>Q:</strong>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.负数不是回文数、非零且末位为零不是回文数</p>
<p>2.用数字一半部分来比较避免了翻转数字overflow问题（赞）</p>
<p><strong>注意：</strong></p>
<p>注意对大数的处理（用数字一半部分作比较）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; res:</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x = x // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> (x == res <span class="keyword">or</span> x == res // <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11.Container With Most Water"></a>11.Container With Most Water</h2><p><strong>Q:</strong>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>分析此题可以得到一个解题基础：最终得到的两块挡板左挡板L和右挡板R，L左边的所有挡板一定短于L，R右边的所有挡板一定短于R。据此，可以从轴两遍开始向内遍历，每次记录最值，并且下次从较短的挡板继续向内遍历。</p>
<p><strong>注意：</strong></p>
<p>注意对python 中用while True:    if XX:     break  来代替do while</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">( height)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type height: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(height) - <span class="number">1</span></span><br><span class="line">    l_h = height[l]</span><br><span class="line">    r_h = height[r]</span><br><span class="line">    val = maxval = min(l_h, r_h) * (r - l)</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r):</span><br><span class="line">        <span class="keyword">if</span> l_h &lt;= r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[l] &gt; l_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        l_h = height[l]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> l_h &gt; r_h:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> height[r] &gt; r_h <span class="keyword">or</span> l &gt;= r:</span><br><span class="line">                    <span class="keyword">if</span> r &gt; l:</span><br><span class="line">                        r_h = height[r]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        val = min(l_h, r_h) * (r - l)</span><br><span class="line">        <span class="keyword">if</span> val &gt; maxval:</span><br><span class="line">            maxval = val</span><br><span class="line">    <span class="keyword">return</span> maxval</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14.Longest Common Prefix"></a>14.Longest Common Prefix</h2><p><strong>Q:</strong>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到字符串们的最长前缀</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>关于zip()以及zip(* )的用法</p>
<p>前者相当于压缩到一个list中，后者相当于分开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">c=[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">zz=zip(a,b,c)</span><br><span class="line">print(zz)</span><br><span class="line"></span><br><span class="line">x,y,z=zip(*zz)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(z)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>)]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type strs: List[str]</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, group <span class="keyword">in</span> enumerate(zip(*strs)):</span><br><span class="line">        <span class="keyword">if</span> len(set(group)) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">    <span class="keyword">return</span> min(strs)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="15-3-Sum"><a href="#15-3-Sum" class="headerlink" title="15.3 Sum"></a>15.3 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>开头 排序 为了跳过重复元素（用dup记录上一元素）遍历一次用twosum函数返回（twosum函数也要去重）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        result = []</span><br><span class="line">        dup = <span class="number">-999</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != dup:</span><br><span class="line">                result.extend(self.twosum(nums[i],nums[i+<span class="number">1</span>:],nums[i]*<span class="number">-1</span>))</span><br><span class="line">            dup = nums[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twosum</span><span class="params">(self,p,arr,val)</span>:</span></span><br><span class="line">        box = set()</span><br><span class="line">        threesum = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> (val-arr[i] <span class="keyword">in</span> box):</span><br><span class="line">                temp = sorted([p,arr[i],val-arr[i]])</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> threesum:</span><br><span class="line">                    threesum.append(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                box.add(arr[i])</span><br><span class="line">        <span class="keyword">return</span> threesum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="16-3-Sum-Closest"><a href="#16-3-Sum-Closest" class="headerlink" title="16.3 Sum Closest"></a>16.3 Sum Closest</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = &#123;<span class="number">-1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">-4</span>&#125;, <span class="keyword">and</span> target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">    The sum that <span class="keyword">is</span> closest to the target <span class="keyword">is</span> <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>排序后根据大小查找</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    close = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        k = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;k:</span><br><span class="line">            sum = nums[i]+nums[j]+nums[k]</span><br><span class="line">            <span class="keyword">if</span> sum == target:</span><br><span class="line">                <span class="keyword">return</span> sum</span><br><span class="line">            <span class="keyword">if</span> abs(target-sum) &lt; abs(target-close):</span><br><span class="line">                close = sum</span><br><span class="line">            <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> close</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17-Letter-Combinations-of-a-Phone-Numbert"><a href="#17-Letter-Combinations-of-a-Phone-Numbert" class="headerlink" title="17.Letter Combinations of a Phone Numbert"></a>17.Letter Combinations of a Phone Numbert</h2><p><strong>Q:</strong>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:Digit string <span class="string">"23"</span></span><br><span class="line">Output: [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>递归思想 字符串拼接用 +</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type digits: str</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    mapping = &#123;<span class="string">'0'</span>: <span class="string">' '</span>, <span class="string">'1'</span>: <span class="string">''</span>, <span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span></span><br><span class="line">        , <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> len(digits) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list(mapping[digits[<span class="number">0</span>]])</span><br><span class="line">    pre_comb = self.letterCombinations(digits[:<span class="number">-1</span>])</span><br><span class="line">    last = mapping[digits[<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> [s + v <span class="keyword">for</span> s <span class="keyword">in</span> pre_comb <span class="keyword">for</span> v <span class="keyword">in</span> last]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="18-4-Sum"><a href="#18-4-Sum" class="headerlink" title="18.4 Sum"></a>18.4 Sum</h2><p><strong>Q:</strong>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="keyword">and</span> target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution set <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>列表之间的拼接用 ‘+’先两层嵌套for循环将所有两两组合之和求出来，再用twosum思想</p>
<p>去重</p>
<p>保证每个元素只添加一次(通过变量保存下标而不是值)</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            twosum = nums[i] + nums[j]</span><br><span class="line">            <span class="keyword">if</span> target - twosum <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">for</span> two <span class="keyword">in</span> range(len(dic[target - twosum])):</span><br><span class="line">                    thisfour = sorted([nums[i], nums[j]] +</span><br><span class="line">                                      [nums[dic[target - twosum][two][<span class="number">0</span>]], nums[dic[target - twosum][two][<span class="number">1</span>]]])</span><br><span class="line">                    <span class="comment"># and前条件用于去重；and后条件用于去除元素是否重复利用</span></span><br><span class="line">                    <span class="keyword">if</span> thisfour <span class="keyword">not</span> <span class="keyword">in</span> result <span class="keyword">and</span> len(set([i, j]) | set(dic[target - twosum][two])) == <span class="number">4</span>:</span><br><span class="line">                        result.append(thisfour)</span><br><span class="line">            <span class="keyword">if</span> twosum <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[twosum] = [[i, j]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[twosum].append([i, j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a>19.Remove Nth Node From End of List</h2><p><strong>Q:</strong>Given a linked list, remove the <em>n</em>th node from the end of list and return its head.</p>
<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>构造一个长度为n的滑窗，滑到最后注意判断如果删除了第一个元素（此时post.next = null）应返回head.next</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pre = head</span><br><span class="line">    post = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        post = post.next</span><br><span class="line">    <span class="comment"># 注意这一步，如果删除的是head，直接返回head.next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> post:</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    <span class="keyword">while</span> post.next:</span><br><span class="line">        pre = pre.next</span><br><span class="line">        post = post.next</span><br><span class="line">    pre.next = pre.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><p><strong>Q:</strong>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not..</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>not valid 只有三种情况，找准这三种情况的特点注意一手对ord()的应用</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">'('</span>,<span class="string">'&#123;'</span>,<span class="string">'['</span>]:</span><br><span class="line">            stack = stack + [s[i]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(stack)==<span class="number">0</span>:       <span class="comment"># 右括号比左括号多的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">1</span> <span class="keyword">and</span> ord(s[i])-ord(stack[<span class="number">-1</span>])!= <span class="number">2</span>:       <span class="comment">#左右括号不对称的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack = stack[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:                           <span class="comment"># 左括号比右括号多的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p><strong>Q:</strong>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>1.正常思路，用and终止while，l1 或 l2 的尾巴可以一并加上</p>
<p>2.递归思想找准结束条件，链表一个一个拼接</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">( l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    head = p = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            p.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        p = p.next</span><br><span class="line">    p.next = l1 <span class="keyword">or</span> l2       <span class="comment">#加上小尾巴</span></span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line"><span class="comment"># 递归做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type l1: ListNode</span></span><br><span class="line"><span class="string">    :type l2: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">or</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22.Generate Parentheses"></a>22.Generate Parentheses</h2><p><strong>Q:</strong>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>不带返回值的递归（用于添加或者修改），递归生成每个str</p>
<p>Left right 分别为左右括号的计数器</p>
<p>Init_str为目前生成的字符串</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution22</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left, right, init_str = n, n, <span class="string">''</span></span><br><span class="line">        result = []</span><br><span class="line">        self.generate(left,right,init_str,result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self,left,right,init_str,result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            result.append(init_str)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            self.generate(left<span class="number">-1</span>,right,init_str+<span class="string">'('</span>,result)</span><br><span class="line">        <span class="comment">#left &lt; right 为添加右括号条件</span></span><br><span class="line">        <span class="keyword">if</span> right <span class="keyword">and</span> left &lt; right:</span><br><span class="line">            self.generate(left,right<span class="number">-1</span>,init_str+<span class="string">')'</span>,result)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs"><a href="#24-wap-Nodes-in-Pairs" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-wap-Nodes-in-Pairs-1"><a href="#24-wap-Nodes-in-Pairs-1" class="headerlink" title="24.wap Nodes in Pairs"></a>24.wap Nodes in Pairs</h2><p><strong>Q:</strong>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:1-&gt;2-&gt;3-&gt;4</span><br><span class="line">output:2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>基本操作，但是遇到return head报错，return init.next就正确，没找到原因</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    init = ListNode(<span class="number">0</span>)</span><br><span class="line">    pre = init</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        p = pre.next</span><br><span class="line">        post = p.next</span><br><span class="line">        p.next = post.next</span><br><span class="line">        post.next = p</span><br><span class="line">        pre.next = post</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.next:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = p</span><br><span class="line">            p = p.next</span><br><span class="line">            post = p.next</span><br><span class="line">    <span class="keyword">return</span> init.next</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26.Remove Duplicates from Sorted Array"></a>26.Remove Duplicates from Sorted Array</h2><p><strong>Q:</strong>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line">It doesn<span class="string">'t matter what you leave beyond the new length.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单题，在数组内删除重复元素，两个指针write、read,修改时候</p>
<p>A[write + 1] = A[read]</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution26</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        write = <span class="number">0</span></span><br><span class="line">        read = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(A):</span><br><span class="line">            <span class="keyword">if</span> A[write] != A[read]:</span><br><span class="line">                <span class="comment"># 修改重复元素的方法</span></span><br><span class="line">                A[write + <span class="number">1</span>] = A[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                read += <span class="number">1</span></span><br><span class="line">        A = A[:write + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(A)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27.Remove Element"></a>27.Remove Element</h2><p><strong>Q:</strong>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">Your function should <span class="keyword">return</span> length = <span class="number">2</span>, <span class="keyword">with</span> the first two elements of nums being <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>简单的双指针</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution27</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        read = write =<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> read &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[read] != val:</span><br><span class="line">                nums[write] = nums[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">            read += <span class="number">1</span></span><br><span class="line">        nums = nums[:write]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29.Divide Two Integers"></a>29.Divide Two Integers</h2><p><strong>Q:</strong>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>不会位运算，看了discussion此题两个while循环，第一个为结束条件，第二个循环每次减去除数的1、2、4、8……倍，结束第二个循环继续从一倍开始。减完回到第一个循环的判定条件判断是否需要再进行第二个while，相当于指数高效的记录倍数</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution29</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">                temp, i = divisor, <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> dividend &gt;= temp:</span><br><span class="line">                    dividend -= temp</span><br><span class="line">                    res += i</span><br><span class="line">                    temp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    i &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:</span><br><span class="line">            res = -res</span><br><span class="line">        <span class="keyword">return</span> min(max(<span class="number">-2</span> ** <span class="number">31</span>,res), <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31.Next Permutation"></a>31.Next Permutation</h2><p><strong>Q:</strong>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>从这几个数组合中找到下一个比他大的数</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>较简单，尽可能更改最后几位，并且从后往前如果一直是递增则就是这几个数的最大排列如4321，从后找到第一个非递增的数字p（如1245763中的5），然后将此数字与之后数字中 大于它且最接近于它 的数字（6）交换，交换后将该位置之后的数字升序排列（1246357）该题要求在原数组中修改，因此我把之后按升序拍了的数组建立一个临时数组temp_list，用for循环写入原数组</p>
<p><strong><em>list.sort() 和 sorted(list)的区别</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">list.sort()就地修改无返回值 sorted(list)返回新列表，对所有可迭代对象均有效</span><br><span class="line">print(a.sort())         -&gt; None</span><br><span class="line">print(sorted(a))        -&gt; [1,2,3]</span><br><span class="line">a.sort()    print(a)    -&gt; [1,2,3]</span><br><span class="line"><span class="comment">#对于切片列表：</span></span><br><span class="line">a[1:].sort()    print(a)    -&gt;[3,2,1] 无效</span><br><span class="line">print(sorted(a[1:]))        -&gt;[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p> ①找与p交换的数字时从后往前找可以避免index越界问题   </p>
<p> ②考虑有重复数字问题    </p>
<p> ③while遍历时候考虑左右边界问题（如while p and 条件  -&gt;此为不超过左边界）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution31</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># while p用以阻止左边界越界</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> nums[p<span class="number">-1</span>] &gt;= nums[p]:</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">0</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = p - <span class="number">1</span></span><br><span class="line">            post = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># while post用以阻止左边界越界，同时从后往前找防止右边界越界</span></span><br><span class="line">            <span class="keyword">while</span> post <span class="keyword">and</span> nums[post]&lt;=nums[p]:</span><br><span class="line">                post -= <span class="number">1</span></span><br><span class="line">            temp = nums[p]</span><br><span class="line">            nums[p] = nums[post]</span><br><span class="line">            nums[post] = temp</span><br><span class="line">            temp_list = sorted(nums[p+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(p+<span class="number">1</span>,len(nums)):</span><br><span class="line">                nums[i] = temp_list[i-p<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33.Search in Rotated Sorted Array"></a>33.Search in Rotated Sorted Array</h2><p><strong>Q:</strong>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>在排序或类排序数组中查找首先想到二分法此题因为不需要考虑重复元素，较为简单，列出所有情况来即可，我的代码比较繁琐，边界值判定条件应该可以统一一下，懒得改了因为最后的6种判定条件互斥，所以用 抑或^ 或者 or 都行分情况讨论如图（类似高中数学题）</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution33</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left +right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target <span class="keyword">and</span> target &gt; nums[right])^(nums[right]&gt;nums[mid] <span class="keyword">and</span> nums[mid]&gt;target</span><br><span class="line">                        )^(target&gt;nums[right] <span class="keyword">and</span> nums[right]&gt;nums[mid]):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34.Search for a Range"></a>34.Search for a Range</h2><p><strong>Q:</strong>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given [<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>] <span class="keyword">and</span> target value <span class="number">8</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>很简单，因为是排序数组，所以先用二分法查找target,在从这个位置往两边扩展</p>
<p><strong>注意：</strong></p>
<p>①类似while pre&gt;0 and nums[pre] == target: 中判断while结束后的pre是否指向target(有可能因为边界条件跳出循环，并且边界仍满足target)来判断pre是否 -1    </p>
<p> ②第一个while l&lt;=r: 中‘=’存在不构成死循环的原因如果l=r且指向target接下来会return，如果l=r不指向target之后对于mid与target判定仍会跳出循环</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution34</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target):</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l == r <span class="keyword">and</span> nums[<span class="number">0</span>]==target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                pre = post = mid</span><br><span class="line">                <span class="keyword">while</span> pre&gt;<span class="number">0</span> <span class="keyword">and</span> nums[pre] == target:</span><br><span class="line">                    pre -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> post&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[post] == target:</span><br><span class="line">                    post += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[pre] != target:</span><br><span class="line">                    pre += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[post] != target:</span><br><span class="line">                    post -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [pre, post]</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35.Search Insert Position"></a>35.Search Insert Position</h2><p><strong>Q:</strong>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>没什么好说的，排序数列二分查找，注意边界值问题及while中的等号问题while 中 加’=’保证在无target的情况，mid在连续两位中的右边一位</p>
<p><strong>注意：</strong>target&gt;max情况</p>
<p><strong>Code</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution35</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> (len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&gt;=target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r: <span class="comment"># 加‘=’保证在无target的情况，mid在连续两位中的右边一位</span></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># target&gt;max情况</span></span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>**</p>
]]></content>
    <summary type="html">
    <![CDATA[LeetCode刷题记录]]>
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
